<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CollectionUtils工具类</title>
    <url>/2020/12/23/CollectionUtils%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<p>这篇讲的CollectionUtils工具类是在<code>apache下</code>的, 而不是springframework下的CollectionUtils。</p>
<p>个人觉得CollectionUtils在真实项目中,可以使你的代码更加简洁和安全。</p>
<p>所以需要倒入相关jar包,目前从maven找到最新jar包如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="API常用方法"><a href="#API常用方法" class="headerlink" title="API常用方法"></a>API常用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、除非元素为null，否则向集合添加元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.addIgnoreNull(personList,<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、将两个已排序的集合a和b合并为一个已排序的列表，以便保留元素的自然顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.collate(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3、将两个已排序的集合a和b合并到一个已排序的列表中，以便保留根据Comparator c的元素顺序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.collate(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b, Comparator&lt;? <span class="keyword">super</span> O&gt; c)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4、返回该个集合中是否含有至少有一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.containsAny(Collection&lt;?&gt; coll1, T... coll2)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 5、如果参数是null，则返回不可变的空集合，否则返回参数本身。（很实用 ,最终返回List EMPTY_LIST = new EmptyList&lt;&gt;()）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.emptyIfNull(Collection&lt;T&gt; collection)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 6、空安全检查指定的集合是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.isEmpty(Collection&lt;?&gt; coll)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 7、 空安全检查指定的集合是否为空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.isNotEmpty(Collection&lt;?&gt; coll)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8、反转给定数组的顺序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.reverseArray(Object[] array);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 9、差集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.subtract(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 10、并集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.union(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 11、交集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.intersection(Collection a, Collection b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *12、 交集的补集（析取）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.disjunction(Collection a, Collection b)</span><br></pre></td></tr></table></figure>
<h2 id="非对象集合交、并、差处理"><a href="#非对象集合交、并、差处理" class="headerlink" title="非对象集合交、并、差处理"></a>非对象集合交、并、差处理</h2><p>对于集合取交集、并集的处理其实有很多种方式,这里就介绍3种</p>
<ul>
<li>第一种 是CollectionUtils工具类</li>
<li>第二种 是List自带方法</li>
<li>第三种 是JDK1.8 stream 新特性</li>
</ul>
<h3 id="CollectionUtils工具类"><a href="#CollectionUtils工具类" class="headerlink" title="CollectionUtils工具类"></a>CollectionUtils工具类</h3><p>下面对于基本数据(包扩String)类型中的集合进行demo示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String[] arrayA = <span class="keyword">new</span> String[] &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;;</span><br><span class="line">       String[] arrayB = <span class="keyword">new</span> String[] &#123; <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span> &#125;;</span><br><span class="line">       List&lt;String&gt; listA = Arrays.asList(arrayA);</span><br><span class="line">       List&lt;String&gt; listB = Arrays.asList(arrayB);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//1、并集 union</span></span><br><span class="line">       System.out.println(CollectionUtils.union(listA, listB));</span><br><span class="line">       <span class="comment">//输出: [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//2、交集 intersection</span></span><br><span class="line">       System.out.println(CollectionUtils.intersection(listA, listB));</span><br><span class="line">       <span class="comment">//输出:[3, 4]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//3、交集的补集（析取）disjunction</span></span><br><span class="line">       System.out.println(CollectionUtils.disjunction(listA, listB));</span><br><span class="line">       <span class="comment">//输出:[1, 2, 5, 6]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//4、差集（扣除）</span></span><br><span class="line">       System.out.println(CollectionUtils.subtract(listA, listB));</span><br><span class="line">       <span class="comment">//输出:[1, 2]</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="List自带方法"><a href="#List自带方法" class="headerlink" title="List自带方法"></a>List自带方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] arrayA = <span class="keyword">new</span> String[] &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;;</span><br><span class="line">    String[] arrayB = <span class="keyword">new</span> String[] &#123; <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span> &#125;;</span><br><span class="line">    List&lt;String&gt; listA = Arrays.asList(arrayA);</span><br><span class="line">    List&lt;String&gt; listB = Arrays.asList(arrayB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、交集</span></span><br><span class="line">    List&lt;String&gt;  jiaoList = <span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    jiaoList.retainAll(listB);</span><br><span class="line">    System.out.println(jiaoList);</span><br><span class="line">    <span class="comment">//输出:[3, 4]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//2、差集</span></span><br><span class="line">    List&lt;String&gt;  chaList = <span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    chaList.removeAll(listB);</span><br><span class="line">    System.out.println(chaList);</span><br><span class="line">    <span class="comment">//输出:[1, 2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、并集 (先做差集再做添加所有）</span></span><br><span class="line">    List&lt;String&gt;  bingList = <span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    bingList.removeAll(listB); <span class="comment">// bingList为 [1, 2]</span></span><br><span class="line">    bingList.addAll(listB);  <span class="comment">//添加[3,4,5,6]</span></span><br><span class="line">    System.out.println(bingList);</span><br><span class="line">    <span class="comment">//输出:[1, 2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>注意</code> : <strong>intersection和retainAll的差别</strong></p>
<p>要注意的是它们的返回类型是不一样的,<code>intersection</code>返回的是一个新的List集合，而<code>retainAll</code>返回是Bollean类型那就说明retainAll方法是对原有集合进行处理再返回原有集合,会改变原有集合中的内容。</p>
<p><code>个人观点</code>：1、从性能角度来考虑的话,List自带会高点,因为它不用再创建新的集合。2、需要注意的是：因为retainAll因为会改变原有集合,所以该集合需要多次使用就不适合用retainAll。</p>
<p><code>注意</code>: Arrays.asList将数组转集合不能进行add和remove操作。</p>
<p><code>原因</code>：调用Arrays.asList()生产的List的add、remove方法时报异常，这是由<strong>Arrays.asList() 返回的市Arrays的内部类ArrayList， 而不是java.util.ArrayList</strong>。Arrays的内部类ArrayList和java.util.ArrayList都是继承AbstractList，remove、add等方法AbstractList中是默认throw UnsupportedOperationException而且不作任何操作。java.util.ArrayList重新了这些方法而Arrays的内部类ArrayList没有重新，所以会抛出异常。</p>
<p>所以正确做法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">List arrList = <span class="keyword">new</span> ArrayList(list);</span><br><span class="line">arrList.add(<span class="string">"6"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="JDK1-8-stream-新特性"><a href="#JDK1-8-stream-新特性" class="headerlink" title="JDK1.8 stream 新特性"></a>JDK1.8 stream 新特性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] arrayA = <span class="keyword">new</span> String[] &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;;</span><br><span class="line">    String[] arrayB = <span class="keyword">new</span> String[] &#123; <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span> &#125;;</span><br><span class="line">    List&lt;String&gt; listA = Arrays.asList(arrayA);</span><br><span class="line">    List&lt;String&gt; listB = Arrays.asList(arrayB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交集</span></span><br><span class="line">    List&lt;String&gt; intersection = listA.stream().filter(item -&gt; listB.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(intersection);</span><br><span class="line">    <span class="comment">//输出:[3, 4]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 差集 (list1 - list2)</span></span><br><span class="line">    List&lt;String&gt; reduceList = listA.stream().filter(item -&gt; !listB.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(reduceList);</span><br><span class="line">    <span class="comment">//输出:[1, 2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并集 （新建集合:1、是因为不影响原始集合。2、Arrays.asList不能add和remove操作。</span></span><br><span class="line">    List&lt;String&gt; listAll = listA.parallelStream().collect(toList());</span><br><span class="line">    List&lt;String&gt; listAll2 = listB.parallelStream().collect(toList());</span><br><span class="line">    listAll.addAll(listAll2);</span><br><span class="line">    System.out.println(listAll);</span><br><span class="line">    <span class="comment">//输出:[1, 2, 3, 4, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去重并集 </span></span><br><span class="line">    List&lt;String&gt; list =<span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    list.addAll(listB);</span><br><span class="line">    List&lt;String&gt; listAllDistinct = list.stream().distinct().collect(toList());</span><br><span class="line">    System.out.println(listAllDistinct);</span><br><span class="line">    <span class="comment">//输出:[1, 2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>总结</code> ： 这三种我还是<code>最喜欢第一种方式</code>，因为第二种还需要确定该集合是否被多次调用。第三种可读性不高。</p>
<h2 id="对象集合交、并、差处理"><a href="#对象集合交、并、差处理" class="headerlink" title="对象集合交、并、差处理"></a>对象集合交、并、差处理</h2><p>因为对象的equels比较是比较两个对象的内存地址，所以除非是同一对象，否则equel返回永远是false。</p>
<p>但我们实际开发中 在我们的业务系统中判断对象时有时候需要的不是一种严格意义上的相等，而是一种业务上的对象相等。在这种情况下，原生的equals方法就不能满足我们的需求了，所以这个时候我们需要重写equals方法。</p>
<p><code>说明</code> :String为什么可以使用equels方法为什么只要字符串相等就为true,那是因为String类重写了equal和hashCode方法，比较的是值。</p>
<h3 id="Person对象"><a href="#Person对象" class="headerlink" title="Person对象"></a>Person对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为什么重写equals方法一定要重写hashCode方法下面也会讲</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = name + age;</span><br><span class="line">        <span class="keyword">return</span> result.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 equals 方法 根据name和age都相同那么对象就默认相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Person u = (Person) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName().equals(u.getName()) &amp;&amp; (<span class="keyword">this</span>.age.equals(u.getAge()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 toString 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>这里根据name和age都相同那么就默认相同对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Person&gt; personList = Lists.newArrayList();</span><br><span class="line">    Person person1 = <span class="keyword">new</span> Person(<span class="string">"小小"</span>,<span class="number">3</span>);</span><br><span class="line">    Person person2 = <span class="keyword">new</span> Person(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    personList.add(person1);</span><br><span class="line">    personList.add(person2);</span><br><span class="line"></span><br><span class="line">    List&lt;Person&gt; person1List = Lists.newArrayList();</span><br><span class="line">    Person person3 = <span class="keyword">new</span> Person(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    Person person4 = <span class="keyword">new</span> Person(<span class="string">"大大"</span>,<span class="number">5</span>);</span><br><span class="line">    person1List.add(person3);</span><br><span class="line">    person1List.add(person4);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、差集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.subtract(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='小小', age=3&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、并集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.union(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='小小', age=3&#125;, Person&#123;name='中中', age=4&#125;, Person&#123;name='大大', age=5&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、交集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.intersection(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='中中', age=4&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4、交集的补集（析取）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.disjunction(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='小小', age=3&#125;, Person&#123;name='大大', age=5&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它两种方式就不在测了，因为都一样。</p>
<h2 id="为什么重写equels方法一定要重写hashCode方法"><a href="#为什么重写equels方法一定要重写hashCode方法" class="headerlink" title="为什么重写equels方法一定要重写hashCode方法"></a>为什么重写equels方法一定要重写hashCode方法</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>其实上面的Person类我可以只重写equels方法而不写hashCode方法,一样能达到上面的效果。但为什么还是建议写上呢？官方的说法是:<code>对象的equals方法被重写，那么对象的hashCode()也尽量重写</code>。</p>
<p>重写equals()方法就必须重写hashCode()方法的原因，从源头Object类讲起就更好理解了。</p>
<p>先来看Object关于hashCode()和equals()的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public native int hashCode();</span><br><span class="line">      </span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">         return (this == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>光从代码中我们可以知道，<code>hashCode()方法是一个本地native方法</code>，返回的是对象引用中存储的对象的内存地址。而equals方法是利用==来比较的也是对象的内存地址。从上边我们可以看出，hashCode方法和equals方法是一致的。还有最关键的一点，我们来看Object类中关于hashCode()方法的注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。    </span><br><span class="line">2.如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。    </span><br><span class="line">3.如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。</span><br><span class="line">   但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。</span><br></pre></td></tr></table></figure>
<p><code>整理</code> : hashCode()和equals()保持一致，如果equals方法返回true，那么两个对象的hasCode()返回值必须一样。如果equals方法返回false，hashcode可以不一样，但是这样不利于哈希表的性能，一般我们也不要这样做。</p>
<p>假设两个对象，重写了其equals方法，其相等条件是某属性相等，就返回true。如果不重写hashcode方法，其返回的依然是两个对象的内存地址值，必然不相等。这就出现了equals方法相等，但是hashcode不相等的情况。这不符合hashcode的规则。</p>
<h3 id="HashSet和Map集合类型"><a href="#HashSet和Map集合类型" class="headerlink" title="HashSet和Map集合类型"></a>HashSet和Map集合类型</h3><p>重写equals()方法就必须重写hashCode()方法主要是针对HashSet和Map集合类型,而对于List集合倒没什么影响。</p>
<p><code>原因</code>： 在向HashSet集合中存入一个元素时，HashSet会调用该对象（存入对象）的hashCode()方法来得到该对象的hashCode()值，然后<code>根据该hashCode值决定该对象在HashSet中存储的位置</code>。简单的说：<code>HashSet集合判断两个元素相等的标准是：两个对象通过equals()方法比较相等，并且两个对象的HashCode()方法返回值也相等</code>。如果两个元素通过equals()方法比较返回true，但是它们的hashCode()方法返回值不同，HashSet会把它们存储在不同的位置，依然可以添加成功。</p>
<p><code>这就是问题所在</code>：就是如果你只重写equals()方法，而不重写hashCode(),如果equals()为true,而它们的hashCode()方法返回值肯定不一样，因为它们都不是同一对象所以内存地址肯定不一样，所以它还是添加成功了，那么其实你写的equals()方法根本没啥软用。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p><strong>1、People类</strong></p>
<p>重写equals方法,但并没有hashCode方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 equals 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        People u = (People) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName().equals(u.getName()) &amp;&amp; (<span class="keyword">this</span>.age.equals(u.getAge()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 toString 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"People&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;People&gt; hashSet = Sets.newHashSet();</span><br><span class="line">    People people1 = <span class="keyword">new</span> People(<span class="string">"小小"</span>,<span class="number">3</span>);</span><br><span class="line">    People people2 = <span class="keyword">new</span> People(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    People people3 = <span class="keyword">new</span> People(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    People people4 = <span class="keyword">new</span> People(<span class="string">"大大"</span>,<span class="number">5</span>);</span><br><span class="line">    hashSet.add(people1);</span><br><span class="line">    hashSet.add(people2);</span><br><span class="line">    hashSet.add(people3);</span><br><span class="line">    hashSet.add(people4);</span><br><span class="line"></span><br><span class="line">    System.out.println(hashSet);</span><br><span class="line">    <span class="comment">//输出:[People&#123;name='小小', age=3&#125;, People&#123;name='中中', age=4&#125;, People&#123;name='大大', age=5&#125;, People&#123;name='中中', age=4&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显,我重写了equals方法,那么people2和people3的equals应该相同，所以不能放入HashSet,但它们的hashCode()方法返回不同，所以导致同样能放入HashSet。</p>
<p><code>重点</code>：对于Set集合必须要同时重写这两个方法，要不然Set的特性就被破坏了。</p>
<p>转载自：<a href="https://www.cnblogs.com/qdhxhz/p/10787130.html" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/p/10787130.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>DNF-包管理器</title>
    <url>/2020/12/06/DNF-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>DNF(Dandified Yum)是新一代的RPM软件包管理器。<br>DNF包管理器克服了YUM包管理器的一些瓶颈，提升了包括用户体验，内存占用，依赖分析，运行速度等多方面的内容。</p>
<h3 id="安装DNF"><a href="#安装DNF" class="headerlink" title="安装DNF"></a>安装DNF</h3><p>DNF并未默认安装在RHEL或CentOS7系统中，但可以在使用YUM的同时使用DNF。</p>
<ol>
<li>安装epel-release依赖：<code>yum install epel-release</code> 或者 <code>yum install epel-release -y</code></li>
<li>安装DNF包：<code>yum install dnf</code> 或者 <code>yum install dnf -y</code></li>
</ol>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>/etc/dnf/dnf.conf</p>
<h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h3><p>Add the following settings in [main] section of /etc/dnf/dnf.conf, and save the file.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy=http://&lt;ip address&gt;:&lt;port&gt;</span><br><span class="line">proxy_username=&lt;username&gt;</span><br><span class="line">proxy_password=&lt;password&gt;</span><br></pre></td></tr></table></figure>
<h3 id="DNF命令"><a href="#DNF命令" class="headerlink" title="DNF命令"></a>DNF命令</h3><p>与YUM基本保持一致，少数用法有区别。<br><a href="http://man.linuxde.net/dnf" target="_blank" rel="noopener">常用dnf命令</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##### 版本</span></span><br><span class="line">dnf –version  <span class="comment"># 查看DNF包管理器版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 帮助</span></span><br><span class="line">dnf <span class="built_in">help</span>  <span class="comment"># 查看所有的DNF命令及其用途</span></span><br><span class="line">dnf <span class="built_in">help</span> &lt;<span class="built_in">command</span>&gt;  <span class="comment"># 获取命令的使用帮助</span></span><br><span class="line">dnf <span class="built_in">history</span>  <span class="comment"># 查看 DNF 命令的执行历史</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 信息查看</span></span><br><span class="line">dnf repolist  <span class="comment"># 查看系统中可用的DNF软件库</span></span><br><span class="line">dnf search &lt;package&gt;  <span class="comment"># 搜索软件库中的RPM包</span></span><br><span class="line"></span><br><span class="line">dnf list installed  <span class="comment"># 列出所有安装的RPM包</span></span><br><span class="line">dnf list available  <span class="comment"># 列出所有可安装的RPM包</span></span><br><span class="line">dnf info &lt;package&gt;  <span class="comment"># 查看软件包详情</span></span><br><span class="line"></span><br><span class="line">dnf provides &lt;file&gt;  <span class="comment"># 查找某一文件的提供者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 软件包操作</span></span><br><span class="line">dnf install &lt;package&gt;  <span class="comment"># 安装软件包及其所需的所有依赖</span></span><br><span class="line">dnf update &lt;package&gt;  <span class="comment"># 升级软件包</span></span><br><span class="line">dnf remove &lt;package&gt;  <span class="comment"># 删除软件包</span></span><br><span class="line">dnf reinstall &lt;package&gt;  <span class="comment"># 重新安装特定软件包</span></span><br><span class="line">dnf distro-sync  <span class="comment"># 更新软件包到最新的稳定发行版</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 系统软件包</span></span><br><span class="line">dnf check-update  <span class="comment"># 检查系统所有软件包的更新</span></span><br><span class="line">dnf update  <span class="comment"># 升级所有系统软件包</span></span><br><span class="line">dnf clean all  <span class="comment"># 删除缓存的无用软件包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 组</span></span><br><span class="line">dnf grouplist</span><br><span class="line">dnf groupinstall <span class="string">'xxx'</span></span><br><span class="line">dnf groupupdate <span class="string">'xxx'</span></span><br><span class="line">dnf groupremove</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>DNF</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>LF will be replaced by CRLF</title>
    <url>/2020/12/10/LF-will-be-replaced-by-CRLF/</url>
    <content><![CDATA[<p>本文主要写了在 Hexo 博客中 出现 LF will be replaced by CRLF 的原因以及它的解决方式。</p>
<h5 id="出现的原因"><a href="#出现的原因" class="headerlink" title="出现的原因"></a>出现的原因</h5><ol>
<li>windows中的换行符为 CRLF，而在Linux下的换行符为LF，所以在执行add时出现提示 </li>
<li>CRLF和LF是两种不同的换行格式，git工作区默认为CRLF来作为换行符，<br> 所以当我们项目文件里有用的地方使用LF作为换行符，这个时候我们再继续git add<br> 或者git commit的时候就会弹出警告，当最终push到远程仓库的时候git会统一格式全部转化为用CRLF作为换行符 </li>
</ol>
<h5 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h5><ol>
<li>这个只是一个警告，我们直接忽略就好。</li>
<li>在hexo目下的.deploy_git目录下打开git bash 执行git config –global core.autocrlf false //禁用自动转换 </li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>加密算法</title>
    <url>/2020/12/24/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="对称性加密算法"><a href="#对称性加密算法" class="headerlink" title="对称性加密算法"></a>对称性加密算法</h2><p><img src="/2020/12/24/加密算法/1.jpg" alt="加密流程图"></p>
<p>对称式加密就是加密和解密使用同一个密钥。信息接收双方都需事先知道密匙和加解密算法且其密匙是相同的，之后便是对数据进行加解密了。对称加密算法用来对敏感数据等信息进行加密。</p>
<p>对称加密算法的优点是：算法公开、计算量小、加密速度快、加密效率高。用途：对称加密算法用来对敏感数据等信息进行加密</p>
<p>对称加密算法的缺点是：在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。</p>
<p><strong>DES</strong>：全称为Data Encryption Standard数据加密标准，速度较快，适用于加密大量数据的场合。</p>
<p><strong>3DES</strong>（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。</p>
<p><strong>AES</strong>：全称为Advanced Encryption Standard高级加密标准，是下一代的加密算法标准，速度快，安全级别高；AES是一个使用128为分组块的分组加密算法，分组块和128、192或256位的密钥一起作为输入，对4×4的字节数组上进行操作。众所周之AES是种十分高效的算法，尤其在8位架构中，这源于它面向字节的设计。AES 适用于8位的小型单片机或者普通的32位微处理器,并且适合用专门的硬件实现，硬件实现能够使其吞吐量（每秒可以到达的加密/解密bit数）达到十亿量级。同样，其也适用于RFID系统。</p>
<h2 id="非对称性算法"><a href="#非对称性算法" class="headerlink" title="非对称性算法"></a>非对称性算法</h2><p><img src="/2020/12/24/加密算法/2.jpg" alt="img"></p>
<p><strong>既然是加密，那肯定是不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证。</strong></p>
<p>与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p>
<p>非对称加密与有点是：安全性更好；对称加密的通信双方使用相同的秘钥，如果一方的秘钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对秘钥，一个用来加密，一个用来解密，而且公钥是公开的，秘钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥。</p>
<p>非对称加密的缺点是：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p>
<p><strong>RSA</strong>：全称为Digital Signature Algorithm，是第一个能同时用于加密和数字签名的算法，也易于理解和操作。RSA是被研究得最广泛的公钥算法，从提出到现今的三十多年里，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。</p>
<p><strong>DSA</strong>：全称为Digital Encryption Standard，是基于整数有限域离散对数难题的，其安全性与RSA相比差不多。DSA的一个重要特点是两个素数公开，这样，当使用别人的p和q时，即使不知道私钥，你也能确认它们是否是随机产生的，还是作了手脚。RSA算法却做不到。</p>
<p><strong>ECC</strong>：全称为Elliptic Curves Cryptography,，也叫椭圆加密算法，是一种公钥加密体制，最初由Koblitz和Miller两人于1985年提出，其数学基础是利用椭圆曲线上的有理点构成Abel加法群上椭圆离散对数的计算困难性。</p>
<blockquote>
<p>ECC和RSA相比，在许多方面都有对绝对的优势，主要体现在以下方面：</p>
<ol>
<li>抗攻击性强。相同的密钥长度，其抗攻击性要强很多倍。</li>
<li>计算量小，处理速度快。ECC总的速度比RSA、DSA要快得多。</li>
<li>存储空间占用小。ECC的密钥尺寸和系统参数与RSA、DSA相比要小得多，意味着它所占的存贮空间要小得多。这对于加密算法在IC卡上的应用具有特别重要的意义。</li>
<li>带宽要求低。当对长消息进行加解密时，三类密码系统有相同的带宽要求，但应用于短消息时ECC带宽要求却低得多。带宽要求低使ECC在无线网络领域具有广泛的应用前景。</li>
</ol>
</blockquote>
<h2 id="散列算法（签名算法）"><a href="#散列算法（签名算法）" class="headerlink" title="散列算法（签名算法）"></a>散列算法（签名算法）</h2><p><img src="/2020/12/24/加密算法/sl.png" alt="img"></p>
<p>散列算法，又称哈希函数，是一种单向加密算法。在信息安全技术中，经常需要验证消息的完整性，散列(Hash)函数提供了这一服务，它对不同长度的输入消息，产生固定长度的输出。这个固定长度的输出称为原输入消息的”散列”或”消息摘要”(Message digest)。散列算法不算加密算法，因为其结果是不可逆的，既然是不可逆的，那么当然不是用来加密的，而是签名。</p>
<p>用途：主要用于验证，防止信息被修。具体用途如：文件校验、数字签名、鉴权协议</p>
<p><strong>MD5</strong>：MD5是一种不可逆的加密算法，目前是最牢靠的加密算法之一，尚没有能够逆运算的程序被开发出来，它对应任何字符串都可以加密成一段唯一的固定长度的代码。</p>
<p><strong>SHA1</strong>：全称为Secure Hash Algorithm，即安全哈希算法，主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。有SHA-1，SHA-224，SHA-256，SHA-384，和SHA-512这几种单向散列算法，其中SHA-1已经不安全。而SHA-1基于MD5，MD5又基于MD4。</p>
<p><strong>HMAC</strong>：全称为Hash Message Authentication Code，即散列消息鉴别码，主要是利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。一般的，消息鉴别码用于验证传输于两个共 同享有一个密钥的单位之间的消息。HMAC 可以与任何迭代散列函数捆绑使用。MD5 和 SHA-1 就是这种散列函数。HMAC 还可以使用一个用于计算和确认消息鉴别值的密钥。</p>
<p><strong>建议：</strong> AES采用128为即可，RSA建议采用1024位的数字，ECC建议采用160位。RSA加密字符长度有限制，一般采用AES+RSA方式组合使用。</p>
<h2 id="Base64算法"><a href="#Base64算法" class="headerlink" title="Base64算法"></a>Base64算法</h2><p>Base64 加密算法是最常见的用于传递 8bit <strong>字节码的编码方式之一</strong></p>
<p>计算机任何数据都是按 ascii 码存储的，而 ascii 码的 128～256 之间的值是不可见字符，由于不同设备对字符处理方式有不同，可能会导致错误，不利于传输，所以把数据作为一个 Base64 编码，统统变成可见字符，出错可能性就降低了</p>
<p>Base64 是取 6 个比特为一组，计算它的 ascii 值，得到一个可见字符，在解码时按 6 个比特进行解码并读取，如 01010101101 等比特流，取 010110 计算它的 ascii 码，转化为可见字符，因此 Base64 <strong>还具备了数据压缩能力</strong></p>
<p>其实不是安全领域下的加密解密算法，只能算是一个编码算法，通常用于把二进制数据编码为可写的字符形式的数据，对数据内容进行编码来适合传输(可以对img图像编码用于传输)。这是一种可逆的编码方式。编码后的数据是一个字符串，其中包含的字符为：A-Z、a-z、0-9、+、/，共64个字符(26 + 26 + 10 + 1 + 1 = 64，其实是65个字符，“=”是填充字符。Base64要求把每三个8Bit的字节转换为四个6Bit的字节(3<em>8 = 4</em>6 = 24)，然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。原文的字节最后不够3个的地方用0来补足，转换时Base64编码用=号来代替。这就是为什么有些Base64编码会以一个或两个等号结束的原因，中间是不可能出现等号的，但等号最多只有两个。其实不用”=”也不耽误解码，之所以用”=”，可能是考虑到多段编码后的Base64字符串拼起来也不会引起混淆。)<br>Base64编码是从二进制到字符的过程，像一些中文字符用不同的编码转为二进制时，产生的二进制是不一样的，所以最终产生的Base64字符也不一样。例如”上网”对应utf-8格式的Base64编码是”5LiK572R”， 对应GB2312格式的Base64编码是”yc/N+A==”。<br>标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的“/”和“+”字符变为形如“%XX”的形式，而这些“%”号在存入数据库时还需要再进行转换，因为ANSI SQL中已将“%”号用作通配符。<br>为解决此问题，可采用一种用于URL的改进Base64编码，它不在末尾填充’=’号，并将标准Base64中的“+”和“/”分别改成了“-”和“<em>”，这样就免去了在URL编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。<br>另有一种用于正则表达式的改进Base64变种，它将“+”和“/”改成了“!”和“-”，因为“+”，“*”以及前面在IRCu中用到的“[”和“]”在正则表达式中都可能具有特殊含义。<br>此外还有一些变种，它们将“+/”改为“</em>-”或“.<em>”（用作编程语言中的标识符名称）或“.-”（用于XML中的Nmtoken）甚至“</em>:”（用于XML中的Name）。</p>
<h2 id="AES-RSA组合应用"><a href="#AES-RSA组合应用" class="headerlink" title="AES+RSA组合应用"></a>AES+RSA组合应用</h2><p>RSA与AES加密算法所产生的密钥数不一样，它们是如何进行加密的呢？</p>
<p>接收方生成RSA密钥对，将其中的RSA公钥传递给发送方(接收方与发送方建立连接是需要认证的，SSL/TLS协议可以确保RSA公钥的安全完整)，然后用RSA公钥对AES密钥进行加密，加密后的结果传递给接收方，接收方用RSA私钥解密后，得到AES密钥，最后使用AES密钥解密，从而达到安全互通数据的目的。(如下图所示)</p>
<p><img src="/2020/12/24/加密算法/3.png" alt="3"></p>
<p><img src="/2020/12/24/加密算法/4.jpg" alt="img"></p>
<h2 id="项目应用总结"><a href="#项目应用总结" class="headerlink" title="项目应用总结"></a>项目应用总结</h2><ol>
<li>加密算法是可逆的，用来对敏感数据进行保护。散列算法(签名算法、哈希算法)是不可逆的，主要用于身份验证。</li>
<li>对称加密算法使用同一个密匙加密和解密，速度快，适合给大量数据加密。对称加密客户端和服务端使用同一个密匙，存在被抓包破解的风险。</li>
<li>非对称加密算法使用公钥加密，私钥解密，私钥签名，公钥验签。安全性比对称加密高，但速度较慢。非对称加密使用两个密匙，服务端和客户端密匙不一样，私钥放在服务端，黑客一般是拿不到的，安全性高。</li>
<li>Base64不是安全领域下的加解密算法，只是一个编码算法，通常用于把二进制数据编码为可写的字符形式的数据，特别适合在http，mime协议下的网络快速传输数据。UTF-8和GBK中文的Base64编码结果是不同的。采用Base64编码不仅比较简短，同时也具有不可读性，即所编码的数据不会被人用肉眼所直接看到，但这种方式很初级，很简单。Base64可以对图片文件进行编码传输。</li>
<li>大量数据加密建议采用对称加密算法，提高加解密速度；小量的机密数据，可以采用非对称加密算法。在实际的操作过程中，我们通常采用的方式是：采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。</li>
<li>MD5标准密钥长度128位（128位是指二进制位。二进制太长，所以一般都改写成16进制，每一位16进制数可以代替4位二进制数，所以128位二进制数写成16进制就变成了128/4=32位。16位加密就是从32位MD5散列中把中间16位提取出来）；sha1标准密钥长度160位(比MD5摘要长32位)，Base64转换后的字符串理论上将要比原来的长1/3。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AES 加密方法，是对称的密码算法(加密与解密的密钥一致)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得一个 密钥长度为 128 位的 AES 密钥，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回经 BASE64 处理之后的密钥字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStrKeyAES</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyGenerator keyGen = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        SecureRandom secureRandom = <span class="keyword">new</span> SecureRandom(String.valueOf(System.currentTimeMillis()).getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="comment">// 这里可以是 128、192、256、越大越安全</span></span><br><span class="line">        keyGen.init(<span class="number">128</span>, secureRandom);</span><br><span class="line">        SecretKey secretKey = keyGen.generateKey();</span><br><span class="line">        <span class="keyword">return</span> base64_byteArr2Str(secretKey.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将使用 Base64 加密后的字符串类型的 secretKey 转为 SecretKey</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SecretKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecretKey <span class="title">strKey2SecretKey</span><span class="params">(String strKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] byteArr = base64_str2ByteArr(strKey);</span><br><span class="line">        SecretKeySpec secretKey = <span class="keyword">new</span> SecretKeySpec(byteArr, <span class="string">"AES"</span>);</span><br><span class="line">        <span class="keyword">return</span> secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   待加密内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKey 加密使用的 AES 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后的密文 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptAES(<span class="keyword">byte</span>[] content, SecretKey secretKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 加密 返回Base64编码的字符串密文</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String message, String secretKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SecretKey aesKey = AESUtil.strKey2SecretKey(secretKey);</span><br><span class="line">        <span class="comment">//加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptAESByteArr = AESUtil.encryptAES(message.getBytes(<span class="string">"utf-8"</span>), aesKey);</span><br><span class="line">        <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">        <span class="keyword">return</span> AESUtil.base64_byteArr2Str(encryptAESByteArr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 解密 传入Base64编码的字符串密文，返回解密后的字符串</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String encryptMsgBase64Str, String secretKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SecretKey aesKey = AESUtil.strKey2SecretKey(secretKey);</span><br><span class="line">        <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] messageByteArr = AESUtil.base64_str2ByteArr(encryptMsgBase64Str);</span><br><span class="line">        <span class="comment">//解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptAESByteArr = AESUtil.decryptAES(messageByteArr, aesKey);</span><br><span class="line">        String descyptAes = <span class="keyword">new</span> String(decryptAESByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="keyword">return</span> descyptAes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   待解密内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKey 解密使用的 AES 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解密后的明文 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptAES(<span class="keyword">byte</span>[] content, SecretKey secretKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转Base64编码字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">base64_byteArr2Str</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base64编码字符串转字节数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base64Key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] base64_str2ByteArr(String base64Key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getDecoder().decode(base64Key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RSA 是非对称的密码算法，密钥分公钥和私钥，公钥用来加密，私钥用于解密</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="title">RSAUtil</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成密钥对：密钥对中包含公钥和私钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含 RSA 公钥与私钥的 keyPair</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title">getKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        SecureRandom secureRandom = <span class="keyword">new</span> SecureRandom(String.valueOf(System.currentTimeMillis()).getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="comment">// 这里可以是1024、2048 初始化一个密钥对</span></span><br><span class="line">        keyPairGenerator.initialize(<span class="number">2048</span>, secureRandom);</span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="keyword">return</span> keyPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取公钥 (并进行Base64编码，返回一个 Base64 编码后的字符串)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个 Base64 编码后的公钥字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKey</span><span class="params">(KeyPair keyPair)</span> </span>&#123;</span><br><span class="line">        PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = publicKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> base64_byteArr2Str(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取私钥(并进行Base64编码，返回一个 Base64 编码后的字符串)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个 Base64 编码后的私钥字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPrivateKey</span><span class="params">(KeyPair keyPair)</span> </span>&#123;</span><br><span class="line">        PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = privateKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> base64_byteArr2Str(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Base64编码后的公钥转换成 PublicKey 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pubStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> PublicKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title">string2PublicKey</span><span class="params">(String pubStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(pubStr);</span><br><span class="line">        X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(bytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        PublicKey publicKey = keyFactory.generatePublic(keySpec);</span><br><span class="line">        <span class="keyword">return</span> publicKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Base64编码后的私钥转换成 PrivateKey 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> PrivateKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title">string2PrivateKey</span><span class="params">(String priStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(priStr);</span><br><span class="line">        PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(bytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        PrivateKey privateKey = keyFactory.generatePrivate(keySpec);</span><br><span class="line">        <span class="keyword">return</span> privateKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   待加密的内容 byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 加密所需的公钥对象 PublicKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后的字节数组 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] publicEncrypt(<span class="keyword">byte</span>[] content, PublicKey publicKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密并返回Base64编码的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String message, String publicKeyStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line">        PublicKey publicKey = RSAUtil.string2PublicKey(publicKeyStr);</span><br><span class="line">        <span class="comment">//用公钥加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicEncrypt = RSAUtil.publicEncrypt(message.getBytes(<span class="string">"utf-8"</span>), publicKey);</span><br><span class="line">        <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">        String encryptMsgBase64Str = RSAUtil.base64_byteArr2Str(publicEncrypt);</span><br><span class="line">        <span class="keyword">return</span> encryptMsgBase64Str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content    待解密的内容 byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 解密需要的私钥对象 PrivateKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解密后的字节数组 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] privateDecrypt(<span class="keyword">byte</span>[] content, PrivateKey privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密,返回字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String encryptMsgBase64Str, String privateKeyStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line">        PrivateKey privateKey = RSAUtil.string2PrivateKey(privateKeyStr);</span><br><span class="line">        <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptMsgByteArr = RSAUtil.base64_str2ByteArr(encryptMsgBase64Str);</span><br><span class="line">        <span class="comment">//用私钥解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptmsgByteArr = RSAUtil.privateDecrypt(encryptMsgByteArr, privateKey);</span><br><span class="line">        String decryptmsgStr = <span class="keyword">new</span> String(decryptmsgByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="keyword">return</span> decryptmsgStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转Base64编码字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">base64_byteArr2Str</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base64编码字符串转字节数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base64Key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] base64_str2ByteArr(String base64Key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getDecoder().decode(base64Key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESUtilTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            key = AESUtil.getStrKeyAES();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encryptFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//String sourceFilePath = "D://滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案.docx";</span></span><br><span class="line">        String sourceFilePath = <span class="string">"E:\\打印\\JasperReports+iReport报表开发详解.pdf"</span>;</span><br><span class="line">        <span class="comment">//String sourceFilePath = "D:\\1583915786661_html_2f4d5dc.png";</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// String destFilePath = "D://test//滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案jiami.docx";</span></span><br><span class="line">        String destFilePath = <span class="string">"D://test//JasperReports+iReport报表开发详解jm.pdf"</span>;</span><br><span class="line">        FileEncryptUtil.encryptFile(key, sourceFilePath, destFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decryptFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String sourceFilePath = <span class="string">"D://test//JasperReports+iReport报表开发详解jm.pdf"</span>;</span><br><span class="line">        <span class="comment">//String sourceFilePath = "D://test//滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案jiami.docx";</span></span><br><span class="line">      <span class="comment">//  String destFilePath = "E://test//滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案.docx";</span></span><br><span class="line">        String destFilePath = <span class="string">"E://test//JasperReports+iReport报表开发详解.pdf"</span>;</span><br><span class="line">        <span class="comment">//String destFilePath="E:\\11.png";</span></span><br><span class="line">        FileEncryptUtil.decryptFile(key, sourceFilePath, destFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//=================客户端=================</span></span><br><span class="line">            <span class="comment">//hello, i am infi, good night!加密</span></span><br><span class="line">            String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line">            System.out.println(<span class="string">"明文数据为："</span> + message);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成AES秘钥，并Base64编码</span></span><br><span class="line">            String aesKeyBase64Str = AESUtil.getStrKeyAES();</span><br><span class="line">            System.out.println(<span class="string">"AES秘钥Base64编码:"</span> + aesKeyBase64Str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//将Base64编码的字符串，转换成AES秘钥</span></span><br><span class="line">            SecretKey aesKey = AESUtil.strKey2SecretKey(aesKeyBase64Str);</span><br><span class="line">            <span class="comment">//加密</span></span><br><span class="line">            <span class="keyword">byte</span>[] encryptAESByteArr = AESUtil.encryptAES(message.getBytes(<span class="string">"utf-8"</span>), aesKey);</span><br><span class="line">            <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">            String encryptAESBase64Str = AESUtil.base64_byteArr2Str(encryptAESByteArr);</span><br><span class="line">            System.out.println(<span class="string">"加密并Base64编码的结果："</span> + encryptAESBase64Str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//##############   网络上传输的内容有Base64编码后的秘钥 和 Base64编码加密后的内容    #################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//===================服务端================</span></span><br><span class="line">            <span class="comment">//将Base64编码的字符串，转换成AES秘钥</span></span><br><span class="line">            SecretKey aesKeyFromNet = AESUtil.strKey2SecretKey(aesKeyBase64Str);</span><br><span class="line">            <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">            <span class="keyword">byte</span>[] encryptAESByteArrFromNet = AESUtil.base64_str2ByteArr(encryptAESBase64Str);</span><br><span class="line">            <span class="comment">//解密</span></span><br><span class="line">            <span class="keyword">byte</span>[] decryptAESByteArr = AESUtil.decryptAES(encryptAESByteArrFromNet, aesKeyFromNet);</span><br><span class="line">            String descyptAes = <span class="keyword">new</span> String(decryptAESByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//解密后的明文</span></span><br><span class="line">            System.out.println(<span class="string">"解密后的明文: "</span> + descyptAes);</span><br><span class="line">            <span class="keyword">if</span> (message.equals(descyptAes)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//封装方法测试</span></span><br><span class="line">            String miwen=AESUtil.encrypt(message,aesKeyBase64Str);</span><br><span class="line">            System.out.println(miwen);</span><br><span class="line">            String minwen=AESUtil.decrypt(miwen,aesKeyBase64Str);</span><br><span class="line">            System.out.println(minwen);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            encryptFile();</span><br><span class="line">            decryptFile();</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            System.err.println(<span class="string">"耗时："</span> + (end - begin) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAUtilTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//===============生成公钥和私钥，公钥传给客户端，私钥服务端保留==================</span></span><br><span class="line">            <span class="comment">//生成RSA公钥和私钥，并Base64编码</span></span><br><span class="line">            KeyPair keyPair = RSAUtil.getKeyPair();</span><br><span class="line">            String publicKeyStr = RSAUtil.getPublicKey(keyPair);</span><br><span class="line">            String privateKeyStr = RSAUtil.getPrivateKey(keyPair);</span><br><span class="line">            System.out.println(<span class="string">"RSA公钥Base64编码:"</span> + publicKeyStr);</span><br><span class="line">            System.out.println(<span class="string">"RSA私钥Base64编码:"</span> + privateKeyStr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//=================客户端=================</span></span><br><span class="line">            <span class="comment">//hello, i am infi, good night!加密</span></span><br><span class="line">            String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line">            <span class="comment">//将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line">            PublicKey publicKey = RSAUtil.string2PublicKey(publicKeyStr);</span><br><span class="line">            <span class="comment">//用公钥加密</span></span><br><span class="line">            <span class="keyword">byte</span>[] publicEncrypt = RSAUtil.publicEncrypt(message.getBytes(<span class="string">"utf-8"</span>), publicKey);</span><br><span class="line">            <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">            String encryptMsgBase64Str = RSAUtil.base64_byteArr2Str(publicEncrypt);</span><br><span class="line">            System.out.println(<span class="string">"公钥加密并Base64编码的结果："</span> + encryptMsgBase64Str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//##############    网络上传输的内容有Base64编码后的公钥 和 Base64编码后的公钥加密的内容     #################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//===================服务端================</span></span><br><span class="line">            <span class="comment">//将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line">            PrivateKey privateKey = RSAUtil.string2PrivateKey(privateKeyStr);</span><br><span class="line">            <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">            <span class="keyword">byte</span>[] encryptMsgFromNet = RSAUtil.base64_str2ByteArr(encryptMsgBase64Str);</span><br><span class="line">            <span class="comment">//用私钥解密</span></span><br><span class="line">            <span class="keyword">byte</span>[] privateDecryptmsgByteArr = RSAUtil.privateDecrypt(encryptMsgFromNet, privateKey);</span><br><span class="line">            String privateDecrypmsgtStr = <span class="keyword">new</span> String(privateDecryptmsgByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line">            <span class="comment">//解密后的明文</span></span><br><span class="line">            System.out.println(<span class="string">"解密后的明文: "</span> + privateDecrypmsgtStr);</span><br><span class="line">            <span class="keyword">if</span> (message.equals(privateDecrypmsgtStr)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//封装方法测试</span></span><br><span class="line">            String miwen=RSAUtil.encrypt(message,publicKeyStr);</span><br><span class="line">            System.out.println(<span class="string">"密文: "</span> + miwen);</span><br><span class="line">            String mingwen=RSAUtil.decrypt(miwen,privateKeyStr);</span><br><span class="line">            System.out.println(<span class="string">"明文: "</span> + mingwen);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESAndRSATest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//测试RSA与AES的结合。</span></span><br><span class="line">    <span class="comment">//客户端：AES秘钥加密明文得到密文，然后用从服务器获取的RSA公钥加密AES秘钥，网络传输密文和RSA加密后的AES秘钥到服务器</span></span><br><span class="line">    <span class="comment">//服务端：用RSA私钥解密AES秘钥，解密后的AES秘钥再用来解密密文，得到明文。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//===============生成公钥和私钥，公钥传给客户端，私钥服务端保留==================</span></span><br><span class="line">        <span class="comment">//生成RSA公钥和私钥，并Base64编码，生成一次以后，就写死在配置文件或代码中，下次不再重新生成</span></span><br><span class="line">        KeyPair keyPair = RSAUtil.getKeyPair();</span><br><span class="line">        String publicKeyStr = RSAUtil.getPublicKey(keyPair);</span><br><span class="line">        String privateKeyStr = RSAUtil.getPrivateKey(keyPair);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥Base64编码:"</span> + publicKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥Base64编码:"</span> + privateKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=================客户端=================</span></span><br><span class="line">        <span class="comment">//hello, i am infi, good night!  需要加密的实际内容</span></span><br><span class="line">        String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line">        <span class="comment">//将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line">        PublicKey publicKey = RSAUtil.string2PublicKey(publicKeyStr);</span><br><span class="line">        <span class="comment">//生成AES秘钥，并Base64编码</span></span><br><span class="line">        String aesKeyStr = AESUtil.getStrKeyAES();</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥Base64编码:"</span> + aesKeyStr);</span><br><span class="line">        <span class="comment">//用公钥加密AES秘钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicEncryptAESKey = RSAUtil.publicEncrypt(aesKeyStr.getBytes(<span class="string">"utf-8"</span>), publicKey);</span><br><span class="line">        <span class="comment">//公钥加密AES秘钥后的内容Base64编码</span></span><br><span class="line">        String publicEncryptAESKeyStr = RSAUtil.base64_byteArr2Str(publicEncryptAESKey);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥加密AES秘钥并Base64编码的结果："</span> + publicEncryptAESKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Base64编码后的AES秘钥转换成SecretKey对象</span></span><br><span class="line">        SecretKey aesKey = AESUtil.strKey2SecretKey(aesKeyStr);</span><br><span class="line">        <span class="comment">//用AES秘钥加密实际的内容</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptAES = AESUtil.encryptAES(message.getBytes(<span class="string">"utf-8"</span>), aesKey);</span><br><span class="line">        <span class="comment">//AES秘钥加密后的内容Base64编码</span></span><br><span class="line">        String encryptAESStr = AESUtil.base64_byteArr2Str(encryptAES);</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥加密实际的内容并Base64编码的结果："</span> + encryptAESStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//##############   网络上传输的内容有Base64编码后的公钥加密AES秘钥的结果 和 Base64编码后的AES秘钥加密实际内容的结果   #################</span></span><br><span class="line">        <span class="comment">//##############   即publicEncryptAESKeyStr和encryptAESStr  ###################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//===================服务端================</span></span><br><span class="line">        <span class="comment">//将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line">        PrivateKey privateKey = RSAUtil.string2PrivateKey(privateKeyStr);</span><br><span class="line">        <span class="comment">//公钥加密AES秘钥后的内容(Base64编码)，进行Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicEncryptAESKeyFromNet = RSAUtil.base64_str2ByteArr(publicEncryptAESKeyStr);</span><br><span class="line">        <span class="comment">//用私钥解密,得到aesKey</span></span><br><span class="line">        <span class="keyword">byte</span>[] aesKeyStrBytes = RSAUtil.privateDecrypt(publicEncryptAESKeyFromNet, privateKey);</span><br><span class="line">        <span class="comment">//解密后的aesKey</span></span><br><span class="line">        String aesKeyStrFromNet = <span class="keyword">new</span> String(aesKeyStrBytes,<span class="string">"utf-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥解密AES秘钥并Base64编码的结果: "</span> + aesKeyStrFromNet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Base64编码后的AES秘钥转换成SecretKey对象</span></span><br><span class="line">        SecretKey aesKey2 = AESUtil.strKey2SecretKey(aesKeyStrFromNet);</span><br><span class="line">        <span class="comment">//AES秘钥加密后的内容(Base64编码)，进行Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptAES2 = AESUtil.base64_str2ByteArr(encryptAESStr);</span><br><span class="line">        <span class="comment">//用AES秘钥解密实际的内容</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptAES = AESUtil.decryptAES(encryptAES2, aesKey2);</span><br><span class="line">        String decryptAESStr=<span class="keyword">new</span> String(decryptAES,<span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="comment">//解密后的实际内容</span></span><br><span class="line">        System.out.println(<span class="string">"解密后的实际内容: "</span> + decryptAESStr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (message.equals(decryptAESStr)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装方法测试</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSimple</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//===============生成公钥和私钥，公钥传给客户端，私钥服务端保留==================</span></span><br><span class="line">        <span class="comment">//生成RSA公钥和私钥，并Base64编码，生成一次以后，就写死在配置文件或代码中，下次不再重新生成</span></span><br><span class="line">        KeyPair keyPair = RSAUtil.getKeyPair();</span><br><span class="line">        String publicKeyStr = RSAUtil.getPublicKey(keyPair);</span><br><span class="line">        String privateKeyStr = RSAUtil.getPrivateKey(keyPair);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥Base64编码:"</span> + publicKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥Base64编码:"</span> + privateKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=================客户端=================</span></span><br><span class="line">        <span class="comment">//hello, i am infi, good night!  需要加密的实际内容</span></span><br><span class="line">        String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成AES秘钥，并Base64编码</span></span><br><span class="line">        String aesKeyStr = AESUtil.getStrKeyAES();</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥Base64编码:"</span> + aesKeyStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//用公钥加密AES秘钥</span></span><br><span class="line">        String publicEncryptAESKeyStr = RSAUtil.encrypt(aesKeyStr,publicKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥加密AES秘钥并Base64编码的结果："</span> + publicEncryptAESKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用AES秘钥加密实际的内容Base64编码</span></span><br><span class="line">        String encryptAESStr = AESUtil.encrypt(message, aesKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥加密实际的内容并Base64编码的结果："</span> + encryptAESStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//===================服务端================</span></span><br><span class="line">        <span class="comment">//用RSA私钥解密,得到aesKey</span></span><br><span class="line">        String aesKeyStrFromNet = RSAUtil.decrypt(publicEncryptAESKeyStr, privateKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥解密AES秘钥并Base64编码的结果: "</span> + aesKeyStrFromNet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用AES秘钥解密实际的内容</span></span><br><span class="line">        String decryptAESStr = AESUtil.decrypt(encryptAESStr, aesKeyStrFromNet);</span><br><span class="line">        <span class="comment">//解密后的实际内容</span></span><br><span class="line">        System.out.println(<span class="string">"AES解密后的实际内容: "</span> + decryptAESStr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (message.equals(decryptAESStr)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//test();</span></span><br><span class="line">            testSimple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>开博</title>
    <url>/2019/03/24/%E5%BC%80%E5%8D%9A/</url>
    <content><![CDATA[<p>记录生活<br>感悟人生</p>
]]></content>
  </entry>
  <entry>
    <title>hexo本地图片不显示</title>
    <url>/2020/12/10/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><ul>
<li><p>修改文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为<code>true</code></p>
</li>
<li><p>修改之后，再使用<code>hexo new post &quot;hexo本地图片不显示&quot;</code>时，目录的样子是</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo本地图片不显示</span><br><span class="line">├── 01.jpg</span><br><span class="line">├── 02.jpg</span><br><span class="line">└── 03.jpg</span><br><span class="line">...</span><br><span class="line">hexo本地图片不显示.md</span><br></pre></td></tr></table></figure>
<h3 id="安装插件hexo-asset-image"><a href="#安装插件hexo-asset-image" class="headerlink" title="安装插件hexo-asset-image"></a>安装插件hexo-asset-image</h3><ul>
<li>GitHub地址 <a href="https://github.com/xcodebuild/hexo-asset-image" target="_blank" rel="noopener">hexo-asset-image</a></li>
<li>npm安装 (需要提前安装Node.js)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p><img src="/2020/12/10/hexo本地图片不显示/1.png" alt="图片描述"><br><strong>注意</strong> 不要使用<code>npm install hexo-asset-image --save</code>这个命令安装,<strong>版本号不对</strong><br><img src="/2020/12/10/hexo本地图片不显示/2.png" alt="图片描述"></p>
<h3 id="版本差异"><a href="#版本差异" class="headerlink" title="版本差异"></a>版本差异</h3><h4 id="0-0-5版本"><a href="#0-0-5版本" class="headerlink" title="0.0.5版本"></a>0.0.5版本</h4><p><img src="/2020/12/10/hexo本地图片不显示/3.png" alt="图片描述"></p>
<h4 id="1-0-0版本"><a href="#1-0-0版本" class="headerlink" title="1.0.0版本"></a>1.0.0版本</h4><p><img src="/2020/12/10/hexo本地图片不显示/4.png" alt="图片描述"></p>
<h3 id="在md中书写格式（相对路径）"><a href="#在md中书写格式（相对路径）" class="headerlink" title="在md中书写格式（相对路径）"></a>在md中书写格式（相对路径）</h3><p>在md使用如下形式引用图片</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">01</span>](<span class="link">hexo本地图片不显示/01.jpg</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 这里要使用<code>&quot;/&quot;</code></p>
<h3 id="md文件名称和图片存放文件夹名称不同时"><a href="#md文件名称和图片存放文件夹名称不同时" class="headerlink" title="md文件名称和图片存放文件夹名称不同时"></a>md文件名称和图片存放文件夹名称不同时</h3><p><strong>注意</strong> <code>重命名md文件之后记得重命名文件夹，当md文件的名称与文件夹名称不同时，映射关系以md文件名称为主。会导致src图片路径找不到</code></p>
<p><img src="/2020/12/10/hexo本地图片不显示/5.png" alt="图片描述"></p>
<ul>
<li><code>文件和文件夹以url中的名称保持一致</code></li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>检查<code>_config.yml</code> 文件的<code>post_asset_folder:</code>选项是否为<code>true</code></li>
<li>检查创建文件之后的目录结构</li>
<li>检查<code>hexo-asset-image</code>插件的版本</li>
<li>检查路径引用图片的路径使用<code>/</code></li>
<li>检查md文件的文件名称和图片存放文件夹名称是否相同</li>
</ul>
<p>转载于：<a href="https://blog.csdn.net/Strong997/article/details/97767929" target="_blank" rel="noopener">https://blog.csdn.net/Strong997/article/details/97767929</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
