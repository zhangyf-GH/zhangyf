<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>CollectionUtils工具类</title>
    <url>/2020/CollectionUtils%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<p>这篇讲的CollectionUtils工具类是在<code>apache下</code>的, 而不是springframework下的CollectionUtils。</p>
<p>个人觉得CollectionUtils在真实项目中,可以使你的代码更加简洁和安全。</p>
<p>所以需要倒入相关jar包,目前从maven找到最新jar包如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="API常用方法"><a href="#API常用方法" class="headerlink" title="API常用方法"></a>API常用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、除非元素为null，否则向集合添加元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.addIgnoreNull(personList,<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、将两个已排序的集合a和b合并为一个已排序的列表，以便保留元素的自然顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.collate(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3、将两个已排序的集合a和b合并到一个已排序的列表中，以便保留根据Comparator c的元素顺序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.collate(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b, Comparator&lt;? <span class="keyword">super</span> O&gt; c)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4、返回该个集合中是否含有至少有一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.containsAny(Collection&lt;?&gt; coll1, T... coll2)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 5、如果参数是null，则返回不可变的空集合，否则返回参数本身。（很实用 ,最终返回List EMPTY_LIST = new EmptyList&lt;&gt;()）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.emptyIfNull(Collection&lt;T&gt; collection)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 6、空安全检查指定的集合是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.isEmpty(Collection&lt;?&gt; coll)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 7、 空安全检查指定的集合是否为空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.isNotEmpty(Collection&lt;?&gt; coll)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8、反转给定数组的顺序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.reverseArray(Object[] array);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 9、差集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.subtract(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 10、并集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.union(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 11、交集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.intersection(Collection a, Collection b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *12、 交集的补集（析取）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.disjunction(Collection a, Collection b)</span><br></pre></td></tr></table></figure>
<h2 id="非对象集合交、并、差处理"><a href="#非对象集合交、并、差处理" class="headerlink" title="非对象集合交、并、差处理"></a>非对象集合交、并、差处理</h2><p>对于集合取交集、并集的处理其实有很多种方式,这里就介绍3种</p>
<ul>
<li>第一种 是CollectionUtils工具类</li>
<li>第二种 是List自带方法</li>
<li>第三种 是JDK1.8 stream 新特性</li>
</ul>
<h3 id="CollectionUtils工具类"><a href="#CollectionUtils工具类" class="headerlink" title="CollectionUtils工具类"></a>CollectionUtils工具类</h3><p>下面对于基本数据(包扩String)类型中的集合进行demo示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String[] arrayA = <span class="keyword">new</span> String[] &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;;</span><br><span class="line">       String[] arrayB = <span class="keyword">new</span> String[] &#123; <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span> &#125;;</span><br><span class="line">       List&lt;String&gt; listA = Arrays.asList(arrayA);</span><br><span class="line">       List&lt;String&gt; listB = Arrays.asList(arrayB);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//1、并集 union</span></span><br><span class="line">       System.out.println(CollectionUtils.union(listA, listB));</span><br><span class="line">       <span class="comment">//输出: [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//2、交集 intersection</span></span><br><span class="line">       System.out.println(CollectionUtils.intersection(listA, listB));</span><br><span class="line">       <span class="comment">//输出:[3, 4]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//3、交集的补集（析取）disjunction</span></span><br><span class="line">       System.out.println(CollectionUtils.disjunction(listA, listB));</span><br><span class="line">       <span class="comment">//输出:[1, 2, 5, 6]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//4、差集（扣除）</span></span><br><span class="line">       System.out.println(CollectionUtils.subtract(listA, listB));</span><br><span class="line">       <span class="comment">//输出:[1, 2]</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="List自带方法"><a href="#List自带方法" class="headerlink" title="List自带方法"></a>List自带方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] arrayA = <span class="keyword">new</span> String[] &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;;</span><br><span class="line">    String[] arrayB = <span class="keyword">new</span> String[] &#123; <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span> &#125;;</span><br><span class="line">    List&lt;String&gt; listA = Arrays.asList(arrayA);</span><br><span class="line">    List&lt;String&gt; listB = Arrays.asList(arrayB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、交集</span></span><br><span class="line">    List&lt;String&gt;  jiaoList = <span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    jiaoList.retainAll(listB);</span><br><span class="line">    System.out.println(jiaoList);</span><br><span class="line">    <span class="comment">//输出:[3, 4]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//2、差集</span></span><br><span class="line">    List&lt;String&gt;  chaList = <span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    chaList.removeAll(listB);</span><br><span class="line">    System.out.println(chaList);</span><br><span class="line">    <span class="comment">//输出:[1, 2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、并集 (先做差集再做添加所有）</span></span><br><span class="line">    List&lt;String&gt;  bingList = <span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    bingList.removeAll(listB); <span class="comment">// bingList为 [1, 2]</span></span><br><span class="line">    bingList.addAll(listB);  <span class="comment">//添加[3,4,5,6]</span></span><br><span class="line">    System.out.println(bingList);</span><br><span class="line">    <span class="comment">//输出:[1, 2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>注意</code> : <strong>intersection和retainAll的差别</strong></p>
<p>要注意的是它们的返回类型是不一样的,<code>intersection</code>返回的是一个新的List集合，而<code>retainAll</code>返回是Bollean类型那就说明retainAll方法是对原有集合进行处理再返回原有集合,会改变原有集合中的内容。</p>
<p><code>个人观点</code>：1、从性能角度来考虑的话,List自带会高点,因为它不用再创建新的集合。2、需要注意的是：因为retainAll因为会改变原有集合,所以该集合需要多次使用就不适合用retainAll。</p>
<p><code>注意</code>: Arrays.asList将数组转集合不能进行add和remove操作。</p>
<p><code>原因</code>：调用Arrays.asList()生产的List的add、remove方法时报异常，这是由<strong>Arrays.asList() 返回的市Arrays的内部类ArrayList， 而不是java.util.ArrayList</strong>。Arrays的内部类ArrayList和java.util.ArrayList都是继承AbstractList，remove、add等方法AbstractList中是默认throw UnsupportedOperationException而且不作任何操作。java.util.ArrayList重新了这些方法而Arrays的内部类ArrayList没有重新，所以会抛出异常。</p>
<p>所以正确做法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">List arrList = <span class="keyword">new</span> ArrayList(list);</span><br><span class="line">arrList.add(<span class="string">"6"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="JDK1-8-stream-新特性"><a href="#JDK1-8-stream-新特性" class="headerlink" title="JDK1.8 stream 新特性"></a>JDK1.8 stream 新特性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] arrayA = <span class="keyword">new</span> String[] &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;;</span><br><span class="line">    String[] arrayB = <span class="keyword">new</span> String[] &#123; <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span> &#125;;</span><br><span class="line">    List&lt;String&gt; listA = Arrays.asList(arrayA);</span><br><span class="line">    List&lt;String&gt; listB = Arrays.asList(arrayB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交集</span></span><br><span class="line">    List&lt;String&gt; intersection = listA.stream().filter(item -&gt; listB.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(intersection);</span><br><span class="line">    <span class="comment">//输出:[3, 4]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 差集 (list1 - list2)</span></span><br><span class="line">    List&lt;String&gt; reduceList = listA.stream().filter(item -&gt; !listB.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(reduceList);</span><br><span class="line">    <span class="comment">//输出:[1, 2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并集 （新建集合:1、是因为不影响原始集合。2、Arrays.asList不能add和remove操作。</span></span><br><span class="line">    List&lt;String&gt; listAll = listA.parallelStream().collect(toList());</span><br><span class="line">    List&lt;String&gt; listAll2 = listB.parallelStream().collect(toList());</span><br><span class="line">    listAll.addAll(listAll2);</span><br><span class="line">    System.out.println(listAll);</span><br><span class="line">    <span class="comment">//输出:[1, 2, 3, 4, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去重并集 </span></span><br><span class="line">    List&lt;String&gt; list =<span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    list.addAll(listB);</span><br><span class="line">    List&lt;String&gt; listAllDistinct = list.stream().distinct().collect(toList());</span><br><span class="line">    System.out.println(listAllDistinct);</span><br><span class="line">    <span class="comment">//输出:[1, 2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>总结</code> ： 这三种我还是<code>最喜欢第一种方式</code>，因为第二种还需要确定该集合是否被多次调用。第三种可读性不高。</p>
<h2 id="对象集合交、并、差处理"><a href="#对象集合交、并、差处理" class="headerlink" title="对象集合交、并、差处理"></a>对象集合交、并、差处理</h2><p>因为对象的equels比较是比较两个对象的内存地址，所以除非是同一对象，否则equel返回永远是false。</p>
<p>但我们实际开发中 在我们的业务系统中判断对象时有时候需要的不是一种严格意义上的相等，而是一种业务上的对象相等。在这种情况下，原生的equals方法就不能满足我们的需求了，所以这个时候我们需要重写equals方法。</p>
<p><code>说明</code> :String为什么可以使用equels方法为什么只要字符串相等就为true,那是因为String类重写了equal和hashCode方法，比较的是值。</p>
<h3 id="Person对象"><a href="#Person对象" class="headerlink" title="Person对象"></a>Person对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为什么重写equals方法一定要重写hashCode方法下面也会讲</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = name + age;</span><br><span class="line">        <span class="keyword">return</span> result.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 equals 方法 根据name和age都相同那么对象就默认相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Person u = (Person) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName().equals(u.getName()) &amp;&amp; (<span class="keyword">this</span>.age.equals(u.getAge()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 toString 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>这里根据name和age都相同那么就默认相同对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Person&gt; personList = Lists.newArrayList();</span><br><span class="line">    Person person1 = <span class="keyword">new</span> Person(<span class="string">"小小"</span>,<span class="number">3</span>);</span><br><span class="line">    Person person2 = <span class="keyword">new</span> Person(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    personList.add(person1);</span><br><span class="line">    personList.add(person2);</span><br><span class="line"></span><br><span class="line">    List&lt;Person&gt; person1List = Lists.newArrayList();</span><br><span class="line">    Person person3 = <span class="keyword">new</span> Person(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    Person person4 = <span class="keyword">new</span> Person(<span class="string">"大大"</span>,<span class="number">5</span>);</span><br><span class="line">    person1List.add(person3);</span><br><span class="line">    person1List.add(person4);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、差集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.subtract(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='小小', age=3&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、并集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.union(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='小小', age=3&#125;, Person&#123;name='中中', age=4&#125;, Person&#123;name='大大', age=5&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、交集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.intersection(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='中中', age=4&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4、交集的补集（析取）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.disjunction(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='小小', age=3&#125;, Person&#123;name='大大', age=5&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它两种方式就不在测了，因为都一样。</p>
<h2 id="为什么重写equels方法一定要重写hashCode方法"><a href="#为什么重写equels方法一定要重写hashCode方法" class="headerlink" title="为什么重写equels方法一定要重写hashCode方法"></a>为什么重写equels方法一定要重写hashCode方法</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>其实上面的Person类我可以只重写equels方法而不写hashCode方法,一样能达到上面的效果。但为什么还是建议写上呢？官方的说法是:<code>对象的equals方法被重写，那么对象的hashCode()也尽量重写</code>。</p>
<p>重写equals()方法就必须重写hashCode()方法的原因，从源头Object类讲起就更好理解了。</p>
<p>先来看Object关于hashCode()和equals()的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public native int hashCode();</span><br><span class="line">      </span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">         return (this == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>光从代码中我们可以知道，<code>hashCode()方法是一个本地native方法</code>，返回的是对象引用中存储的对象的内存地址。而equals方法是利用==来比较的也是对象的内存地址。从上边我们可以看出，hashCode方法和equals方法是一致的。还有最关键的一点，我们来看Object类中关于hashCode()方法的注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。    </span><br><span class="line">2.如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。    </span><br><span class="line">3.如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。</span><br><span class="line">   但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。</span><br></pre></td></tr></table></figure>
<p><code>整理</code> : hashCode()和equals()保持一致，如果equals方法返回true，那么两个对象的hasCode()返回值必须一样。如果equals方法返回false，hashcode可以不一样，但是这样不利于哈希表的性能，一般我们也不要这样做。</p>
<p>假设两个对象，重写了其equals方法，其相等条件是某属性相等，就返回true。如果不重写hashcode方法，其返回的依然是两个对象的内存地址值，必然不相等。这就出现了equals方法相等，但是hashcode不相等的情况。这不符合hashcode的规则。</p>
<h3 id="HashSet和Map集合类型"><a href="#HashSet和Map集合类型" class="headerlink" title="HashSet和Map集合类型"></a>HashSet和Map集合类型</h3><p>重写equals()方法就必须重写hashCode()方法主要是针对HashSet和Map集合类型,而对于List集合倒没什么影响。</p>
<p><code>原因</code>： 在向HashSet集合中存入一个元素时，HashSet会调用该对象（存入对象）的hashCode()方法来得到该对象的hashCode()值，然后<code>根据该hashCode值决定该对象在HashSet中存储的位置</code>。简单的说：<code>HashSet集合判断两个元素相等的标准是：两个对象通过equals()方法比较相等，并且两个对象的HashCode()方法返回值也相等</code>。如果两个元素通过equals()方法比较返回true，但是它们的hashCode()方法返回值不同，HashSet会把它们存储在不同的位置，依然可以添加成功。</p>
<p><code>这就是问题所在</code>：就是如果你只重写equals()方法，而不重写hashCode(),如果equals()为true,而它们的hashCode()方法返回值肯定不一样，因为它们都不是同一对象所以内存地址肯定不一样，所以它还是添加成功了，那么其实你写的equals()方法根本没啥软用。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p><strong>1、People类</strong></p>
<p>重写equals方法,但并没有hashCode方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 equals 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        People u = (People) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName().equals(u.getName()) &amp;&amp; (<span class="keyword">this</span>.age.equals(u.getAge()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 toString 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"People&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;People&gt; hashSet = Sets.newHashSet();</span><br><span class="line">    People people1 = <span class="keyword">new</span> People(<span class="string">"小小"</span>,<span class="number">3</span>);</span><br><span class="line">    People people2 = <span class="keyword">new</span> People(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    People people3 = <span class="keyword">new</span> People(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    People people4 = <span class="keyword">new</span> People(<span class="string">"大大"</span>,<span class="number">5</span>);</span><br><span class="line">    hashSet.add(people1);</span><br><span class="line">    hashSet.add(people2);</span><br><span class="line">    hashSet.add(people3);</span><br><span class="line">    hashSet.add(people4);</span><br><span class="line"></span><br><span class="line">    System.out.println(hashSet);</span><br><span class="line">    <span class="comment">//输出:[People&#123;name='小小', age=3&#125;, People&#123;name='中中', age=4&#125;, People&#123;name='大大', age=5&#125;, People&#123;name='中中', age=4&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显,我重写了equals方法,那么people2和people3的equals应该相同，所以不能放入HashSet,但它们的hashCode()方法返回不同，所以导致同样能放入HashSet。</p>
<p><code>重点</code>：对于Set集合必须要同时重写这两个方法，要不然Set的特性就被破坏了。</p>
<p>转载自：<a href="https://www.cnblogs.com/qdhxhz/p/10787130.html" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/p/10787130.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>AC86U创建虚拟内存U盘读写速度不够</title>
    <url>/2021/AC86U%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98U%E7%9B%98%E8%AF%BB%E5%86%99%E9%80%9F%E5%BA%A6%E4%B8%8D%E5%A4%9F/</url>
    <content><![CDATA[<h4 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h4><p><code>AC86U</code> 升级固件后挂载虚拟内存总是提示读写速度不够，新固件的读取速度要求 <code>20M/s</code>，写入速度要求 <code>30M/s</code><br><img src="/2021/AC86U创建虚拟内存U盘读写速度不够/20210106091033.png" alt="img"></p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>修改参数限制</p>
<p><code>ssh</code> 登录到路由器，执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改写入速度限制，30替换为10</span><br><span class="line">sed -i &apos;s/^W_LIMIT=30/W_LIMIT=10/&apos; /koolshare/scripts/swap_make.sh</span><br><span class="line"></span><br><span class="line"># 修改读取速度限制，20替换为10</span><br><span class="line">sed -i &apos;s/^R_LIMIT=20/R_LIMIT=10/&apos; /koolshare/scripts/swap_make.sh</span><br></pre></td></tr></table></figure>
<p>以上参数可以根据自己的实际情况进行调整</p>
<p>完成后重新进入管理界面挂载虚拟内存即可</p>
]]></content>
      <categories>
        <category>network</category>
        <category>路由器</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title>DNF-包管理器</title>
    <url>/2020/DNF-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>DNF(Dandified Yum)是新一代的RPM软件包管理器。<br>DNF包管理器克服了YUM包管理器的一些瓶颈，提升了包括用户体验，内存占用，依赖分析，运行速度等多方面的内容。</p>
<h3 id="安装DNF"><a href="#安装DNF" class="headerlink" title="安装DNF"></a>安装DNF</h3><p>DNF并未默认安装在RHEL或CentOS7系统中，但可以在使用YUM的同时使用DNF。</p>
<ol>
<li>安装epel-release依赖：<code>yum install epel-release</code> 或者 <code>yum install epel-release -y</code></li>
<li>安装DNF包：<code>yum install dnf</code> 或者 <code>yum install dnf -y</code></li>
</ol>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>/etc/dnf/dnf.conf</p>
<h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h3><p>Add the following settings in [main] section of /etc/dnf/dnf.conf, and save the file.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy=http://&lt;ip address&gt;:&lt;port&gt;</span><br><span class="line">proxy_username=&lt;username&gt;</span><br><span class="line">proxy_password=&lt;password&gt;</span><br></pre></td></tr></table></figure>
<h3 id="DNF命令"><a href="#DNF命令" class="headerlink" title="DNF命令"></a>DNF命令</h3><p>与YUM基本保持一致，少数用法有区别。<br><a href="http://man.linuxde.net/dnf" target="_blank" rel="noopener">常用dnf命令</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##### 版本</span></span><br><span class="line">dnf –version  <span class="comment"># 查看DNF包管理器版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 帮助</span></span><br><span class="line">dnf <span class="built_in">help</span>  <span class="comment"># 查看所有的DNF命令及其用途</span></span><br><span class="line">dnf <span class="built_in">help</span> &lt;<span class="built_in">command</span>&gt;  <span class="comment"># 获取命令的使用帮助</span></span><br><span class="line">dnf <span class="built_in">history</span>  <span class="comment"># 查看 DNF 命令的执行历史</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 信息查看</span></span><br><span class="line">dnf repolist  <span class="comment"># 查看系统中可用的DNF软件库</span></span><br><span class="line">dnf search &lt;package&gt;  <span class="comment"># 搜索软件库中的RPM包</span></span><br><span class="line"></span><br><span class="line">dnf list installed  <span class="comment"># 列出所有安装的RPM包</span></span><br><span class="line">dnf list available  <span class="comment"># 列出所有可安装的RPM包</span></span><br><span class="line">dnf info &lt;package&gt;  <span class="comment"># 查看软件包详情</span></span><br><span class="line"></span><br><span class="line">dnf provides &lt;file&gt;  <span class="comment"># 查找某一文件的提供者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 软件包操作</span></span><br><span class="line">dnf install &lt;package&gt;  <span class="comment"># 安装软件包及其所需的所有依赖</span></span><br><span class="line">dnf update &lt;package&gt;  <span class="comment"># 升级软件包</span></span><br><span class="line">dnf remove &lt;package&gt;  <span class="comment"># 删除软件包</span></span><br><span class="line">dnf reinstall &lt;package&gt;  <span class="comment"># 重新安装特定软件包</span></span><br><span class="line">dnf distro-sync  <span class="comment"># 更新软件包到最新的稳定发行版</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 系统软件包</span></span><br><span class="line">dnf check-update  <span class="comment"># 检查系统所有软件包的更新</span></span><br><span class="line">dnf update  <span class="comment"># 升级所有系统软件包</span></span><br><span class="line">dnf clean all  <span class="comment"># 删除缓存的无用软件包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 组</span></span><br><span class="line">dnf grouplist</span><br><span class="line">dnf groupinstall <span class="string">'xxx'</span></span><br><span class="line">dnf groupupdate <span class="string">'xxx'</span></span><br><span class="line">dnf groupremove</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>DNF</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+GitPages搭建博客</title>
    <url>/2021/Hexo-GitPages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>假设：邮箱：<a href="mailto:aaa@163.com" target="_blank" rel="noopener">aaa@163.com</a>  </p>
<p>​            名字: aaa</p>
<p>1.到官网下载git安装包后安装</p>
<p>2.在Windows系统安装git后，配置SSH key </p>
<p>用git bash执行如下命令： windows中在C:\Users\zhangyf.ssh目录</p>
<p><code>$ cd ~/. ssh #检查本机已存在的ssh密钥</code></p>
<p>如果提示：No such file or directory 说明你是第一次使用git。</p>
<p><code>ssh-keygen -t rsa -C &quot;aaa@163.com&quot;</code></p>
<p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image002.png" alt="img"></p>
<p>将刚复制的内容粘贴到key那里，title随便填，保存。</p>
<p>3.测试是否成功</p>
<p>$ ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a> # 注意邮箱地址不用改</p>
<p>如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</p>
<p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
<p>看到这个信息说明SSH已配置成功！</p>
<p>此时你还需要配置：</p>
<p><code>git config --global user.email &quot;aaa@163.com&quot;</code></p>
<p><code>git config --global user.name &quot;aaa&quot;</code></p>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>在node.js官网下载安装包安装即可</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>首先在本地磁盘中建立一个Hexo文件夹用于存储本地文件(做本地文件保存以及测试使用)</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image004.jpg" alt="img"></p>
<p>然后在文件夹中右击打开git命令框(我第一次直接在桌面右击，所以命令行无效果)</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image006.jpg" alt="img"></p>
<p>在git命令框中安装hexo命令行工具 ，执行 <code>npm install -g hexo-cli</code> </p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image008.jpg" alt="img"></p>
<p> 初始化 ，执行<code>hexo init zyfblog</code> 加上zyfblog，则全部文件都在zyfblog下</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image010.jpg" alt="img"></p>
<p>执行<code>cd zyfblog</code> 进入zyfblog目录</p>
<p>启动服务，依次执行</p>
<p><code>(npm install --&gt;hexo server)</code></p>
<p>浏览器输入<a href="http://localhost:4000,按理来说应该会出现本地访问页面" target="_blank" rel="noopener">http://localhost:4000,按理来说应该会出现本地访问页面</a></p>
<h2 id="部署到GItPages"><a href="#部署到GItPages" class="headerlink" title="部署到GItPages"></a>部署到GItPages</h2><h3 id="在github上面创建项目"><a href="#在github上面创建项目" class="headerlink" title="在github上面创建项目"></a>在github上面创建项目</h3><p>假设:Owner为: zhangyfzone </p>
<p>​         <strong>Repository name必须为: zhangyfzone.github.io</strong></p>
<p>​         申请的域名：minmax.site</p>
<p><img src="/2021/Hexo-GitPages搭建博客/image-20210330094423950.png" alt="image-20210330094423950"></p>
<h3 id="DNS设置"><a href="#DNS设置" class="headerlink" title="DNS设置"></a>DNS设置</h3><p>如果没有域名，则只能通过GitPages默认链接访问<a href="https://zhangyfzone.github.io/" target="_blank" rel="noopener">https://zhangyfzone.github.io/</a></p>
<p>如果有域名，可将域名解析到zhangyfzone.github.io，这样比较简洁。</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image016.png" alt="img"></p>
<h3 id="hexo-CNAME设置"><a href="#hexo-CNAME设置" class="headerlink" title="hexo CNAME设置"></a>hexo CNAME设置</h3><p> Hexo目录下的source中建一个CNAME命名的文件夹(切记没有后缀)</p>
<p>创建方式：右键新建txt文本-&gt;输入你购买的域名minmax.site&gt;保存关闭</p>
<p>然后快捷键F2或者右键该文本重命名-&gt;将.txt后缀去掉-&gt;会提示文件不可用继续确定即可</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image018.jpg" alt="img"></p>
<p>内容如下所示</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image019.png" alt="img"></p>
<h3 id="github上绑定域名"><a href="#github上绑定域名" class="headerlink" title="github上绑定域名"></a>github上绑定域名</h3><p>在设置中的custom domain填入域名minmax.site 保存</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image021.png" alt="img"></p>
<h3 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改_config.yml</h3><p><img src="/2021/Hexo-GitPages搭建博客/clip_image023.jpg" alt="img"></p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image024.png" alt="img"></p>
<p>配置github项目连接(</p>
<p>deploy: </p>
<p>type: git </p>
<p>repos: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:zhangyfzone/zhangyfzone.github.io.git</p>
<p>branch: master):</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image026.jpg" alt="img"></p>
<h3 id="使用git发布"><a href="#使用git发布" class="headerlink" title="使用git发布"></a>使用git发布</h3><p>执行 <code>npm install hexo-deployer-git --save</code></p>
<p>基本的流程到这里快要结束了</p>
<p>信件一篇博文  <code>hexo new post &#39;第一篇博文&#39;</code>  可在source/post文件夹下面看到，可以编辑内容。</p>
<p>最后执行:<code>(hexo clean --&gt;hexo generate --&gt;hexo deploy)</code></p>
<p>你就可以通过域名看到你的博客了</p>
<p>记住，每次修改配置信息或者其他必须要执行上面的步骤，才可以使得配置信息生效。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>LF will be replaced by CRLF</title>
    <url>/2020/LF-will-be-replaced-by-CRLF/</url>
    <content><![CDATA[<p>本文主要写了在 Hexo 博客中 出现 LF will be replaced by CRLF 的原因以及它的解决方式。</p>
<h5 id="出现的原因"><a href="#出现的原因" class="headerlink" title="出现的原因"></a>出现的原因</h5><ol>
<li>windows中的换行符为 CRLF，而在Linux下的换行符为LF，所以在执行add时出现提示 </li>
<li>CRLF和LF是两种不同的换行格式，git工作区默认为CRLF来作为换行符，<br> 所以当我们项目文件里有用的地方使用LF作为换行符，这个时候我们再继续git add<br> 或者git commit的时候就会弹出警告，当最终push到远程仓库的时候git会统一格式全部转化为用CRLF作为换行符 </li>
</ol>
<h5 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h5><ol>
<li>这个只是一个警告，我们直接忽略就好。</li>
<li>在hexo目下的.deploy_git目录下打开git bash 执行git config –global core.autocrlf false //禁用自动转换 </li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI七层模型与TCP IP五层模型</title>
    <url>/2021/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8ETCP-IP%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="一、OSI参考模型"><a href="#一、OSI参考模型" class="headerlink" title="一、OSI参考模型"></a>一、OSI参考模型</h2><p>​    今天我们先学习一下以太网最基本也是重要的知识——OSI参考模型。</p>
<p> 1、OSI的来源</p>
<p>​    OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。</p>
<p>​    ISO为了更好的使网络应用更为普及，推出了OSI参考模型。其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能互联了。</p>
<p> 2、OSI七层模型的划分</p>
<p>​    OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互连系统参考模型。如下图。</p>
<p>​    每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。</p>
<p>  <img src="/2021/OSI七层模型与TCP-IP五层模型/705728-20160424234824085-667046040.png" alt="img"></p>
<p> 3、各层功能定义</p>
<p>​    这里我们只对OSI各层进行功能上的大概阐述，不详细深究，因为每一层实际都是一个复杂的层。后面我也会根据个人方向展开部分层的深入学习。这里我们就大概了解一下。我们从最顶层——应用层 开始介绍。整个过程以公司A和公司B的一次商业报价单发送为例子进行讲解。</p>
<p><1>  应用层</1></p>
<p>​    OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。</p>
<p>​    实际公司A的老板就是我们所述的用户，而他要发送的商业报价单，就是应用层提供的一种网络服务，当然，老板也可以选择其他服务，比如说，发一份商业合同，发一份询价单，等等。</p>
<p><2>  表示层</2></p>
<p>​    表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>
<p>​    由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。</p>
<p><3>  会话层</3></p>
<p>​    会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。   </p>
<p>​    会话层的同事拿到表示层的同事转换后资料，（会话层的同事类似公司的外联部），会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，外联部的同事就会终止此次会话。</p>
<p><4>  传输层</4></p>
<p>​    传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</p>
<p>​    传输层就相当于公司中的负责快递邮件收发的人，公司自己的投递员，他们负责将上一层的要寄出的资料投递到快递公司或邮局。</p>
<p><5>  网络层</5></p>
<p>​    本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p>
<p>​    网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递（陆运为例啊，空运好像直接就飞到北京了），首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。</p>
<p><6>  数据链路层 </6></p>
<p>​    将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</p>
<p>   数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。</p>
<p>​    MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</p>
<p>​    这个没找到合适的例子</p>
<p><7> 物理层   </7></p>
<p>​    实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>
<p>​     快递寄送过程中的交通工具，就相当于我们的物理层，例如汽车，火车，飞机，船。</p>
<p>4、通信特点：对等通信   </p>
<p>对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。</p>
<p><img src="/2021/OSI七层模型与TCP-IP五层模型/705728-20160424234824866-481636745.png" alt="img"></p>
<h2 id="二、TCP-IP五层模型"><a href="#二、TCP-IP五层模型" class="headerlink" title="二、TCP/IP五层模型"></a>二、TCP/IP五层模型</h2><p>  TCP/IP五层协议和OSI的七层协议对应关系如下。</p>
<p><img src="/2021/OSI七层模型与TCP-IP五层模型/705728-20160424234825491-384470376.png" alt="img"></p>
<p>  在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。</p>
<p><img src="/2021/OSI七层模型与TCP-IP五层模型/705728-20160424234826351-1957282396.png" alt="img"></p>
<p>在每一层实现的协议也各不同，即每一层的服务也不同.下图列出了每层主要的协议。其中每层中具体的协议，我会在后面的逐一学习。</p>
<p><img src="/2021/OSI七层模型与TCP-IP五层模型/705728-20160424234827195-1493107425.png" alt="img"></p>
<p>参考文献：</p>
<p>  1.百度百科：OSI参考模型</p>
<p>  2.<a href="http://blog.csdn.net/wdkirchhoff/article/details/43915825" target="_blank" rel="noopener">http://blog.csdn.net/wdkirchhoff/article/details/43915825</a></p>
]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客部署到VPS</title>
    <url>/2021/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>网上流传的武功秘籍分为两种：</p>
<ul>
<li>将 Hexo 项目上传到 VPS 上面后执行 <code>hexo server</code>，之后配置 Nginx 反向代理，让域名指向 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a>。</li>
<li>将 Hexo 在本地通过 <code>hexo generate</code> 生成静态文件，在通过 <code>hexo deploy</code> 部署到 VPS 上面，使用 Nginx 直接做 Web 服务器。</li>
</ul>
<p>相比第二种方式，第一种每次写博客与更新博客时候的操作会很繁琐。所以我们使用第二种方式进行部署，这样既可以将静态文件 deploy 到 VPS 上，也可以上传到 Github 上用作备份，操作性和安全性上都要胜于前者。</p>
<p>而对于第二种方式而言，常用的又有 <code>git hook</code> 和 <code>rsync</code> 两种自动部署解决方案。</p>
<p>本文主要介绍 <code>git hook</code> 部署过程，过程为：</p>
<p>我们在本地编辑文本，然后使用 Git 远程部署到 VPS 的 Git 仓库。<code>hexo d</code> 命令实际上只 deploy 了本地的 public 文件夹，Git Hooks 实际上就是当 Git 仓库收到最新的 push 时，将 Git 仓库接受到的内容复制到 VPS 上的网站目录内。相当于完成了手动将 public 文件夹复制到 VPS 的网站根目录里。</p>
<p>在vps上搭建hexo博客需要下面这些工具：</p>
<ol>
<li>Nginx: 用于博客展示</li>
<li>SSH：用于Git 推送</li>
<li>Git: 用于将生成的静态文件推送到vps上</li>
</ol>
<p>本文服务器环境为CentOS 7.6</p>
<p>之前本地已经搭建好Hexo博客，之前是提交到Github进行更新</p>
<h2 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h2><p>查看C:\Users\用户名\.ssh 下是否存在私钥文件<code>id_rsa</code>和公钥文件<code>id_rsa.pub</code></p>
<p>如果没有，则需要通过<code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code> 生成</p>
<h2 id="VPS端配置"><a href="#VPS端配置" class="headerlink" title="VPS端配置"></a>VPS端配置</h2><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p>ssh连接到VPS后，执行如下指令进行Git的安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum update &amp;&amp; upgrade -y</span><br><span class="line">yum install epel-release</span><br><span class="line">yum install git-core</span><br></pre></td></tr></table></figure>
<h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install nginx -y</span><br><span class="line">service nginx start  #启动nginx</span><br></pre></td></tr></table></figure>
<p>如果开启了防火墙，还要在防火墙上开启响应端口，操作如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-service=http</span><br><span class="line">firewall-cmd --permanent --zone=public --add-service=https</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">启动： systemctl start firewalld</span><br><span class="line">关闭： systemctl stop firewalld</span><br><span class="line">查看状态： systemctl status firewalld </span><br><span class="line">开机禁用 ： systemctl disable firewalld</span><br><span class="line">开机启用 ： systemctl enable firewalld</span><br></pre></td></tr></table></figure>
<p>安装完Nginx后，最好设置Nginx为开机自启动，操作如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable nginx</span><br></pre></td></tr></table></figure>
<h3 id="Git相关配置"><a href="#Git相关配置" class="headerlink" title="Git相关配置"></a>Git相关配置</h3><ol>
<li>新建git用户，在终端输入如下指令以新建账户，专门用于提交git</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line">adduser git #创建新用户，名为git</span><br></pre></td></tr></table></figure>
<p>接下来修改git账户的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 740 /etc/sudoers</span><br><span class="line">vi /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>在<code>root ALL=(ALL) ALL</code>下面新建一段字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git ALL=(ALL) install</span><br></pre></td></tr></table></figure>
<p>接着保存退出，并执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 440 /etc/sudoers</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建git仓库</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su git                 # 操作转到git用户</span><br><span class="line">cd                     # 定位到Home目录</span><br><span class="line">mkdir .ssh &amp;&amp; cd .ssh  # 创建.ssh文件夹并进入</span><br><span class="line">vi authorized_keys     # 创建密钥文件</span><br></pre></td></tr></table></figure>
<p>此时，将本地<code>id_rsa.pub</code>文件内的内容粘贴到新建的<code>authorized_keys</code>文件中。接下来执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd</span><br><span class="line">mkdir hexo.git &amp;&amp; cd hexo.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure>
<p>此时，在本地终端中输入<code>ssh git@VPS_ip</code>查看收否能连接，如果提示要密码，则需要在VPS内设置一下git用户的密码，操作如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd git</span><br></pre></td></tr></table></figure>
<p>接着设置git用户的密码，并在本地终端中重新连接，输入密码，应该就可以连接了。</p>
<p>如果部署时还是需要密码，则是authorized_keys 文件权限设置有问题，请查看博客里的另一篇文章 <a href="http://www.minmax.site/2021/03/25/authorized-keys不生效解决办法/" target="_blank" rel="noopener">authorized_keys不生效解决办法</a></p>
<ol start="3">
<li>接下来要创建网站的目录，并赋予权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line">cd /var/www</span><br><span class="line">mkdir hexo</span><br><span class="line">chown git:git -R /var/www/hexo</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>配置Git Hooks</li>
</ol>
<p>【注意】这一步在git用户下执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su git</span><br><span class="line">cd /home/git/hexo.git/hooks</span><br><span class="line">vi post-receive</span><br></pre></td></tr></table></figure>
<p>输入如下内容后保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">GIT_REPO=/home/git/hexo.git       #git仓库路径</span><br><span class="line">TMP_GIT_CLONE=/tmp/hexo</span><br><span class="line">PUBLIC_WWW=/var/www/hexo          #hexo网站目录</span><br><span class="line">rm -rf $&#123;TMP_GIT_CLONE&#125;</span><br><span class="line">git clone $GIT_REPO $TMP_GIT_CLONE</span><br><span class="line">rm -rf $&#123;PUBLIC_WWW&#125;/*</span><br><span class="line">cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125;</span><br></pre></td></tr></table></figure>
<p>接着赋予权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure>
<h3 id="Nginx相关配置"><a href="#Nginx相关配置" class="headerlink" title="Nginx相关配置"></a>Nginx相关配置</h3><p>【注意】本操作在root用户下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line">vim /etc/nginx/conf.d/hexo.conf</span><br></pre></td></tr></table></figure>
<p>插入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  80 ;</span><br><span class="line">    root /var/www/hexo; //这里可以改成你的网站目录地址，我将网站放在/var/www/hexo</span><br><span class="line">    server_name example.com www.example.com;   //这里输入你的域名或IP地址</span><br><span class="line">    access_log  /var/log/nginx/hexo_access.log;</span><br><span class="line">    error_log   /var/log/nginx/hexo_error.log;</span><br><span class="line">    location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ &#123;</span><br><span class="line">            root /var/www/hexo;</span><br><span class="line">            access_log   off;</span><br><span class="line">            expires      1d;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~* ^.+\.(css|js|txt|xml|swf|wav)$ &#123;</span><br><span class="line">        root /var/www/hexo;</span><br><span class="line">        access_log   off;</span><br><span class="line">        expires      10m;</span><br><span class="line">    &#125;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /var/www/hexo;      //这里可以改成你的网站目录地址，我将网站放在/var/www/hexo</span><br><span class="line">        if (-f $request_filename) &#123;</span><br><span class="line">            rewrite ^/(.*)$  /$1 break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启Nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>
<h2 id="本地Hexo配置修改"><a href="#本地Hexo配置修改" class="headerlink" title="本地Hexo配置修改"></a>本地Hexo配置修改</h2><p>在本地<code>hexo</code>博客文件下，编辑配置文件<code>\_config.yml</code>，修改<code>deploy</code>选项，可同时发布到github和vps</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo: git@github.com:zhangyfzone/zhangyfzone.github.io.git  #gitHub上用作备份</span><br><span class="line">    branch: master</span><br><span class="line">  - type: git</span><br><span class="line">    repo: ssh://git@VPSIP:端口号/~/hexo.git   #部署到VPS上</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
<p>保存修改后，便可以使用<code>hexo g</code>,<code>hexo d</code>等指令进行博客更新了。</p>
<h2 id="gitHub配置更改"><a href="#gitHub配置更改" class="headerlink" title="gitHub配置更改"></a>gitHub配置更改</h2><p>如果之前部署到github上时设置了域名，则再setting里把custom domain 之前设置的域名清除。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title>authorized_keys不生效解决办法</title>
    <url>/2021/authorized-keys%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>​        在Linux中部署git服务器时，window客户端 执行ssh-keygen在目录<code>C:\Users\zhangyf \.ssh</code> 生成 id_rsa和id_rsa.pub。</p>
<p>将id_rsa.pub内容上传到Linux的/home/git/.ssh/authorized_keys 时， <code>service sshd restart</code> 命令重启了SSH服务， </p>
<p>在windows 打开cmd执行ssh git@VPSIP  -p 28094 需要输入密码。</p>
<p>解决方案：</p>
<p>linux 目录结构为 /home/git/.ssh/authorized_keys  用户和组都为git</p>
<p>/home/git目录必须是 755权限 即drwxr-xr-x  </p>
<p>/home/git/.ssh目录必须是700权限(也就是drwx——)</p>
<p>/home/git/.ssh/authorized_keys 文件必须是600权限(也就是-rw——-)或者644</p>
<p>缺一不可</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo本地图片不显示</title>
    <url>/2020/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><ul>
<li><p>修改文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为<code>true</code></p>
</li>
<li><p>修改之后，再使用<code>hexo new post &quot;hexo本地图片不显示&quot;</code>时，目录的样子是</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo本地图片不显示</span><br><span class="line">├── 01.jpg</span><br><span class="line">├── 02.jpg</span><br><span class="line">└── 03.jpg</span><br><span class="line">...</span><br><span class="line">hexo本地图片不显示.md</span><br></pre></td></tr></table></figure>
<h3 id="安装插件hexo-asset-image"><a href="#安装插件hexo-asset-image" class="headerlink" title="安装插件hexo-asset-image"></a>安装插件hexo-asset-image</h3><ul>
<li>GitHub地址 <a href="https://github.com/xcodebuild/hexo-asset-image" target="_blank" rel="noopener">hexo-asset-image</a></li>
<li>npm安装 (需要提前安装Node.js)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p><img src="/2020/hexo本地图片不显示/1.png" alt="图片描述"><br><strong>注意</strong> 不要使用<code>npm install hexo-asset-image --save</code>这个命令安装,<strong>版本号不对</strong><br><img src="/2020/hexo本地图片不显示/2.png" alt="图片描述"></p>
<h3 id="版本差异"><a href="#版本差异" class="headerlink" title="版本差异"></a>版本差异</h3><h4 id="0-0-5版本"><a href="#0-0-5版本" class="headerlink" title="0.0.5版本"></a>0.0.5版本</h4><p><img src="/2020/hexo本地图片不显示/3.png" alt="图片描述"></p>
<h4 id="1-0-0版本"><a href="#1-0-0版本" class="headerlink" title="1.0.0版本"></a>1.0.0版本</h4><p><img src="/2020/hexo本地图片不显示/4.png" alt="图片描述"></p>
<h3 id="在md中书写格式（相对路径）"><a href="#在md中书写格式（相对路径）" class="headerlink" title="在md中书写格式（相对路径）"></a>在md中书写格式（相对路径）</h3><p>在md使用如下形式引用图片</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">01</span>](<span class="link">hexo本地图片不显示/01.jpg</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 这里要使用<code>&quot;/&quot;</code></p>
<h3 id="md文件名称和图片存放文件夹名称不同时"><a href="#md文件名称和图片存放文件夹名称不同时" class="headerlink" title="md文件名称和图片存放文件夹名称不同时"></a>md文件名称和图片存放文件夹名称不同时</h3><p><strong>注意</strong> <code>重命名md文件之后记得重命名文件夹，当md文件的名称与文件夹名称不同时，映射关系以md文件名称为主。会导致src图片路径找不到</code></p>
<p><img src="/2020/hexo本地图片不显示/5.png" alt="图片描述"></p>
<ul>
<li><code>文件和文件夹以url中的名称保持一致</code></li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>检查<code>_config.yml</code> 文件的<code>post_asset_folder:</code>选项是否为<code>true</code></li>
<li>检查创建文件之后的目录结构</li>
<li>检查<code>hexo-asset-image</code>插件的版本</li>
<li>检查路径引用图片的路径使用<code>/</code></li>
<li>检查md文件的文件名称和图片存放文件夹名称是否相同</li>
</ul>
<p>转载于：<a href="https://blog.csdn.net/Strong997/article/details/97767929" target="_blank" rel="noopener">https://blog.csdn.net/Strong997/article/details/97767929</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>java泛型</title>
    <url>/2021/java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。</p>
<p>什么是泛型？为什么要使用泛型？</p>
<blockquote>
<p><strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</strong></p>
<p><strong>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</strong>。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
</blockquote>
<h1 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h1><p>一个被举了无数次的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">"aaaa"</span>);</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">    String item = (String)arrayList.get(i);</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"item = "</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>毫无疑问，程序的运行结果会以崩溃结束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String1</span><br></pre></td></tr></table></figure>
<p>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p>
<p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//arrayList.add(100); 在编译阶段，编译器就会报错123</span></span><br></pre></td></tr></table></figure>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>泛型只在编译阶段有效。看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"类型相同"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<code>D/泛型测试: 类型相同</code>。</p>
<p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>
<p><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p>
<h1 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h1><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p>
<p>泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> 泛型标识 <span class="comment">/*（成员变量类型）*/</span> <span class="keyword">var</span>; </span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个最普通的泛型类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span></span><br><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为String.</span></span><br><span class="line">Generic&lt;String&gt; genericString = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"key_vlaue"</span>);</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + genericInteger.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + genericString.getKey());<span class="number">12345678</span></span><br><span class="line"><span class="number">12</span>-<span class="number">27</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">04.432</span> <span class="number">13063</span>-<span class="number">13063</span>/? D/泛型测试: key is <span class="number">123456</span></span><br><span class="line"><span class="number">12</span>-<span class="number">27</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">04.432</span> <span class="number">13063</span>-<span class="number">13063</span>/? D/泛型测试: key is key_vlaue12</span><br></pre></td></tr></table></figure>
<p>定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p>
<p>看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Generic generic = <span class="keyword">new</span> Generic(<span class="string">"111111"</span>);</span><br><span class="line">Generic generic1 = <span class="keyword">new</span> Generic(<span class="number">4444</span>);</span><br><span class="line">Generic generic2 = <span class="keyword">new</span> Generic(<span class="number">55.55</span>);</span><br><span class="line">Generic generic3 = <span class="keyword">new</span> Generic(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic1.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic2.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic3.getKey());</span><br><span class="line">D/泛型测试: key is <span class="number">111111</span></span><br><span class="line">D/泛型测试: key is <span class="number">4444</span></span><br><span class="line">D/泛型测试: key is <span class="number">55.55</span></span><br><span class="line">D/泛型测试: key is false1234</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ul>
<li><ol>
<li>泛型的类型参数只能是类类型，不能是简单类型。</li>
</ol>
</li>
<li><ol>
<li><p>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;      <span class="keyword">if</span>(ex_num <span class="keyword">instanceof</span> Generic&lt;Number&gt;)&#123;   </span><br><span class="line">&gt;      &#125; <span class="number">12</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当实现泛型接口的类，未传入泛型实参时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错："Unknown class"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当实现泛型接口的类，传入泛型实参时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Pear"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。</p>
<blockquote>
<p>尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。</p>
</blockquote>
<p><strong>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span><span class="keyword">throws</span> InstantiationException ,</span></span><br><span class="line"><span class="function">  IllegalAccessException</span>&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">Object obj = genericMethod(Class.forName(<span class="string">"com.test.test"</span>));<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="泛型方法的基本用法"><a href="#泛型方法的基本用法" class="headerlink" title="泛型方法的基本用法"></a>泛型方法的基本用法</h3><p>光看上面的例子有的同学可能依然会非常迷糊，我们再通过一个例子，把我泛型方法再总结一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">//所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">        public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">             this.key = keu</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">        <span class="comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span></span><br><span class="line">        T test = container.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">    <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "</span></span><br><span class="line"><span class="comment">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span></span><br><span class="line"><span class="comment">     * 所以这也不是一个正确的泛型方法声明。</span></span><br><span class="line"><span class="comment">    public void showkey(T genericObj)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类中的泛型方法"><a href="#类中的泛型方法" class="headerlink" title="类中的泛型方法"></a>类中的泛型方法</h3><p>当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericFruit</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"fruit"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"apple"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Person"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GenerateTest</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show_1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">        <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        GenerateTest&lt;Fruit&gt; generateTest = <span class="keyword">new</span> GenerateTest&lt;Fruit&gt;();</span><br><span class="line">        <span class="comment">//apple是Fruit的子类，所以这里可以</span></span><br><span class="line">        generateTest.show_1(apple);</span><br><span class="line">        <span class="comment">//编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span></span><br><span class="line">        <span class="comment">//generateTest.show_1(person);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法都可以成功</span></span><br><span class="line">        generateTest.show_2(apple);</span><br><span class="line">        generateTest.show_2(person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法也都可以成功</span></span><br><span class="line">        generateTest.show_3(apple);</span><br><span class="line">        generateTest.show_3(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法与可变参数"><a href="#泛型方法与可变参数" class="headerlink" title="泛型方法与可变参数"></a>泛型方法与可变参数</h3><p>再看一个泛型方法和可变参数的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printMsg</span><span class="params">( T... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T t : args)&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"t is "</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">printMsg(<span class="string">"111"</span>,<span class="number">222</span>,<span class="string">"aaaa"</span>,<span class="string">"2323.4"</span>,<span class="number">55.55</span>);<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h3><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</strong></p>
<p>即：<strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">          "StaticGenerator cannot be refrenced from static context"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法总结"><a href="#泛型方法总结" class="headerlink" title="泛型方法总结"></a>泛型方法总结</h3><p>泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则：</p>
<blockquote>
<p>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法</p>
</blockquote>
<h2 id="泛型中通配符"><a href="#泛型中通配符" class="headerlink" title="泛型中通配符"></a>泛型中通配符</h2><p>我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V 等等，这些通配符又都是什么意思呢？</p>
<p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。通常情况下，T，E，K，V，？是这样约定的：</p>
<ul>
<li>？表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<h3 id="？无界通配符"><a href="#？无界通配符" class="headerlink" title="？无界通配符"></a>？无界通配符</h3><p>先从一个小例子看起，我有一个父类 Animal 和几个子类，如狗、猫等，现在我需要一个动物的列表，我的第一个想法是像这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Animal&gt; listAnimals</span><br></pre></td></tr></table></figure>
<p>但是老板的想法确实这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Animal&gt; listAnimals</span><br></pre></td></tr></table></figure>
<p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs</span> <span class="params">(List&lt;? extends Animal &gt; animals )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal += animal.countLegs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs1</span> <span class="params">(List&lt; Animal &gt; animals )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal += animal.countLegs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="comment">// 不会报错</span></span><br><span class="line">    countLegs( dogs );</span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    countLegs1(dogs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用 countLegs1 时，就会报错。所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 <code>&lt;?&gt;</code>），表示可以持有任何类型。像 countLegs 方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 countLegs1 就不行。</p>
<h3 id="上界通配符-lt-extends-E-gt"><a href="#上界通配符-lt-extends-E-gt" class="headerlink" title="上界通配符 &lt; ? extends E&gt;"></a>上界通配符 &lt; ? extends E&gt;</h3><blockquote>
<p>上界：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p>
</blockquote>
<p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p>
<ul>
<li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li>
<li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private &lt;K extends A, E extends B&gt; E test(K arg1, E arg2)&#123;</span><br><span class="line">    E result = arg2;</span><br><span class="line">    arg2.compareTo(arg1);</span><br><span class="line">    //.....</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型参数列表中如果有多个类型参数上限，用逗号分开</p>
<h3 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符 &lt; ? super E&gt;"></a>下界通配符 &lt; ? super E&gt;</h3><blockquote>
<p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p>
</blockquote>
<p>在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private &lt;T&gt; void test(List&lt;? super T&gt; dst, List&lt;T&gt; src)&#123;</span><br><span class="line">    for (T t : src) &#123;</span><br><span class="line">        dst.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Animal&gt; animals = new ArrayList&lt;&gt;();</span><br><span class="line">    new Test3().test(animals,dogs);</span><br><span class="line">&#125;</span><br><span class="line">// Dog 是 Animal 的子类</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dst 类型 “大于等于” src 的类型，这里的“大于等于”是指 dst 表示的范围比 src 要大，因此装得下 dst 的容器也就能装 src 。</p>
<h3 id="？和-T-的区别"><a href="#？和-T-的区别" class="headerlink" title="？和 T 的区别"></a>？和 T 的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//指定集合元素只能是T类型</span><br><span class="line">List&lt;T&gt; list =new ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">//集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法</span><br><span class="line">List&lt;?&gt; list =new ArrayList&lt;?&gt;();</span><br></pre></td></tr></table></figure>
<p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？不行，比如如下这种 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 可以</span><br><span class="line">T t = operate();</span><br><span class="line"></span><br><span class="line">// 不可以</span><br><span class="line">?car = operate();</span><br></pre></td></tr></table></figure>
<p>简单总结下：</p>
<blockquote>
<p>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p>
</blockquote>
<h4 id="区别1：通过-T-来-确保-泛型参数的一致性"><a href="#区别1：通过-T-来-确保-泛型参数的一致性" class="headerlink" title="区别1：通过 T 来 确保 泛型参数的一致性"></a>区别1：通过 T 来 确保 泛型参数的一致性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过 T 来 确保 泛型参数的一致性</span><br><span class="line">public &lt;T extends Number&gt; void</span><br><span class="line">test(List&lt;T&gt; dest, List&lt;T&gt; src)</span><br><span class="line"></span><br><span class="line">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span><br><span class="line">public void</span><br><span class="line">test(List&lt;? extends Number&gt; dest, List&lt;? extends Number&gt; src)</span><br></pre></td></tr></table></figure>
<p>像下面的代码中，约定的 T 是 Number 的子类才可以，但是申明时是用的 String ，所以就会飘红报错。</p>
<p>不能保证两个 List 具有相同的元素类型的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GlmapperGeneric&lt;String&gt; glmapperGeneric = new GlmapperGeneric&lt;&gt;();</span><br><span class="line">List&lt;String&gt; dest = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt; src = new ArrayList&lt;&gt;();</span><br><span class="line">glmapperGeneric.testNon(dest,src);</span><br></pre></td></tr></table></figure>
<p>上面的代码在编译器并不会报错，但是当进入到 testNon 方法内部操作时（比如赋值），对于 dest 和 src 而言，就还是需要进行类型转换。</p>
<h4 id="区别2：类型参数可以多重限定而通配符不行"><a href="#区别2：类型参数可以多重限定而通配符不行" class="headerlink" title="区别2：类型参数可以多重限定而通配符不行"></a>区别2：类型参数可以多重限定而通配符不行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiLimit</span> <span class="keyword">implements</span> <span class="title">MultiLimitInterfaceA</span>,<span class="title">MultiLimitInterfaceB</span></span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 使用 &amp; 符号设定多重边界</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span>&lt;T extends MultiLimitInterfaceA &amp; MultiLimitInterfaceB&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MultiLimitInterfaceA</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MulitLimitInterfaceB</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>使用 &amp; 符号设定多重边界（Multi Bounds)，指定泛型类型 T 必须是 MultiLimitInterfaceA 和 MultiLimitInterfaceB 的共有子类型，此时变量 t 就具有了所有限定的方法和属性。对于通配符来说，因为它不是一个确定的类型，所以不能进行多重限定。</p>
<h4 id="区别3：通配符可以使用超类限定而类型参数不行"><a href="#区别3：通配符可以使用超类限定而类型参数不行" class="headerlink" title="区别3：通配符可以使用超类限定而类型参数不行"></a>区别3：通配符可以使用超类限定而类型参数不行</h4><p>类型参数 T 只具有 一种 类型限定方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T extends A</span><br></pre></td></tr></table></figure>
<p>但是通配符 ? 可以进行 两种限定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">? extends A</span><br><span class="line">? super A</span><br></pre></td></tr></table></figure>
<h2 id="Class-lt-T-gt-和-Class-lt-gt-区别"><a href="#Class-lt-T-gt-和-Class-lt-gt-区别" class="headerlink" title="Class&lt; T &gt; 和 Class&lt; ? &gt; 区别"></a>Class&lt; T &gt; 和 Class&lt; ? &gt; 区别</h2><p>前面介绍了 ？和 T 的区别，那么对于，<code>Class&lt;T&gt;</code> 和 <code>&lt;Class&lt;?&gt;</code> 又有什么区别呢？</p>
<p>最常见的是在反射场景下的使用，这里以用一段发射的代码来说明下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过反射的方式生成  multiLimit </span><br><span class="line">// 对象，这里比较明显的是，我们需要使用强制类型转换</span><br><span class="line">MultiLimit multiLimit = (MultiLimit)</span><br><span class="line">Class.forName(&quot;com.glmapper.bridge.boot.generic.MultiLimit&quot;).newInstance();</span><br></pre></td></tr></table></figure>
<p>对于上述代码，在运行期，如果反射的类型不是 MultiLimit 类，那么一定会报 java.lang.ClassCastException 错误。</p>
<p>对于这种情况，则可以使用下面的代码来代替，使得在在编译期就能直接 检查到类型的问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Ttest3&#123;</span><br><span class="line">	public static &lt;T&gt; T createInstance(Class&lt;T&gt; clazz) throws Exception&#123;</span><br><span class="line">		return clazz.newInstance();</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		A a = createInstance(A.class);</span><br><span class="line">		B b = createInstance(B.class);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class A&#123;&#125;</span><br><span class="line">class B&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>Class&lt;T&gt;</code> 在实例化的时候，T 要替换成具体类。<code>Class&lt;?&gt;</code> 它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 可以</span><br><span class="line">public Class&lt;?&gt; clazz;</span><br><span class="line">// 不可以，因为 T 需要指定类型</span><br><span class="line">public Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>
<p>所以当不知道定声明什么类型的 Class 的时候可以定义一 个<code>Class&lt;?&gt;</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test3 &#123;</span><br><span class="line">    public Class&lt;?&gt; clazz;</span><br><span class="line">    public Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>
<p>那如果也想 <code>public Class&lt;T&gt; clazzT;</code> 这样的话，就必须让当前的类也指定 T ，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test3&lt;T&gt; &#123;</span><br><span class="line">    public Class&lt;?&gt; clazz;</span><br><span class="line">    // 不会报错</span><br><span class="line">    public Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>加密算法</title>
    <url>/2020/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="对称性加密算法"><a href="#对称性加密算法" class="headerlink" title="对称性加密算法"></a>对称性加密算法</h2><p><img src="/2020/加密算法/1.jpg" alt="加密流程图"></p>
<p>对称式加密就是加密和解密使用同一个密钥。信息接收双方都需事先知道密匙和加解密算法且其密匙是相同的，之后便是对数据进行加解密了。对称加密算法用来对敏感数据等信息进行加密。</p>
<p>对称加密算法的优点是：算法公开、计算量小、加密速度快、加密效率高。用途：对称加密算法用来对敏感数据等信息进行加密</p>
<p>对称加密算法的缺点是：在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。</p>
<p><strong>DES</strong>：全称为Data Encryption Standard数据加密标准，速度较快，适用于加密大量数据的场合。</p>
<p><strong>3DES</strong>（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。</p>
<p><strong>AES</strong>：全称为Advanced Encryption Standard高级加密标准，是下一代的加密算法标准，速度快，安全级别高；AES是一个使用128为分组块的分组加密算法，分组块和128、192或256位的密钥一起作为输入，对4×4的字节数组上进行操作。众所周之AES是种十分高效的算法，尤其在8位架构中，这源于它面向字节的设计。AES 适用于8位的小型单片机或者普通的32位微处理器,并且适合用专门的硬件实现，硬件实现能够使其吞吐量（每秒可以到达的加密/解密bit数）达到十亿量级。同样，其也适用于RFID系统。</p>
<h2 id="非对称性算法"><a href="#非对称性算法" class="headerlink" title="非对称性算法"></a>非对称性算法</h2><p><img src="/2020/加密算法/2.jpg" alt="img"></p>
<p><strong>既然是加密，那肯定是不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证。</strong></p>
<p>与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p>
<p>非对称加密与有点是：安全性更好；对称加密的通信双方使用相同的秘钥，如果一方的秘钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对秘钥，一个用来加密，一个用来解密，而且公钥是公开的，秘钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥。</p>
<p>非对称加密的缺点是：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p>
<p><strong>RSA</strong>：全称为Digital Signature Algorithm，是第一个能同时用于加密和数字签名的算法，也易于理解和操作。RSA是被研究得最广泛的公钥算法，从提出到现今的三十多年里，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。</p>
<p><strong>DSA</strong>：全称为Digital Encryption Standard，是基于整数有限域离散对数难题的，其安全性与RSA相比差不多。DSA的一个重要特点是两个素数公开，这样，当使用别人的p和q时，即使不知道私钥，你也能确认它们是否是随机产生的，还是作了手脚。RSA算法却做不到。</p>
<p><strong>ECC</strong>：全称为Elliptic Curves Cryptography,，也叫椭圆加密算法，是一种公钥加密体制，最初由Koblitz和Miller两人于1985年提出，其数学基础是利用椭圆曲线上的有理点构成Abel加法群上椭圆离散对数的计算困难性。</p>
<blockquote>
<p>ECC和RSA相比，在许多方面都有对绝对的优势，主要体现在以下方面：</p>
<ol>
<li>抗攻击性强。相同的密钥长度，其抗攻击性要强很多倍。</li>
<li>计算量小，处理速度快。ECC总的速度比RSA、DSA要快得多。</li>
<li>存储空间占用小。ECC的密钥尺寸和系统参数与RSA、DSA相比要小得多，意味着它所占的存贮空间要小得多。这对于加密算法在IC卡上的应用具有特别重要的意义。</li>
<li>带宽要求低。当对长消息进行加解密时，三类密码系统有相同的带宽要求，但应用于短消息时ECC带宽要求却低得多。带宽要求低使ECC在无线网络领域具有广泛的应用前景。</li>
</ol>
</blockquote>
<h2 id="散列算法（签名算法）"><a href="#散列算法（签名算法）" class="headerlink" title="散列算法（签名算法）"></a>散列算法（签名算法）</h2><p><img src="/2020/加密算法/sl.png" alt="img"></p>
<p>散列算法，又称哈希函数，是一种单向加密算法。在信息安全技术中，经常需要验证消息的完整性，散列(Hash)函数提供了这一服务，它对不同长度的输入消息，产生固定长度的输出。这个固定长度的输出称为原输入消息的”散列”或”消息摘要”(Message digest)。散列算法不算加密算法，因为其结果是不可逆的，既然是不可逆的，那么当然不是用来加密的，而是签名。</p>
<p>用途：主要用于验证，防止信息被修。具体用途如：文件校验、数字签名、鉴权协议</p>
<p><strong>MD5</strong>：MD5是一种不可逆的加密算法，目前是最牢靠的加密算法之一，尚没有能够逆运算的程序被开发出来，它对应任何字符串都可以加密成一段唯一的固定长度的代码。</p>
<p><strong>SHA1</strong>：全称为Secure Hash Algorithm，即安全哈希算法，主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。有SHA-1，SHA-224，SHA-256，SHA-384，和SHA-512这几种单向散列算法，其中SHA-1已经不安全。而SHA-1基于MD5，MD5又基于MD4。</p>
<p><strong>HMAC</strong>：全称为Hash Message Authentication Code，即散列消息鉴别码，主要是利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。一般的，消息鉴别码用于验证传输于两个共 同享有一个密钥的单位之间的消息。HMAC 可以与任何迭代散列函数捆绑使用。MD5 和 SHA-1 就是这种散列函数。HMAC 还可以使用一个用于计算和确认消息鉴别值的密钥。</p>
<p><strong>建议：</strong> AES采用128为即可，RSA建议采用1024位的数字，ECC建议采用160位。RSA加密字符长度有限制，一般采用AES+RSA方式组合使用。</p>
<h2 id="Base64算法"><a href="#Base64算法" class="headerlink" title="Base64算法"></a>Base64算法</h2><p>Base64 加密算法是最常见的用于传递 8bit <strong>字节码的编码方式之一</strong></p>
<p>计算机任何数据都是按 ascii 码存储的，而 ascii 码的 128～256 之间的值是不可见字符，由于不同设备对字符处理方式有不同，可能会导致错误，不利于传输，所以把数据作为一个 Base64 编码，统统变成可见字符，出错可能性就降低了</p>
<p>Base64 是取 6 个比特为一组，计算它的 ascii 值，得到一个可见字符，在解码时按 6 个比特进行解码并读取，如 01010101101 等比特流，取 010110 计算它的 ascii 码，转化为可见字符，因此 Base64 <strong>还具备了数据压缩能力</strong></p>
<p>其实不是安全领域下的加密解密算法，只能算是一个编码算法，通常用于把二进制数据编码为可写的字符形式的数据，对数据内容进行编码来适合传输(可以对img图像编码用于传输)。这是一种可逆的编码方式。编码后的数据是一个字符串，其中包含的字符为：A-Z、a-z、0-9、+、/，共64个字符(26 + 26 + 10 + 1 + 1 = 64，其实是65个字符，“=”是填充字符。Base64要求把每三个8Bit的字节转换为四个6Bit的字节(3<em>8 = 4</em>6 = 24)，然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。原文的字节最后不够3个的地方用0来补足，转换时Base64编码用=号来代替。这就是为什么有些Base64编码会以一个或两个等号结束的原因，中间是不可能出现等号的，但等号最多只有两个。其实不用”=”也不耽误解码，之所以用”=”，可能是考虑到多段编码后的Base64字符串拼起来也不会引起混淆。)<br>Base64编码是从二进制到字符的过程，像一些中文字符用不同的编码转为二进制时，产生的二进制是不一样的，所以最终产生的Base64字符也不一样。例如”上网”对应utf-8格式的Base64编码是”5LiK572R”， 对应GB2312格式的Base64编码是”yc/N+A==”。<br>标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的“/”和“+”字符变为形如“%XX”的形式，而这些“%”号在存入数据库时还需要再进行转换，因为ANSI SQL中已将“%”号用作通配符。<br>为解决此问题，可采用一种用于URL的改进Base64编码，它不在末尾填充’=’号，并将标准Base64中的“+”和“/”分别改成了“-”和“<em>”，这样就免去了在URL编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。<br>另有一种用于正则表达式的改进Base64变种，它将“+”和“/”改成了“!”和“-”，因为“+”，“*”以及前面在IRCu中用到的“[”和“]”在正则表达式中都可能具有特殊含义。<br>此外还有一些变种，它们将“+/”改为“</em>-”或“.<em>”（用作编程语言中的标识符名称）或“.-”（用于XML中的Nmtoken）甚至“</em>:”（用于XML中的Name）。</p>
<h2 id="AES-RSA组合应用"><a href="#AES-RSA组合应用" class="headerlink" title="AES+RSA组合应用"></a>AES+RSA组合应用</h2><p>RSA与AES加密算法所产生的密钥数不一样，它们是如何进行加密的呢？</p>
<p>接收方生成RSA密钥对，将其中的RSA公钥传递给发送方(接收方与发送方建立连接是需要认证的，SSL/TLS协议可以确保RSA公钥的安全完整)，然后用RSA公钥对AES密钥进行加密，加密后的结果传递给接收方，接收方用RSA私钥解密后，得到AES密钥，最后使用AES密钥解密，从而达到安全互通数据的目的。(如下图所示)</p>
<p><img src="/2020/加密算法/3.png" alt="3"></p>
<p><img src="/2020/加密算法/4.jpg" alt="img"></p>
<h2 id="项目应用总结"><a href="#项目应用总结" class="headerlink" title="项目应用总结"></a>项目应用总结</h2><ol>
<li>加密算法是可逆的，用来对敏感数据进行保护。散列算法(签名算法、哈希算法)是不可逆的，主要用于身份验证。</li>
<li>对称加密算法使用同一个密匙加密和解密，速度快，适合给大量数据加密。对称加密客户端和服务端使用同一个密匙，存在被抓包破解的风险。</li>
<li>非对称加密算法使用公钥加密，私钥解密，私钥签名，公钥验签。安全性比对称加密高，但速度较慢。非对称加密使用两个密匙，服务端和客户端密匙不一样，私钥放在服务端，黑客一般是拿不到的，安全性高。</li>
<li>Base64不是安全领域下的加解密算法，只是一个编码算法，通常用于把二进制数据编码为可写的字符形式的数据，特别适合在http，mime协议下的网络快速传输数据。UTF-8和GBK中文的Base64编码结果是不同的。采用Base64编码不仅比较简短，同时也具有不可读性，即所编码的数据不会被人用肉眼所直接看到，但这种方式很初级，很简单。Base64可以对图片文件进行编码传输。</li>
<li>大量数据加密建议采用对称加密算法，提高加解密速度；小量的机密数据，可以采用非对称加密算法。在实际的操作过程中，我们通常采用的方式是：采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。</li>
<li>MD5标准密钥长度128位（128位是指二进制位。二进制太长，所以一般都改写成16进制，每一位16进制数可以代替4位二进制数，所以128位二进制数写成16进制就变成了128/4=32位。16位加密就是从32位MD5散列中把中间16位提取出来）；sha1标准密钥长度160位(比MD5摘要长32位)，Base64转换后的字符串理论上将要比原来的长1/3。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AES 加密方法，是对称的密码算法(加密与解密的密钥一致)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得一个 密钥长度为 128 位的 AES 密钥，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回经 BASE64 处理之后的密钥字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStrKeyAES</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyGenerator keyGen = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        SecureRandom secureRandom = <span class="keyword">new</span> SecureRandom(String.valueOf(System.currentTimeMillis()).getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="comment">// 这里可以是 128、192、256、越大越安全</span></span><br><span class="line">        keyGen.init(<span class="number">128</span>, secureRandom);</span><br><span class="line">        SecretKey secretKey = keyGen.generateKey();</span><br><span class="line">        <span class="keyword">return</span> base64_byteArr2Str(secretKey.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将使用 Base64 加密后的字符串类型的 secretKey 转为 SecretKey</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SecretKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecretKey <span class="title">strKey2SecretKey</span><span class="params">(String strKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] byteArr = base64_str2ByteArr(strKey);</span><br><span class="line">        SecretKeySpec secretKey = <span class="keyword">new</span> SecretKeySpec(byteArr, <span class="string">"AES"</span>);</span><br><span class="line">        <span class="keyword">return</span> secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   待加密内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKey 加密使用的 AES 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后的密文 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptAES(<span class="keyword">byte</span>[] content, SecretKey secretKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 加密 返回Base64编码的字符串密文</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String message, String secretKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SecretKey aesKey = AESUtil.strKey2SecretKey(secretKey);</span><br><span class="line">        <span class="comment">//加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptAESByteArr = AESUtil.encryptAES(message.getBytes(<span class="string">"utf-8"</span>), aesKey);</span><br><span class="line">        <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">        <span class="keyword">return</span> AESUtil.base64_byteArr2Str(encryptAESByteArr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 解密 传入Base64编码的字符串密文，返回解密后的字符串</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String encryptMsgBase64Str, String secretKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SecretKey aesKey = AESUtil.strKey2SecretKey(secretKey);</span><br><span class="line">        <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] messageByteArr = AESUtil.base64_str2ByteArr(encryptMsgBase64Str);</span><br><span class="line">        <span class="comment">//解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptAESByteArr = AESUtil.decryptAES(messageByteArr, aesKey);</span><br><span class="line">        String descyptAes = <span class="keyword">new</span> String(decryptAESByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="keyword">return</span> descyptAes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   待解密内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKey 解密使用的 AES 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解密后的明文 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptAES(<span class="keyword">byte</span>[] content, SecretKey secretKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转Base64编码字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">base64_byteArr2Str</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base64编码字符串转字节数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base64Key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] base64_str2ByteArr(String base64Key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getDecoder().decode(base64Key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RSA 是非对称的密码算法，密钥分公钥和私钥，公钥用来加密，私钥用于解密</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="title">RSAUtil</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成密钥对：密钥对中包含公钥和私钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含 RSA 公钥与私钥的 keyPair</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title">getKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        SecureRandom secureRandom = <span class="keyword">new</span> SecureRandom(String.valueOf(System.currentTimeMillis()).getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="comment">// 这里可以是1024、2048 初始化一个密钥对</span></span><br><span class="line">        keyPairGenerator.initialize(<span class="number">2048</span>, secureRandom);</span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="keyword">return</span> keyPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取公钥 (并进行Base64编码，返回一个 Base64 编码后的字符串)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个 Base64 编码后的公钥字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKey</span><span class="params">(KeyPair keyPair)</span> </span>&#123;</span><br><span class="line">        PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = publicKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> base64_byteArr2Str(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取私钥(并进行Base64编码，返回一个 Base64 编码后的字符串)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个 Base64 编码后的私钥字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPrivateKey</span><span class="params">(KeyPair keyPair)</span> </span>&#123;</span><br><span class="line">        PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = privateKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> base64_byteArr2Str(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Base64编码后的公钥转换成 PublicKey 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pubStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> PublicKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title">string2PublicKey</span><span class="params">(String pubStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(pubStr);</span><br><span class="line">        X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(bytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        PublicKey publicKey = keyFactory.generatePublic(keySpec);</span><br><span class="line">        <span class="keyword">return</span> publicKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Base64编码后的私钥转换成 PrivateKey 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> PrivateKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title">string2PrivateKey</span><span class="params">(String priStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(priStr);</span><br><span class="line">        PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(bytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        PrivateKey privateKey = keyFactory.generatePrivate(keySpec);</span><br><span class="line">        <span class="keyword">return</span> privateKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   待加密的内容 byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 加密所需的公钥对象 PublicKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后的字节数组 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] publicEncrypt(<span class="keyword">byte</span>[] content, PublicKey publicKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密并返回Base64编码的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String message, String publicKeyStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line">        PublicKey publicKey = RSAUtil.string2PublicKey(publicKeyStr);</span><br><span class="line">        <span class="comment">//用公钥加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicEncrypt = RSAUtil.publicEncrypt(message.getBytes(<span class="string">"utf-8"</span>), publicKey);</span><br><span class="line">        <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">        String encryptMsgBase64Str = RSAUtil.base64_byteArr2Str(publicEncrypt);</span><br><span class="line">        <span class="keyword">return</span> encryptMsgBase64Str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content    待解密的内容 byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 解密需要的私钥对象 PrivateKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解密后的字节数组 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] privateDecrypt(<span class="keyword">byte</span>[] content, PrivateKey privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密,返回字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String encryptMsgBase64Str, String privateKeyStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line">        PrivateKey privateKey = RSAUtil.string2PrivateKey(privateKeyStr);</span><br><span class="line">        <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptMsgByteArr = RSAUtil.base64_str2ByteArr(encryptMsgBase64Str);</span><br><span class="line">        <span class="comment">//用私钥解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptmsgByteArr = RSAUtil.privateDecrypt(encryptMsgByteArr, privateKey);</span><br><span class="line">        String decryptmsgStr = <span class="keyword">new</span> String(decryptmsgByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="keyword">return</span> decryptmsgStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转Base64编码字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">base64_byteArr2Str</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base64编码字符串转字节数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base64Key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] base64_str2ByteArr(String base64Key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getDecoder().decode(base64Key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESUtilTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            key = AESUtil.getStrKeyAES();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encryptFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//String sourceFilePath = "D://滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案.docx";</span></span><br><span class="line">        String sourceFilePath = <span class="string">"E:\\打印\\JasperReports+iReport报表开发详解.pdf"</span>;</span><br><span class="line">        <span class="comment">//String sourceFilePath = "D:\\1583915786661_html_2f4d5dc.png";</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// String destFilePath = "D://test//滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案jiami.docx";</span></span><br><span class="line">        String destFilePath = <span class="string">"D://test//JasperReports+iReport报表开发详解jm.pdf"</span>;</span><br><span class="line">        FileEncryptUtil.encryptFile(key, sourceFilePath, destFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decryptFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String sourceFilePath = <span class="string">"D://test//JasperReports+iReport报表开发详解jm.pdf"</span>;</span><br><span class="line">        <span class="comment">//String sourceFilePath = "D://test//滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案jiami.docx";</span></span><br><span class="line">      <span class="comment">//  String destFilePath = "E://test//滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案.docx";</span></span><br><span class="line">        String destFilePath = <span class="string">"E://test//JasperReports+iReport报表开发详解.pdf"</span>;</span><br><span class="line">        <span class="comment">//String destFilePath="E:\\11.png";</span></span><br><span class="line">        FileEncryptUtil.decryptFile(key, sourceFilePath, destFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//=================客户端=================</span></span><br><span class="line">            <span class="comment">//hello, i am infi, good night!加密</span></span><br><span class="line">            String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line">            System.out.println(<span class="string">"明文数据为："</span> + message);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成AES秘钥，并Base64编码</span></span><br><span class="line">            String aesKeyBase64Str = AESUtil.getStrKeyAES();</span><br><span class="line">            System.out.println(<span class="string">"AES秘钥Base64编码:"</span> + aesKeyBase64Str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//将Base64编码的字符串，转换成AES秘钥</span></span><br><span class="line">            SecretKey aesKey = AESUtil.strKey2SecretKey(aesKeyBase64Str);</span><br><span class="line">            <span class="comment">//加密</span></span><br><span class="line">            <span class="keyword">byte</span>[] encryptAESByteArr = AESUtil.encryptAES(message.getBytes(<span class="string">"utf-8"</span>), aesKey);</span><br><span class="line">            <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">            String encryptAESBase64Str = AESUtil.base64_byteArr2Str(encryptAESByteArr);</span><br><span class="line">            System.out.println(<span class="string">"加密并Base64编码的结果："</span> + encryptAESBase64Str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//##############   网络上传输的内容有Base64编码后的秘钥 和 Base64编码加密后的内容    #################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//===================服务端================</span></span><br><span class="line">            <span class="comment">//将Base64编码的字符串，转换成AES秘钥</span></span><br><span class="line">            SecretKey aesKeyFromNet = AESUtil.strKey2SecretKey(aesKeyBase64Str);</span><br><span class="line">            <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">            <span class="keyword">byte</span>[] encryptAESByteArrFromNet = AESUtil.base64_str2ByteArr(encryptAESBase64Str);</span><br><span class="line">            <span class="comment">//解密</span></span><br><span class="line">            <span class="keyword">byte</span>[] decryptAESByteArr = AESUtil.decryptAES(encryptAESByteArrFromNet, aesKeyFromNet);</span><br><span class="line">            String descyptAes = <span class="keyword">new</span> String(decryptAESByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//解密后的明文</span></span><br><span class="line">            System.out.println(<span class="string">"解密后的明文: "</span> + descyptAes);</span><br><span class="line">            <span class="keyword">if</span> (message.equals(descyptAes)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//封装方法测试</span></span><br><span class="line">            String miwen=AESUtil.encrypt(message,aesKeyBase64Str);</span><br><span class="line">            System.out.println(miwen);</span><br><span class="line">            String minwen=AESUtil.decrypt(miwen,aesKeyBase64Str);</span><br><span class="line">            System.out.println(minwen);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            encryptFile();</span><br><span class="line">            decryptFile();</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            System.err.println(<span class="string">"耗时："</span> + (end - begin) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAUtilTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//===============生成公钥和私钥，公钥传给客户端，私钥服务端保留==================</span></span><br><span class="line">            <span class="comment">//生成RSA公钥和私钥，并Base64编码</span></span><br><span class="line">            KeyPair keyPair = RSAUtil.getKeyPair();</span><br><span class="line">            String publicKeyStr = RSAUtil.getPublicKey(keyPair);</span><br><span class="line">            String privateKeyStr = RSAUtil.getPrivateKey(keyPair);</span><br><span class="line">            System.out.println(<span class="string">"RSA公钥Base64编码:"</span> + publicKeyStr);</span><br><span class="line">            System.out.println(<span class="string">"RSA私钥Base64编码:"</span> + privateKeyStr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//=================客户端=================</span></span><br><span class="line">            <span class="comment">//hello, i am infi, good night!加密</span></span><br><span class="line">            String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line">            <span class="comment">//将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line">            PublicKey publicKey = RSAUtil.string2PublicKey(publicKeyStr);</span><br><span class="line">            <span class="comment">//用公钥加密</span></span><br><span class="line">            <span class="keyword">byte</span>[] publicEncrypt = RSAUtil.publicEncrypt(message.getBytes(<span class="string">"utf-8"</span>), publicKey);</span><br><span class="line">            <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">            String encryptMsgBase64Str = RSAUtil.base64_byteArr2Str(publicEncrypt);</span><br><span class="line">            System.out.println(<span class="string">"公钥加密并Base64编码的结果："</span> + encryptMsgBase64Str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//##############    网络上传输的内容有Base64编码后的公钥 和 Base64编码后的公钥加密的内容     #################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//===================服务端================</span></span><br><span class="line">            <span class="comment">//将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line">            PrivateKey privateKey = RSAUtil.string2PrivateKey(privateKeyStr);</span><br><span class="line">            <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">            <span class="keyword">byte</span>[] encryptMsgFromNet = RSAUtil.base64_str2ByteArr(encryptMsgBase64Str);</span><br><span class="line">            <span class="comment">//用私钥解密</span></span><br><span class="line">            <span class="keyword">byte</span>[] privateDecryptmsgByteArr = RSAUtil.privateDecrypt(encryptMsgFromNet, privateKey);</span><br><span class="line">            String privateDecrypmsgtStr = <span class="keyword">new</span> String(privateDecryptmsgByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line">            <span class="comment">//解密后的明文</span></span><br><span class="line">            System.out.println(<span class="string">"解密后的明文: "</span> + privateDecrypmsgtStr);</span><br><span class="line">            <span class="keyword">if</span> (message.equals(privateDecrypmsgtStr)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//封装方法测试</span></span><br><span class="line">            String miwen=RSAUtil.encrypt(message,publicKeyStr);</span><br><span class="line">            System.out.println(<span class="string">"密文: "</span> + miwen);</span><br><span class="line">            String mingwen=RSAUtil.decrypt(miwen,privateKeyStr);</span><br><span class="line">            System.out.println(<span class="string">"明文: "</span> + mingwen);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESAndRSATest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//测试RSA与AES的结合。</span></span><br><span class="line">    <span class="comment">//客户端：AES秘钥加密明文得到密文，然后用从服务器获取的RSA公钥加密AES秘钥，网络传输密文和RSA加密后的AES秘钥到服务器</span></span><br><span class="line">    <span class="comment">//服务端：用RSA私钥解密AES秘钥，解密后的AES秘钥再用来解密密文，得到明文。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//===============生成公钥和私钥，公钥传给客户端，私钥服务端保留==================</span></span><br><span class="line">        <span class="comment">//生成RSA公钥和私钥，并Base64编码，生成一次以后，就写死在配置文件或代码中，下次不再重新生成</span></span><br><span class="line">        KeyPair keyPair = RSAUtil.getKeyPair();</span><br><span class="line">        String publicKeyStr = RSAUtil.getPublicKey(keyPair);</span><br><span class="line">        String privateKeyStr = RSAUtil.getPrivateKey(keyPair);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥Base64编码:"</span> + publicKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥Base64编码:"</span> + privateKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=================客户端=================</span></span><br><span class="line">        <span class="comment">//hello, i am infi, good night!  需要加密的实际内容</span></span><br><span class="line">        String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line">        <span class="comment">//将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line">        PublicKey publicKey = RSAUtil.string2PublicKey(publicKeyStr);</span><br><span class="line">        <span class="comment">//生成AES秘钥，并Base64编码</span></span><br><span class="line">        String aesKeyStr = AESUtil.getStrKeyAES();</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥Base64编码:"</span> + aesKeyStr);</span><br><span class="line">        <span class="comment">//用公钥加密AES秘钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicEncryptAESKey = RSAUtil.publicEncrypt(aesKeyStr.getBytes(<span class="string">"utf-8"</span>), publicKey);</span><br><span class="line">        <span class="comment">//公钥加密AES秘钥后的内容Base64编码</span></span><br><span class="line">        String publicEncryptAESKeyStr = RSAUtil.base64_byteArr2Str(publicEncryptAESKey);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥加密AES秘钥并Base64编码的结果："</span> + publicEncryptAESKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Base64编码后的AES秘钥转换成SecretKey对象</span></span><br><span class="line">        SecretKey aesKey = AESUtil.strKey2SecretKey(aesKeyStr);</span><br><span class="line">        <span class="comment">//用AES秘钥加密实际的内容</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptAES = AESUtil.encryptAES(message.getBytes(<span class="string">"utf-8"</span>), aesKey);</span><br><span class="line">        <span class="comment">//AES秘钥加密后的内容Base64编码</span></span><br><span class="line">        String encryptAESStr = AESUtil.base64_byteArr2Str(encryptAES);</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥加密实际的内容并Base64编码的结果："</span> + encryptAESStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//##############   网络上传输的内容有Base64编码后的公钥加密AES秘钥的结果 和 Base64编码后的AES秘钥加密实际内容的结果   #################</span></span><br><span class="line">        <span class="comment">//##############   即publicEncryptAESKeyStr和encryptAESStr  ###################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//===================服务端================</span></span><br><span class="line">        <span class="comment">//将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line">        PrivateKey privateKey = RSAUtil.string2PrivateKey(privateKeyStr);</span><br><span class="line">        <span class="comment">//公钥加密AES秘钥后的内容(Base64编码)，进行Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicEncryptAESKeyFromNet = RSAUtil.base64_str2ByteArr(publicEncryptAESKeyStr);</span><br><span class="line">        <span class="comment">//用私钥解密,得到aesKey</span></span><br><span class="line">        <span class="keyword">byte</span>[] aesKeyStrBytes = RSAUtil.privateDecrypt(publicEncryptAESKeyFromNet, privateKey);</span><br><span class="line">        <span class="comment">//解密后的aesKey</span></span><br><span class="line">        String aesKeyStrFromNet = <span class="keyword">new</span> String(aesKeyStrBytes,<span class="string">"utf-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥解密AES秘钥并Base64编码的结果: "</span> + aesKeyStrFromNet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Base64编码后的AES秘钥转换成SecretKey对象</span></span><br><span class="line">        SecretKey aesKey2 = AESUtil.strKey2SecretKey(aesKeyStrFromNet);</span><br><span class="line">        <span class="comment">//AES秘钥加密后的内容(Base64编码)，进行Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptAES2 = AESUtil.base64_str2ByteArr(encryptAESStr);</span><br><span class="line">        <span class="comment">//用AES秘钥解密实际的内容</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptAES = AESUtil.decryptAES(encryptAES2, aesKey2);</span><br><span class="line">        String decryptAESStr=<span class="keyword">new</span> String(decryptAES,<span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="comment">//解密后的实际内容</span></span><br><span class="line">        System.out.println(<span class="string">"解密后的实际内容: "</span> + decryptAESStr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (message.equals(decryptAESStr)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装方法测试</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSimple</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//===============生成公钥和私钥，公钥传给客户端，私钥服务端保留==================</span></span><br><span class="line">        <span class="comment">//生成RSA公钥和私钥，并Base64编码，生成一次以后，就写死在配置文件或代码中，下次不再重新生成</span></span><br><span class="line">        KeyPair keyPair = RSAUtil.getKeyPair();</span><br><span class="line">        String publicKeyStr = RSAUtil.getPublicKey(keyPair);</span><br><span class="line">        String privateKeyStr = RSAUtil.getPrivateKey(keyPair);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥Base64编码:"</span> + publicKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥Base64编码:"</span> + privateKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=================客户端=================</span></span><br><span class="line">        <span class="comment">//hello, i am infi, good night!  需要加密的实际内容</span></span><br><span class="line">        String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成AES秘钥，并Base64编码</span></span><br><span class="line">        String aesKeyStr = AESUtil.getStrKeyAES();</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥Base64编码:"</span> + aesKeyStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//用公钥加密AES秘钥</span></span><br><span class="line">        String publicEncryptAESKeyStr = RSAUtil.encrypt(aesKeyStr,publicKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥加密AES秘钥并Base64编码的结果："</span> + publicEncryptAESKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用AES秘钥加密实际的内容Base64编码</span></span><br><span class="line">        String encryptAESStr = AESUtil.encrypt(message, aesKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥加密实际的内容并Base64编码的结果："</span> + encryptAESStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//===================服务端================</span></span><br><span class="line">        <span class="comment">//用RSA私钥解密,得到aesKey</span></span><br><span class="line">        String aesKeyStrFromNet = RSAUtil.decrypt(publicEncryptAESKeyStr, privateKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥解密AES秘钥并Base64编码的结果: "</span> + aesKeyStrFromNet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用AES秘钥解密实际的内容</span></span><br><span class="line">        String decryptAESStr = AESUtil.decrypt(encryptAESStr, aesKeyStrFromNet);</span><br><span class="line">        <span class="comment">//解密后的实际内容</span></span><br><span class="line">        System.out.println(<span class="string">"AES解密后的实际内容: "</span> + decryptAESStr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (message.equals(decryptAESStr)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//test();</span></span><br><span class="line">            testSimple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>开博</title>
    <url>/2019/%E5%BC%80%E5%8D%9A/</url>
    <content><![CDATA[<p>记录生活<br>感悟人生</p>
]]></content>
  </entry>
  <entry>
    <title>群晖DSM使用端口大全</title>
    <url>/2021/%E7%BE%A4%E6%99%96DSM%E4%BD%BF%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>设置工具</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>Synology Assistant</td>
<td>9999、9998、9997</td>
<td>UDP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>备份</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>Data Replicator、Data Replicator II、Data Replicator III</td>
<td>9999、9998、9997、137、138、139、445</td>
<td>TCP</td>
</tr>
<tr>
<td>网络备份</td>
<td>873（数据）、3260（iSCSI LUN）</td>
<td>TCP</td>
</tr>
<tr>
<td>加密的网络备份（远程 Time Backup）</td>
<td>22</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>下载</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>eMule</td>
<td>4662（TCP）、4672（UDP）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>BT</td>
<td>6890 ~ 6999（用于 DSM 版本早于 v2.0.1-3.0401 的机型）；  16881（用于 DSM 版本 v2.0.1 以上的机型）</td>
<td>TCP/UDP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>网页应用程序</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>DSM</td>
<td>5000（HTTP）、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>Download Station</td>
<td>5000</td>
<td>TCP</td>
</tr>
<tr>
<td>Photo Station、Web Station</td>
<td>80（可添加另外的端口）、443（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>Mail Station</td>
<td>80（HTTP）、443（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>Audio Station</td>
<td>5000（HTTP，可添加另外的端口）、5001（HTTPS，可添加另外的端口）、5353（Bonjour 服务）、6001-6010（AirPlay 控制/定时）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>File Station</td>
<td>5000（HTTP，可添加另外的端口）、5001（HTTPS，可添加另外的端口）</td>
<td>TCP</td>
</tr>
<tr>
<td>Surveillance Station</td>
<td>9900（HTTP）、9901（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>媒体服务器</td>
<td>1900（UPnP）、50001（内容浏览）、50002（内容串流）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>Video Station</td>
<td>5000（HTTP）、5001（HTTPS）、9025-9040、 5002、5004、65001（使用 HDHomeRun 网络调谐器的情况下）</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>邮件服务器</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>SMTP</td>
<td>25</td>
<td>TCP</td>
</tr>
<tr>
<td>POP3</td>
<td>110</td>
<td>TCP</td>
</tr>
<tr>
<td>IMAP</td>
<td>143</td>
<td>TCP</td>
</tr>
<tr>
<td>IMAP 含 SSL/TLS</td>
<td>993</td>
<td>TCP</td>
</tr>
<tr>
<td>POP3 含 SSL/TLS</td>
<td>995</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>文件传输</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>FTP、FTP 含 SSL、FTP 含 TLS</td>
<td>21（命令）、20（主动模式的数据连接）、55536-55663（被动模式的数据连接）</td>
<td>TCP</td>
</tr>
<tr>
<td>AFP</td>
<td>548</td>
<td>TCP</td>
</tr>
<tr>
<td>CIFS</td>
<td>smbd：139（netbios-ssn）、445（microsoft-ds）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>Nmbd：137、138</td>
<td>UDP</td>
<td></td>
</tr>
<tr>
<td>NFS</td>
<td>111、892、2049</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>WebDAV、CalDAV</td>
<td>5005、5006（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>iSCSI</td>
<td>3260</td>
<td>TCP</td>
</tr>
<tr>
<td>TFTP</td>
<td>69</td>
<td>UDP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>套件</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>Cloud Station</td>
<td>6690</td>
<td>TCP</td>
</tr>
<tr>
<td>VPN Server（OpenVPN）</td>
<td>1194</td>
<td>UDP</td>
</tr>
<tr>
<td>VPN Server（PPTP）</td>
<td>1723</td>
<td>TCP</td>
</tr>
<tr>
<td>Syslog Server</td>
<td>514（可添加另外的端口）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>iTunes Server</td>
<td>3689</td>
<td>TCP</td>
</tr>
<tr>
<td>Directory Server</td>
<td>389（LDAP）、636（LDAP 含 SSL）</td>
<td>TCP</td>
</tr>
<tr>
<td>DHCP Server</td>
<td>67、68</td>
<td>UDP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>行动应用程序</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>DS photo+</td>
<td>80、443（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS audio</td>
<td>5000、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS cam</td>
<td>5000</td>
<td>TCP</td>
</tr>
<tr>
<td>DS file</td>
<td>Android/iOS 设备：5005、5006（HTTPS） Windows Phone：5000</td>
<td>TCP</td>
</tr>
<tr>
<td>DS finder</td>
<td>5000（HTTP）、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS video</td>
<td>5000（HTTP）、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS download</td>
<td>5000（HTTP）、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS cloud</td>
<td>6690</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><strong>打印机、UPS 和外围设备</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>LPR</td>
<td>515</td>
<td>UDP</td>
</tr>
<tr>
<td>网络打印机（IPP）/CUPS</td>
<td>631</td>
<td>TCP</td>
</tr>
<tr>
<td>Bonjour</td>
<td>5353</td>
<td>UDP</td>
</tr>
<tr>
<td>网络 MFP</td>
<td>3240-3259</td>
<td>TCP</td>
</tr>
<tr>
<td>UPS</td>
<td>3493</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><strong>系统</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>SSH/SFTP</td>
<td>22</td>
<td>TCP</td>
</tr>
<tr>
<td>Telnet</td>
<td>23</td>
<td>TCP</td>
</tr>
<tr>
<td>资源监视器/SNMP</td>
<td>161</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>MySQL</td>
<td>3306</td>
<td>TCP</td>
</tr>
<tr>
<td>LDAP</td>
<td>389、636（SLAPD）</td>
<td>TCP</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>network</category>
        <category>NAS</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>雷鸟电视在线安装软件</title>
    <url>/2021/%E9%9B%B7%E9%B8%9F%E7%94%B5%E8%A7%86%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>新买的雷鸟R625C电视往往默认是无法安装第三方应用的，即使用U盘安装了第三方应用，应用也没有升级权限。另外，也无法通过沙发管家等应用市场来安装应用。接下来说说如何使用adb工具打开雷鸟电视的第三方应用安装权限。</p>
<h2 id="ADB安装"><a href="#ADB安装" class="headerlink" title="ADB安装"></a>ADB安装</h2><p>ADB的全称为Android Debug Bridge，通过ADB工具，我们可以直接操作管理android模拟器或者真实的android设备（如安卓手机、机顶盒）。它主要有以下几种作用：<br>（1）运行设备的shell(命令行)<br>（2）管理模拟器或设备的端口映射<br>（3）计算机和android设备之间上传/下载文件<br>（4）将本地apk软件安装至android模拟器或android设备</p>
<h3 id="下载Android-Platform-Tools"><a href="#下载Android-Platform-Tools" class="headerlink" title="下载Android Platform Tools"></a>下载Android Platform Tools</h3><p>到Android开发官网下载Android Platform Tools并解压，解压后可以看到文件夹platform-tools，里面包含adb调试工具。<br> <img src="/2021/雷鸟电视在线安装软件/image-20210331111636482.png" alt="image-20210331111636482"></p>
<h3 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h3><p>打开“我的电脑-&gt;属性-&gt;系统高级设置-&gt;环境变量”，在Path变量中添加platform-tools文件夹的路径：</p>
<p><img src="/2021/雷鸟电视在线安装软件/image-20210331111701288.png" alt="image-20210331111701288"></p>
<h3 id="运行ADB"><a href="#运行ADB" class="headerlink" title="运行ADB"></a>运行ADB</h3><p>打开命令行窗口，输入adb，能打印出adb的版本号和用法，即为安装成功。</p>
<p> <img src="/2021/雷鸟电视在线安装软件/image-20210331111724426.png" alt="image-20210331111724426"></p>
<h2 id="打开电视的adb调试开关"><a href="#打开电视的adb调试开关" class="headerlink" title="打开电视的adb调试开关"></a>打开电视的adb调试开关</h2><p>进入设置-&gt;系统-&gt;系统信息，遥控器依次按下“上”、“下”、“左”、“右”，即可看到页面中跳出adb开关，将ADB设为开启状态即可：</p>
<p><img src="/2021/雷鸟电视在线安装软件/image-20210331111929404.png" alt="image-20210331111929404"></p>
<h2 id="abd工具打开电视权限"><a href="#abd工具打开电视权限" class="headerlink" title="abd工具打开电视权限"></a>abd工具打开电视权限</h2><ol>
<li><p>首先将电脑和雷鸟电视连接到同一网络下。</p>
</li>
<li><p>查看雷鸟电视的ip地址，我的这台电视的ip为192.168.0.129</p>
</li>
<li><p>根据上一步获得的ip地址，在windows命令行执行<code>adb connect 192.168.0.129:5555</code>连接到雷鸟电视：</p>
</li>
<li><p>执行adb shell进入shell模式，然后执行以下两条命令就可以成功打开第三方应用安装权限：<br><code>setprop persist.tcl.debug.installapk 1</code><br><code>setprop persist.tcl.installapk.enable 1</code></p>
<p><img src="/2021/雷鸟电视在线安装软件/image-20210331112424137.png" alt="image-20210331112424137"></p>
</li>
<li><p>然后再尝试用电视安装或升级第三方应用，第三方应用已经可以正常安装和升级，用当贝极速版或者沙发管家下载就可以了。</p>
</li>
<li><p>如果需要直接通过adb工具安装应用，先按照步骤1~3连接到电视，再执行<code>adb install</code>命令安装应用即可：<br><code>adb install XXX.apk</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>network</category>
        <category>电视</category>
      </categories>
      <tags>
        <tag>电视</tag>
      </tags>
  </entry>
</search>
