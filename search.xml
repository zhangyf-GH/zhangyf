<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>AC86U创建虚拟内存U盘读写速度不够</title>
    <url>/2021/AC86U%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98U%E7%9B%98%E8%AF%BB%E5%86%99%E9%80%9F%E5%BA%A6%E4%B8%8D%E5%A4%9F/</url>
    <content><![CDATA[<h4 id="前记"><a href="#前记" class="headerlink" title="前记"></a>前记</h4><p><code>AC86U</code> 升级固件后挂载虚拟内存总是提示读写速度不够，新固件的读取速度要求 <code>20M/s</code>，写入速度要求 <code>30M/s</code><br><img src="/2021/AC86U创建虚拟内存U盘读写速度不够/20210106091033.png" alt="img"></p>
<h4 id="解决"><a href="#解决" class="headerlink" title="解决"></a>解决</h4><p>修改参数限制</p>
<p><code>ssh</code> 登录到路由器，执行如下命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 修改写入速度限制，30替换为10</span><br><span class="line">sed -i &apos;s/^W_LIMIT=30/W_LIMIT=10/&apos; /koolshare/scripts/swap_make.sh</span><br><span class="line"></span><br><span class="line"># 修改读取速度限制，20替换为10</span><br><span class="line">sed -i &apos;s/^R_LIMIT=20/R_LIMIT=10/&apos; /koolshare/scripts/swap_make.sh</span><br></pre></td></tr></table></figure>
<p>以上参数可以根据自己的实际情况进行调整</p>
<p>完成后重新进入管理界面挂载虚拟内存即可</p>
]]></content>
      <categories>
        <category>network</category>
        <category>路由器</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>路由器</tag>
      </tags>
  </entry>
  <entry>
    <title>CollectionUtils工具类</title>
    <url>/2020/CollectionUtils%E5%B7%A5%E5%85%B7%E7%B1%BB/</url>
    <content><![CDATA[<p>这篇讲的CollectionUtils工具类是在<code>apache下</code>的, 而不是springframework下的CollectionUtils。</p>
<p>个人觉得CollectionUtils在真实项目中,可以使你的代码更加简洁和安全。</p>
<p>所以需要倒入相关jar包,目前从maven找到最新jar包如下:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.commons<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-collections4<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="API常用方法"><a href="#API常用方法" class="headerlink" title="API常用方法"></a>API常用方法</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1、除非元素为null，否则向集合添加元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.addIgnoreNull(personList,<span class="keyword">null</span>);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2、将两个已排序的集合a和b合并为一个已排序的列表，以便保留元素的自然顺序</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.collate(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 3、将两个已排序的集合a和b合并到一个已排序的列表中，以便保留根据Comparator c的元素顺序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.collate(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b, Comparator&lt;? <span class="keyword">super</span> O&gt; c)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 4、返回该个集合中是否含有至少有一个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.containsAny(Collection&lt;?&gt; coll1, T... coll2)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 5、如果参数是null，则返回不可变的空集合，否则返回参数本身。（很实用 ,最终返回List EMPTY_LIST = new EmptyList&lt;&gt;()）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.emptyIfNull(Collection&lt;T&gt; collection)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 6、空安全检查指定的集合是否为空</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.isEmpty(Collection&lt;?&gt; coll)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 7、 空安全检查指定的集合是否为空。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.isNotEmpty(Collection&lt;?&gt; coll)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 8、反转给定数组的顺序。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.reverseArray(Object[] array);</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 9、差集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.subtract(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 10、并集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.union(Iterable&lt;? extends O&gt; a, Iterable&lt;? extends O&gt; b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 11、交集</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.intersection(Collection a, Collection b)</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *12、 交集的补集（析取）</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">CollectionUtils.disjunction(Collection a, Collection b)</span><br></pre></td></tr></table></figure>
<h2 id="非对象集合交、并、差处理"><a href="#非对象集合交、并、差处理" class="headerlink" title="非对象集合交、并、差处理"></a>非对象集合交、并、差处理</h2><p>对于集合取交集、并集的处理其实有很多种方式,这里就介绍3种</p>
<ul>
<li>第一种 是CollectionUtils工具类</li>
<li>第二种 是List自带方法</li>
<li>第三种 是JDK1.8 stream 新特性</li>
</ul>
<h3 id="CollectionUtils工具类"><a href="#CollectionUtils工具类" class="headerlink" title="CollectionUtils工具类"></a>CollectionUtils工具类</h3><p>下面对于基本数据(包扩String)类型中的集合进行demo示例。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">       String[] arrayA = <span class="keyword">new</span> String[] &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;;</span><br><span class="line">       String[] arrayB = <span class="keyword">new</span> String[] &#123; <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span> &#125;;</span><br><span class="line">       List&lt;String&gt; listA = Arrays.asList(arrayA);</span><br><span class="line">       List&lt;String&gt; listB = Arrays.asList(arrayB);</span><br><span class="line"></span><br><span class="line">       <span class="comment">//1、并集 union</span></span><br><span class="line">       System.out.println(CollectionUtils.union(listA, listB));</span><br><span class="line">       <span class="comment">//输出: [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//2、交集 intersection</span></span><br><span class="line">       System.out.println(CollectionUtils.intersection(listA, listB));</span><br><span class="line">       <span class="comment">//输出:[3, 4]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//3、交集的补集（析取）disjunction</span></span><br><span class="line">       System.out.println(CollectionUtils.disjunction(listA, listB));</span><br><span class="line">       <span class="comment">//输出:[1, 2, 5, 6]</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">//4、差集（扣除）</span></span><br><span class="line">       System.out.println(CollectionUtils.subtract(listA, listB));</span><br><span class="line">       <span class="comment">//输出:[1, 2]</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h3 id="List自带方法"><a href="#List自带方法" class="headerlink" title="List自带方法"></a>List自带方法</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] arrayA = <span class="keyword">new</span> String[] &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;;</span><br><span class="line">    String[] arrayB = <span class="keyword">new</span> String[] &#123; <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span> &#125;;</span><br><span class="line">    List&lt;String&gt; listA = Arrays.asList(arrayA);</span><br><span class="line">    List&lt;String&gt; listB = Arrays.asList(arrayB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1、交集</span></span><br><span class="line">    List&lt;String&gt;  jiaoList = <span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    jiaoList.retainAll(listB);</span><br><span class="line">    System.out.println(jiaoList);</span><br><span class="line">    <span class="comment">//输出:[3, 4]</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">//2、差集</span></span><br><span class="line">    List&lt;String&gt;  chaList = <span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    chaList.removeAll(listB);</span><br><span class="line">    System.out.println(chaList);</span><br><span class="line">    <span class="comment">//输出:[1, 2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、并集 (先做差集再做添加所有）</span></span><br><span class="line">    List&lt;String&gt;  bingList = <span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    bingList.removeAll(listB); <span class="comment">// bingList为 [1, 2]</span></span><br><span class="line">    bingList.addAll(listB);  <span class="comment">//添加[3,4,5,6]</span></span><br><span class="line">    System.out.println(bingList);</span><br><span class="line">    <span class="comment">//输出:[1, 2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>注意</code> : <strong>intersection和retainAll的差别</strong></p>
<p>要注意的是它们的返回类型是不一样的,<code>intersection</code>返回的是一个新的List集合，而<code>retainAll</code>返回是Bollean类型那就说明retainAll方法是对原有集合进行处理再返回原有集合,会改变原有集合中的内容。</p>
<p><code>个人观点</code>：1、从性能角度来考虑的话,List自带会高点,因为它不用再创建新的集合。2、需要注意的是：因为retainAll因为会改变原有集合,所以该集合需要多次使用就不适合用retainAll。</p>
<p><code>注意</code>: Arrays.asList将数组转集合不能进行add和remove操作。</p>
<p><code>原因</code>：调用Arrays.asList()生产的List的add、remove方法时报异常，这是由<strong>Arrays.asList() 返回的市Arrays的内部类ArrayList， 而不是java.util.ArrayList</strong>。Arrays的内部类ArrayList和java.util.ArrayList都是继承AbstractList，remove、add等方法AbstractList中是默认throw UnsupportedOperationException而且不作任何操作。java.util.ArrayList重新了这些方法而Arrays的内部类ArrayList没有重新，所以会抛出异常。</p>
<p>所以正确做法如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] array = &#123;<span class="string">"1"</span>,<span class="string">"2"</span>,<span class="string">"3"</span>,<span class="string">"4"</span>,<span class="string">"5"</span>&#125;;</span><br><span class="line">List&lt;String&gt; list = Arrays.asList(array);</span><br><span class="line">List arrList = <span class="keyword">new</span> ArrayList(list);</span><br><span class="line">arrList.add(<span class="string">"6"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="JDK1-8-stream-新特性"><a href="#JDK1-8-stream-新特性" class="headerlink" title="JDK1.8 stream 新特性"></a>JDK1.8 stream 新特性</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    String[] arrayA = <span class="keyword">new</span> String[] &#123; <span class="string">"1"</span>, <span class="string">"2"</span>, <span class="string">"3"</span>, <span class="string">"4"</span>&#125;;</span><br><span class="line">    String[] arrayB = <span class="keyword">new</span> String[] &#123; <span class="string">"3"</span>, <span class="string">"4"</span>, <span class="string">"5"</span>, <span class="string">"6"</span> &#125;;</span><br><span class="line">    List&lt;String&gt; listA = Arrays.asList(arrayA);</span><br><span class="line">    List&lt;String&gt; listB = Arrays.asList(arrayB);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交集</span></span><br><span class="line">    List&lt;String&gt; intersection = listA.stream().filter(item -&gt; listB.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(intersection);</span><br><span class="line">    <span class="comment">//输出:[3, 4]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 差集 (list1 - list2)</span></span><br><span class="line">    List&lt;String&gt; reduceList = listA.stream().filter(item -&gt; !listB.contains(item)).collect(toList());</span><br><span class="line">    System.out.println(reduceList);</span><br><span class="line">    <span class="comment">//输出:[1, 2]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 并集 （新建集合:1、是因为不影响原始集合。2、Arrays.asList不能add和remove操作。</span></span><br><span class="line">    List&lt;String&gt; listAll = listA.parallelStream().collect(toList());</span><br><span class="line">    List&lt;String&gt; listAll2 = listB.parallelStream().collect(toList());</span><br><span class="line">    listAll.addAll(listAll2);</span><br><span class="line">    System.out.println(listAll);</span><br><span class="line">    <span class="comment">//输出:[1, 2, 3, 4, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 去重并集 </span></span><br><span class="line">    List&lt;String&gt; list =<span class="keyword">new</span> ArrayList&lt;&gt;(listA);</span><br><span class="line">    list.addAll(listB);</span><br><span class="line">    List&lt;String&gt; listAllDistinct = list.stream().distinct().collect(toList());</span><br><span class="line">    System.out.println(listAllDistinct);</span><br><span class="line">    <span class="comment">//输出:[1, 2, 3, 4, 5, 6]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>总结</code> ： 这三种我还是<code>最喜欢第一种方式</code>，因为第二种还需要确定该集合是否被多次调用。第三种可读性不高。</p>
<h2 id="对象集合交、并、差处理"><a href="#对象集合交、并、差处理" class="headerlink" title="对象集合交、并、差处理"></a>对象集合交、并、差处理</h2><p>因为对象的equels比较是比较两个对象的内存地址，所以除非是同一对象，否则equel返回永远是false。</p>
<p>但我们实际开发中 在我们的业务系统中判断对象时有时候需要的不是一种严格意义上的相等，而是一种业务上的对象相等。在这种情况下，原生的equals方法就不能满足我们的需求了，所以这个时候我们需要重写equals方法。</p>
<p><code>说明</code> :String为什么可以使用equels方法为什么只要字符串相等就为true,那是因为String类重写了equal和hashCode方法，比较的是值。</p>
<h3 id="Person对象"><a href="#Person对象" class="headerlink" title="Person对象"></a>Person对象</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 为什么重写equals方法一定要重写hashCode方法下面也会讲</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        String result = name + age;</span><br><span class="line">        <span class="keyword">return</span> result.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 equals 方法 根据name和age都相同那么对象就默认相同</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        Person u = (Person) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName().equals(u.getName()) &amp;&amp; (<span class="keyword">this</span>.age.equals(u.getAge()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 toString 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Person&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><p>这里根据name和age都相同那么就默认相同对象。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    List&lt;Person&gt; personList = Lists.newArrayList();</span><br><span class="line">    Person person1 = <span class="keyword">new</span> Person(<span class="string">"小小"</span>,<span class="number">3</span>);</span><br><span class="line">    Person person2 = <span class="keyword">new</span> Person(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    personList.add(person1);</span><br><span class="line">    personList.add(person2);</span><br><span class="line"></span><br><span class="line">    List&lt;Person&gt; person1List = Lists.newArrayList();</span><br><span class="line">    Person person3 = <span class="keyword">new</span> Person(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    Person person4 = <span class="keyword">new</span> Person(<span class="string">"大大"</span>,<span class="number">5</span>);</span><br><span class="line">    person1List.add(person3);</span><br><span class="line">    person1List.add(person4);</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 1、差集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.subtract(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='小小', age=3&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2、并集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.union(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='小小', age=3&#125;, Person&#123;name='中中', age=4&#125;, Person&#123;name='大大', age=5&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 3、交集</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.intersection(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='中中', age=4&#125;]</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 4、交集的补集（析取）</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    System.out.println(CollectionUtils.disjunction(personList, person1List));</span><br><span class="line">    <span class="comment">//输出:[Person&#123;name='小小', age=3&#125;, Person&#123;name='大大', age=5&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它两种方式就不在测了，因为都一样。</p>
<h2 id="为什么重写equels方法一定要重写hashCode方法"><a href="#为什么重写equels方法一定要重写hashCode方法" class="headerlink" title="为什么重写equels方法一定要重写hashCode方法"></a>为什么重写equels方法一定要重写hashCode方法</h2><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>其实上面的Person类我可以只重写equels方法而不写hashCode方法,一样能达到上面的效果。但为什么还是建议写上呢？官方的说法是:<code>对象的equals方法被重写，那么对象的hashCode()也尽量重写</code>。</p>
<p>重写equals()方法就必须重写hashCode()方法的原因，从源头Object类讲起就更好理解了。</p>
<p>先来看Object关于hashCode()和equals()的源码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public native int hashCode();</span><br><span class="line">      </span><br><span class="line">public boolean equals(Object obj) &#123;</span><br><span class="line">         return (this == obj);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>光从代码中我们可以知道，<code>hashCode()方法是一个本地native方法</code>，返回的是对象引用中存储的对象的内存地址。而equals方法是利用==来比较的也是对象的内存地址。从上边我们可以看出，hashCode方法和equals方法是一致的。还有最关键的一点，我们来看Object类中关于hashCode()方法的注释：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1.在 Java 应用程序执行期间，在对同一对象多次调用 hashCode 方法时，必须一致地返回相同的整数，前提是将对象进行 equals 比较时所用的信息没有被修改。    </span><br><span class="line">2.如果根据 equals(Object) 方法，两个对象是相等的，那么对这两个对象中的每个对象调用 hashCode 方法都必须生成相同的整数结果。    </span><br><span class="line">3.如果根据 equals(java.lang.Object) 方法，两个对象不相等，那么对这两个对象中的任一对象上调用 hashCode 方法不 要求一定生成不同的整数结果。</span><br><span class="line">   但是，程序员应该意识到，为不相等的对象生成不同整数结果可以提高哈希表的性能。</span><br></pre></td></tr></table></figure>
<p><code>整理</code> : hashCode()和equals()保持一致，如果equals方法返回true，那么两个对象的hasCode()返回值必须一样。如果equals方法返回false，hashcode可以不一样，但是这样不利于哈希表的性能，一般我们也不要这样做。</p>
<p>假设两个对象，重写了其equals方法，其相等条件是某属性相等，就返回true。如果不重写hashcode方法，其返回的依然是两个对象的内存地址值，必然不相等。这就出现了equals方法相等，但是hashcode不相等的情况。这不符合hashcode的规则。</p>
<h3 id="HashSet和Map集合类型"><a href="#HashSet和Map集合类型" class="headerlink" title="HashSet和Map集合类型"></a>HashSet和Map集合类型</h3><p>重写equals()方法就必须重写hashCode()方法主要是针对HashSet和Map集合类型,而对于List集合倒没什么影响。</p>
<p><code>原因</code>： 在向HashSet集合中存入一个元素时，HashSet会调用该对象（存入对象）的hashCode()方法来得到该对象的hashCode()值，然后<code>根据该hashCode值决定该对象在HashSet中存储的位置</code>。简单的说：<code>HashSet集合判断两个元素相等的标准是：两个对象通过equals()方法比较相等，并且两个对象的HashCode()方法返回值也相等</code>。如果两个元素通过equals()方法比较返回true，但是它们的hashCode()方法返回值不同，HashSet会把它们存储在不同的位置，依然可以添加成功。</p>
<p><code>这就是问题所在</code>：就是如果你只重写equals()方法，而不重写hashCode(),如果equals()为true,而它们的hashCode()方法返回值肯定不一样，因为它们都不是同一对象所以内存地址肯定不一样，所以它还是添加成功了，那么其实你写的equals()方法根本没啥软用。</p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><p><strong>1、People类</strong></p>
<p>重写equals方法,但并没有hashCode方法。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">People</span><span class="params">(String name, Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 equals 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        People u = (People) obj;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.getName().equals(u.getName()) &amp;&amp; (<span class="keyword">this</span>.age.equals(u.getAge()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写 toString 方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"People&#123;"</span> +</span><br><span class="line">                <span class="string">"name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、实现类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    HashSet&lt;People&gt; hashSet = Sets.newHashSet();</span><br><span class="line">    People people1 = <span class="keyword">new</span> People(<span class="string">"小小"</span>,<span class="number">3</span>);</span><br><span class="line">    People people2 = <span class="keyword">new</span> People(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    People people3 = <span class="keyword">new</span> People(<span class="string">"中中"</span>,<span class="number">4</span>);</span><br><span class="line">    People people4 = <span class="keyword">new</span> People(<span class="string">"大大"</span>,<span class="number">5</span>);</span><br><span class="line">    hashSet.add(people1);</span><br><span class="line">    hashSet.add(people2);</span><br><span class="line">    hashSet.add(people3);</span><br><span class="line">    hashSet.add(people4);</span><br><span class="line"></span><br><span class="line">    System.out.println(hashSet);</span><br><span class="line">    <span class="comment">//输出:[People&#123;name='小小', age=3&#125;, People&#123;name='中中', age=4&#125;, People&#123;name='大大', age=5&#125;, People&#123;name='中中', age=4&#125;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很明显,我重写了equals方法,那么people2和people3的equals应该相同，所以不能放入HashSet,但它们的hashCode()方法返回不同，所以导致同样能放入HashSet。</p>
<p><code>重点</code>：对于Set集合必须要同时重写这两个方法，要不然Set的特性就被破坏了。</p>
<p>转载自：<a href="https://www.cnblogs.com/qdhxhz/p/10787130.html" target="_blank" rel="noopener">https://www.cnblogs.com/qdhxhz/p/10787130.html</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>DNF-包管理器</title>
    <url>/2020/DNF-%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>DNF(Dandified Yum)是新一代的RPM软件包管理器。<br>DNF包管理器克服了YUM包管理器的一些瓶颈，提升了包括用户体验，内存占用，依赖分析，运行速度等多方面的内容。</p>
<h3 id="安装DNF"><a href="#安装DNF" class="headerlink" title="安装DNF"></a>安装DNF</h3><p>DNF并未默认安装在RHEL或CentOS7系统中，但可以在使用YUM的同时使用DNF。</p>
<ol>
<li>安装epel-release依赖：<code>yum install epel-release</code> 或者 <code>yum install epel-release -y</code></li>
<li>安装DNF包：<code>yum install dnf</code> 或者 <code>yum install dnf -y</code></li>
</ol>
<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>/etc/dnf/dnf.conf</p>
<h3 id="代理设置"><a href="#代理设置" class="headerlink" title="代理设置"></a>代理设置</h3><p>Add the following settings in [main] section of /etc/dnf/dnf.conf, and save the file.</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">proxy=http://&lt;ip address&gt;:&lt;port&gt;</span><br><span class="line">proxy_username=&lt;username&gt;</span><br><span class="line">proxy_password=&lt;password&gt;</span><br></pre></td></tr></table></figure>
<h3 id="DNF命令"><a href="#DNF命令" class="headerlink" title="DNF命令"></a>DNF命令</h3><p>与YUM基本保持一致，少数用法有区别。<br><a href="http://man.linuxde.net/dnf" target="_blank" rel="noopener">常用dnf命令</a></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">##### 版本</span></span><br><span class="line">dnf –version  <span class="comment"># 查看DNF包管理器版本</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 帮助</span></span><br><span class="line">dnf <span class="built_in">help</span>  <span class="comment"># 查看所有的DNF命令及其用途</span></span><br><span class="line">dnf <span class="built_in">help</span> &lt;<span class="built_in">command</span>&gt;  <span class="comment"># 获取命令的使用帮助</span></span><br><span class="line">dnf <span class="built_in">history</span>  <span class="comment"># 查看 DNF 命令的执行历史</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 信息查看</span></span><br><span class="line">dnf repolist  <span class="comment"># 查看系统中可用的DNF软件库</span></span><br><span class="line">dnf search &lt;package&gt;  <span class="comment"># 搜索软件库中的RPM包</span></span><br><span class="line"></span><br><span class="line">dnf list installed  <span class="comment"># 列出所有安装的RPM包</span></span><br><span class="line">dnf list available  <span class="comment"># 列出所有可安装的RPM包</span></span><br><span class="line">dnf info &lt;package&gt;  <span class="comment"># 查看软件包详情</span></span><br><span class="line"></span><br><span class="line">dnf provides &lt;file&gt;  <span class="comment"># 查找某一文件的提供者</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 软件包操作</span></span><br><span class="line">dnf install &lt;package&gt;  <span class="comment"># 安装软件包及其所需的所有依赖</span></span><br><span class="line">dnf update &lt;package&gt;  <span class="comment"># 升级软件包</span></span><br><span class="line">dnf remove &lt;package&gt;  <span class="comment"># 删除软件包</span></span><br><span class="line">dnf reinstall &lt;package&gt;  <span class="comment"># 重新安装特定软件包</span></span><br><span class="line">dnf distro-sync  <span class="comment"># 更新软件包到最新的稳定发行版</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 系统软件包</span></span><br><span class="line">dnf check-update  <span class="comment"># 检查系统所有软件包的更新</span></span><br><span class="line">dnf update  <span class="comment"># 升级所有系统软件包</span></span><br><span class="line">dnf clean all  <span class="comment"># 删除缓存的无用软件包</span></span><br><span class="line"></span><br><span class="line"><span class="comment">##### 组</span></span><br><span class="line">dnf grouplist</span><br><span class="line">dnf groupinstall <span class="string">'xxx'</span></span><br><span class="line">dnf groupupdate <span class="string">'xxx'</span></span><br><span class="line">dnf groupremove</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos</tag>
        <tag>DNF</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>FRP内网穿透</title>
    <url>/2021/FRP%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<p>NAS没有公网IP是一件很不方便的事情，尤其是在国内的网络环境，学校和小区内的用户通常都没有公网IP。为了解决这个问题，则需要内网穿透，而内网穿透的方法主要有两种：</p>
<p>1.不借助第三方中转，直接建立点对点的连接，创建虚拟局域网。主要有tinc 、Zerotier(先尝试穿透，穿透不了则进行中转)。</p>
<p>2.借助第三方进行数据中转。主要有ngrok、frp。</p>
<p><strong>由于手机4G网络(5G都为IPv6公网IP)和运行商的大内网内的机器（指没有公网IP的机器）所在的网络都为双端NAT网络</strong>，所以第一种方案内网穿透很困难，成功率很低。</p>
<p>而ngrok的使用和配置比frp稍复杂，所以我采用frp进行内网穿透。</p>
<p><a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">frp</a> 是一个高性能的反向代理应用，可以帮助您轻松地进行内网穿透，对外网提供服务，支持 tcp, http, https 等协议类型，并且 web 服务支持根据域名进行路由转发。github地址：<a href="https://github.com/fatedier/frp" target="_blank" rel="noopener">https://github.com/fatedier/frp</a></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul>
<li><p>VPS有公网IP的服务器，</p>
</li>
<li><p>内网机器这里是群晖NAS，也可以是能安装frpc插件路由器</p>
</li>
<li><p>PUTTY 和WinSCP</p>
</li>
<li><p>阿里云域名,假设你的域名为 aaa.com</p>
</li>
</ul>
<h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><ol>
<li><p><strong>在域名服务商的控制台里设置DNS域名解析  aaa.com解析到NAS IP</strong></p>
</li>
<li><p>到 <a href="https://github.com/fatedier/frp/releases" target="_blank" rel="noopener">https://github.com/fatedier/frp/releases</a> 下载对应平台的安装包，我是用frp_0.21.0_linux_amd64.tar.gz</p>
</li>
<li><p>如果在windows上，解压后用WinSCP上传到VPS和NAS上/root下。</p>
</li>
<li><p>修改VPS和NAS中frp_0.21.0_linux_amd64文件夹属性改为0777</p>
<p><img src="/2021/FRP内网穿透/Snipaste_2021-04-02_11-37-20.png" alt="Snipaste_2021-04-02_11-37-20" style="zoom:67%;"></p>
</li>
</ol>
<h2 id="VPS-NAS组合"><a href="#VPS-NAS组合" class="headerlink" title="VPS+NAS组合"></a>VPS+NAS组合</h2><h3 id="VPS配置"><a href="#VPS配置" class="headerlink" title="VPS配置"></a>VPS配置</h3><p>修改VPS上的frps.ini配置文件，服务端只用frps和frps.ini两个文件，其余都可删掉。</p>
<p>frps.ini文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line"></span><br><span class="line">log_file = ./frps.log</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br></pre></td></tr></table></figure>
<p>使用putty连接上VPS，切换到 /root/frp_0.21.0_linux_amd64目录下<br>前端开启，关闭窗口时服务同时关闭，仅用于观看输出，不建议使用此命令 <code>./frps -c ./frps.ini</code><br>执行命令 后台开启 <code>nohup ./frps -c ./frps.ini &amp;</code></p>
<h3 id="NAS配置"><a href="#NAS配置" class="headerlink" title="NAS配置"></a>NAS配置</h3><p>修改NAS上的frpc.ini配置文件，客户端只用frpc和frpc.ini两个文件，其余可删掉<br>frpc.ini文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = 144.168.60.183</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line">log_file = /root/frp_0.21.0_linux_amd64/frpc.log</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br><span class="line"></span><br><span class="line">[nas]</span><br><span class="line">type = http</span><br><span class="line">local_port = 5000</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /</span><br><span class="line"></span><br><span class="line">[photo]</span><br><span class="line">type = http</span><br><span class="line">local_port = 80</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /photo</span><br><span class="line"></span><br><span class="line">[windowsDrive]</span><br><span class="line">type = tcp</span><br><span class="line">local_port = 6690</span><br><span class="line">remote_port = 6690  #TCP类型不需要设置locations或者custom_domains</span><br></pre></td></tr></table></figure>
<p>NAS中配置开机启动脚本：</p>
<ol>
<li>新建 frpcExec.sh到/root,内容为：</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#/bin/bash</span><br><span class="line">nohup /root/frp_0.21.0_linux_amd64/frpc   -c   /root/frp_0.21.0_linux_amd64/frpc.ini  &gt;  /root/frp_0.21.0_linux_amd64/mynohup.out 2&gt;&amp;1 &amp;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>在NAS中新建用户触发脚本任务<code>/root/frpcExec.sh</code></p>
<p><img src="/2021/FRP内网穿透/Snipaste_2021-04-02_13-48-45.png" alt="Snipaste_2021-04-02_13-48-45"></p>
<p><img src="/2021/FRP内网穿透/Snipaste_2021-04-02_13-48-54.png" alt="Snipaste_2021-04-02_13-48-54"></p>
</li>
</ol>
<h2 id="VPS-路由器组合"><a href="#VPS-路由器组合" class="headerlink" title="VPS+路由器组合"></a>VPS+路由器组合</h2><h3 id="VPS配置-1"><a href="#VPS配置-1" class="headerlink" title="VPS配置"></a>VPS配置</h3><p>修改VPS上的frps.ini配置文件，服务端只用frps和frps.ini两个文件，其余都可删掉。</p>
<p>frps.ini文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port = 7000</span><br><span class="line"></span><br><span class="line">#由于路由器不能使用locations，所以使用二级域名，要在此配置</span><br><span class="line">subdomain_host = aaa.com</span><br><span class="line"></span><br><span class="line">log_file = ./frps.log</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br></pre></td></tr></table></figure>
<p> 使用putty连接上VPS，切换到 /root/frp_0.21.0_linux_amd64目录下，下面的步骤选一个执行</p>
<ul>
<li><p>执行命令 后台开启 <code>nohup ./frps -c ./frps.ini &amp;</code></p>
</li>
<li><p>Centos6中或者将其写入开机启动 vim /etc/rc.local   加入此行<br><code>nohup  /root/frp_0.21.0_linux_amd64/frps -c  /root/frp_0.21.0_linux_amd64/frps.ini  &gt;  /root/frp_0.21.0_linux_amd64/frps.log 2&gt;&amp;1 &amp;</code></p>
</li>
</ul>
<ul>
<li><p>Centos7使用systemd，可以新建服务，开机自动启动</p>
<p>新建文件  <code>vi /etc/systemd/system/frp.service</code> </p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=frps service</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">ExecStart=/root/frp_0.21.0_linux_amd64/frps -c /root/frp_0.21.0_linux_amd64/frps.ini </span><br><span class="line">ExecReload=/bin/kill -HUP $MAINPID</span><br><span class="line">ExecStop=/bin/kill -9 $MAINPID</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=5s</span><br><span class="line">User=root</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl daemon-reload # 添加或修改配置文件后，需要重新加载</span><br><span class="line">systemctl enable frp.service # 开机自启</span><br><span class="line">systemctl start  frp.service # 启动测试</span><br><span class="line">systemctl status frp.service # 查看启动状态</span><br><span class="line">systemctl disable frp.service # 关闭开机启动</span><br><span class="line">systemctl stop frp.service # 停止服务</span><br><span class="line">systemctl restart frp.service # 重启服务</span><br></pre></td></tr></table></figure>
<h3 id="路由器AC86U"><a href="#路由器AC86U" class="headerlink" title="路由器AC86U"></a>路由器AC86U</h3><ol>
<li><p>到koolshare论坛下载带有软件中心的固件刷机，下载Frpc插件。或者你用软路由系统的软件中心下载Frpc插件。</p>
<p><img src="/2021/FRP内网穿透/image-20210402141322236.png" alt="image-20210402141322236"></p>
</li>
<li><p>在自定义配置中填入一下配置  </p>
<p>路由器的IP为192.168.50.1 </p>
<p>掩码为192.168.50.255</p>
<p>NAS的IP 192.168.50.123</p>
<p>电脑的IP 192.168.50.100</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr = VPS IP地址</span><br><span class="line">server_port = 7000</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log_file = /tmp/upload//frpc.log</span><br><span class="line">log_level = info</span><br><span class="line">log_max_days = 3</span><br><span class="line"></span><br><span class="line">#路由器ssh，需要在路由器中开启ssh模式，一般不需要对外网开放，访问VPS的6000端口，转发到路由器的22端口</span><br><span class="line">[routerSSH]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 127.0.0.1</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6000</span><br><span class="line"></span><br><span class="line">#nas的ssh功能，一般不需要对外网开放，访问VPS的6001端口，转发到NAS(192.168.50.123)的22端口</span><br><span class="line">[nasSSH]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 22</span><br><span class="line">remote_port = 6001</span><br><span class="line"></span><br><span class="line">#nas的web端 访问http://aaa.com,转发到NAS(192.168.50.123)的5000端口</span><br><span class="line">[nas]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 5000</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /</span><br><span class="line"></span><br><span class="line">#transmission的web端 访问http://aaa.com/trans,转发到NAS(192.168.50.123)的9091端口</span><br><span class="line">[transmission]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 9091</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /trans</span><br><span class="line"></span><br><span class="line">[aria2]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 6080</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /aria</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[photo]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 80</span><br><span class="line">custom_domains = aaa.com</span><br><span class="line">locations = /photo</span><br><span class="line"></span><br><span class="line">[windowsDrive]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 192.168.50.123</span><br><span class="line">local_port = 6690</span><br><span class="line">remote_port = 6690</span><br><span class="line"></span><br><span class="line">#路由器使用二级域名，通过http://router.aaa.com访问</span><br><span class="line">#使用远程管理路由器也可以进行局域网唤醒</span><br><span class="line">#需要添加二级域名解析 router.aaa.com解析到NAS IP</span><br><span class="line">[router]</span><br><span class="line">type = http</span><br><span class="line">local_ip = 192.168.50.1</span><br><span class="line">local_port = 80</span><br><span class="line">subdomain = router</span><br><span class="line"></span><br><span class="line">#远程唤醒</span><br><span class="line">[wol]</span><br><span class="line">type = udp    #类型为UDP</span><br><span class="line">local_ip = 192.168.50.255    #此处填写广播地址，不需要再路由器中设置端口转发</span><br><span class="line">local_port = 9</span><br><span class="line">remote_port = 9</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#局域网唤醒后，使用远程桌面进行访问，走frps主机流量访问192.168.50.100(电脑固定IP)的3389端口</span><br><span class="line">[remote desktop]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 192.168.50.100</span><br><span class="line">local_port = 3389</span><br><span class="line">remote_port = 3389</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h2><p>DS file、DS finder、DS audio 官方使用5000端口 ， DS photo官方使用80端口</p>
<p>web端访问管理界面 <a href="http://aaa.com" target="_blank" rel="noopener">http://aaa.com</a> </p>
<p>web端访问路由器 <a href="http://router.aaa.com" target="_blank" rel="noopener">http://router.aaa.com</a></p>
<p>移动端APP填入以下地址：</p>
<p>ds file                                 aaa.com:80/               :80不能省略，省略的话，APP可能默认使用5000端口<br>ds audio                            aaa.com:80/               :80不能省略，省略的话，APP可能默认使用5000端口<br>ds photo                           aaa.com:80/photo<br>android drive                   aaa.com:80/</p>
<p>windows drive                 aaa.com:6690           不能省略端口</p>
]]></content>
      <categories>
        <category>network</category>
        <category>内网穿透</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>frp</tag>
        <tag>VPS</tag>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+GitPages搭建博客</title>
    <url>/2021/Hexo-GitPages%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h2 id="安装Git"><a href="#安装Git" class="headerlink" title="安装Git"></a>安装Git</h2><p>假设：邮箱：<a href="mailto:aaa@163.com" target="_blank" rel="noopener">aaa@163.com</a>  </p>
<p>​            名字: aaa</p>
<p>1.到官网下载git安装包后安装</p>
<p>2.在Windows系统安装git后，配置SSH key </p>
<p>用git bash执行如下命令： windows中在C:\Users\zhangyf.ssh目录</p>
<p><code>$ cd ~/. ssh #检查本机已存在的ssh密钥</code></p>
<p>如果提示：No such file or directory 说明你是第一次使用git。</p>
<p><code>ssh-keygen -t rsa -C &quot;aaa@163.com&quot;</code></p>
<p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件，记事本打开并复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image002.png" alt="img"></p>
<p>将刚复制的内容粘贴到key那里，title随便填，保存。</p>
<p>3.测试是否成功</p>
<p>$ ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a> # 注意邮箱地址不用改</p>
<p>如果提示Are you sure you want to continue connecting (yes/no)?，输入yes，然后会看到：</p>
<p>Hi liuxianan! You’ve successfully authenticated, but GitHub does not provide shell access.</p>
<p>看到这个信息说明SSH已配置成功！</p>
<p>此时你还需要配置：</p>
<p><code>git config --global user.email &quot;aaa@163.com&quot;</code></p>
<p><code>git config --global user.name &quot;aaa&quot;</code></p>
<h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><p>在node.js官网下载安装包安装即可</p>
<h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>首先在本地磁盘中建立一个Hexo文件夹用于存储本地文件(做本地文件保存以及测试使用)</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image004.jpg" alt="img"></p>
<p>然后在文件夹中右击打开git命令框(我第一次直接在桌面右击，所以命令行无效果)</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image006.jpg" alt="img"></p>
<p>在git命令框中安装hexo命令行工具 ，执行 <code>npm install -g hexo-cli</code> </p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image008.jpg" alt="img"></p>
<p> 初始化 ，执行<code>hexo init zyfblog</code> 加上zyfblog，则全部文件都在zyfblog下</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image010.jpg" alt="img"></p>
<p>执行<code>cd zyfblog</code> 进入zyfblog目录</p>
<p>启动服务，依次执行</p>
<p><code>(npm install --&gt;hexo server)</code></p>
<p>浏览器输入<a href="http://localhost:4000,按理来说应该会出现本地访问页面" target="_blank" rel="noopener">http://localhost:4000,按理来说应该会出现本地访问页面</a></p>
<h2 id="部署到GItPages"><a href="#部署到GItPages" class="headerlink" title="部署到GItPages"></a>部署到GItPages</h2><h3 id="在github上面创建项目"><a href="#在github上面创建项目" class="headerlink" title="在github上面创建项目"></a>在github上面创建项目</h3><p>假设:Owner为: zhangyfzone </p>
<p>​         <strong>Repository name必须为: zhangyfzone.github.io</strong></p>
<p>​         申请的域名：minmax.site</p>
<p><img src="/2021/Hexo-GitPages搭建博客/image-20210330094423950.png" alt="image-20210330094423950"></p>
<h3 id="DNS设置"><a href="#DNS设置" class="headerlink" title="DNS设置"></a>DNS设置</h3><p>如果没有域名，则只能通过GitPages默认链接访问<a href="https://zhangyfzone.github.io/" target="_blank" rel="noopener">https://zhangyfzone.github.io/</a></p>
<p>如果有域名，可将域名解析到zhangyfzone.github.io，这样比较简洁。</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image016.png" alt="img"></p>
<h3 id="hexo-CNAME设置"><a href="#hexo-CNAME设置" class="headerlink" title="hexo CNAME设置"></a>hexo CNAME设置</h3><p> Hexo目录下的source中建一个CNAME命名的文件夹(切记没有后缀)</p>
<p>创建方式：右键新建txt文本-&gt;输入你购买的域名minmax.site&gt;保存关闭</p>
<p>然后快捷键F2或者右键该文本重命名-&gt;将.txt后缀去掉-&gt;会提示文件不可用继续确定即可</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image018.jpg" alt="img"></p>
<p>内容如下所示</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image019.png" alt="img"></p>
<h3 id="github上绑定域名"><a href="#github上绑定域名" class="headerlink" title="github上绑定域名"></a>github上绑定域名</h3><p>在设置中的custom domain填入域名minmax.site 保存</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image021.png" alt="img"></p>
<h3 id="修改-config-yml"><a href="#修改-config-yml" class="headerlink" title="修改_config.yml"></a>修改_config.yml</h3><p><img src="/2021/Hexo-GitPages搭建博客/clip_image023.jpg" alt="img"></p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image024.png" alt="img"></p>
<p>配置github项目连接(</p>
<p>deploy: </p>
<p>type: git </p>
<p>repos: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:zhangyfzone/zhangyfzone.github.io.git</p>
<p>branch: master):</p>
<p><img src="/2021/Hexo-GitPages搭建博客/clip_image026.jpg" alt="img"></p>
<h3 id="使用git发布"><a href="#使用git发布" class="headerlink" title="使用git发布"></a>使用git发布</h3><p>执行 <code>npm install hexo-deployer-git --save</code></p>
<p>基本的流程到这里快要结束了</p>
<p>信件一篇博文  <code>hexo new post &#39;第一篇博文&#39;</code>  可在source/post文件夹下面看到，可以编辑内容。</p>
<p>最后执行:<code>(hexo clean --&gt;hexo generate --&gt;hexo deploy)</code></p>
<p><code>hexo generate --&gt;hexo deploy</code> 可简写为 <code>hexo g -d</code></p>
<p>你就可以通过域名看到你的博客了</p>
<p>记住，每次修改配置信息或者其他必须要执行上面的步骤，才可以使得配置信息生效。</p>
<p> 常用命令：</p>
<p><code>hexo new &#39;博文&#39;</code>  默认创建post</p>
<p><code>hexo server</code></p>
<p><code>hexo g -d</code></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo博客部署到VPS</title>
    <url>/2021/Hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0VPS/</url>
    <content><![CDATA[<h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>网上流传的武功秘籍分为两种：</p>
<ul>
<li>将 Hexo 项目上传到 VPS 上面后执行 <code>hexo server</code>，之后配置 Nginx 反向代理，让域名指向 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000</a>。</li>
<li>将 Hexo 在本地通过 <code>hexo generate</code> 生成静态文件，在通过 <code>hexo deploy</code> 部署到 VPS 上面，使用 Nginx 直接做 Web 服务器。</li>
</ul>
<p>相比第二种方式，第一种每次写博客与更新博客时候的操作会很繁琐。所以我们使用第二种方式进行部署，这样既可以将静态文件 deploy 到 VPS 上，也可以上传到 Github 上用作备份，操作性和安全性上都要胜于前者。</p>
<p>而对于第二种方式而言，常用的又有 <code>git hook</code> 和 <code>rsync</code> 两种自动部署解决方案。</p>
<p>本文主要介绍 <code>git hook</code> 部署过程，过程为：</p>
<p>我们在本地编辑文本，然后使用 Git 远程部署到 VPS 的 Git 仓库。<code>hexo d</code> 命令实际上只 deploy 了本地的 public 文件夹，Git Hooks 实际上就是当 Git 仓库收到最新的 push 时，将 Git 仓库接受到的内容复制到 VPS 上的网站目录内。相当于完成了手动将 public 文件夹复制到 VPS 的网站根目录里。</p>
<p>在vps上搭建hexo博客需要下面这些工具：</p>
<ol>
<li>Nginx: 用于博客展示</li>
<li>SSH：用于Git 推送</li>
<li>Git: 用于将生成的静态文件推送到vps上</li>
</ol>
<p>本文服务器环境为CentOS 7.6</p>
<p>之前本地已经搭建好Hexo博客，之前是提交到Github进行更新</p>
<h2 id="本地配置"><a href="#本地配置" class="headerlink" title="本地配置"></a>本地配置</h2><p>查看C:\Users\用户名\.ssh 下是否存在私钥文件<code>id_rsa</code>和公钥文件<code>id_rsa.pub</code></p>
<p>如果没有，则需要通过<code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;</code> 生成</p>
<h2 id="VPS端配置"><a href="#VPS端配置" class="headerlink" title="VPS端配置"></a>VPS端配置</h2><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p>ssh连接到VPS后，执行如下指令进行Git的安装</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum update &amp;&amp; upgrade -y</span><br><span class="line">yum install epel-release</span><br><span class="line">yum install git-core</span><br></pre></td></tr></table></figure>
<h3 id="安装-Nginx"><a href="#安装-Nginx" class="headerlink" title="安装 Nginx"></a>安装 Nginx</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yum install nginx -y</span><br><span class="line">service nginx start  #启动nginx</span><br></pre></td></tr></table></figure>
<p>如果开启了防火墙，还要在防火墙上开启响应端口，操作如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firewall-cmd --permanent --zone=public --add-service=http</span><br><span class="line">firewall-cmd --permanent --zone=public --add-service=https</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">启动： systemctl start firewalld</span><br><span class="line">关闭： systemctl stop firewalld</span><br><span class="line">查看状态： systemctl status firewalld </span><br><span class="line">开机禁用 ： systemctl disable firewalld</span><br><span class="line">开机启用 ： systemctl enable firewalld</span><br></pre></td></tr></table></figure>
<p>安装完Nginx后，最好设置Nginx为开机自启动，操作如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl enable nginx</span><br></pre></td></tr></table></figure>
<h3 id="Git相关配置"><a href="#Git相关配置" class="headerlink" title="Git相关配置"></a>Git相关配置</h3><ol>
<li>新建git用户，在终端输入如下指令以新建账户，专门用于提交git</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line">adduser git #创建新用户，名为git</span><br></pre></td></tr></table></figure>
<p>接下来修改git账户的权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 740 /etc/sudoers</span><br><span class="line">vi /etc/sudoers</span><br></pre></td></tr></table></figure>
<p>在<code>root ALL=(ALL) ALL</code>下面新建一段字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git ALL=(ALL) install</span><br></pre></td></tr></table></figure>
<p>接着保存退出，并执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod 440 /etc/sudoers</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>创建git仓库</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su git                 # 操作转到git用户</span><br><span class="line">cd                     # 定位到Home目录</span><br><span class="line">mkdir .ssh &amp;&amp; cd .ssh  # 创建.ssh文件夹并进入</span><br><span class="line">vi authorized_keys     # 创建密钥文件</span><br></pre></td></tr></table></figure>
<p>此时，将本地<code>id_rsa.pub</code>文件内的内容粘贴到新建的<code>authorized_keys</code>文件中。接下来执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd</span><br><span class="line">mkdir hexo.git &amp;&amp; cd hexo.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure>
<p>此时，在本地终端中输入<code>ssh git@VPS_ip</code>查看收否能连接，如果提示要密码，则需要在VPS内设置一下git用户的密码，操作如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">passwd git</span><br></pre></td></tr></table></figure>
<p>接着设置git用户的密码，并在本地终端中重新连接，输入密码，应该就可以连接了。</p>
<p>如果部署时还是需要密码，则是authorized_keys 文件权限设置有问题，请查看博客里的另一篇文章 <a href="http://www.minmax.site/2021/03/25/authorized-keys不生效解决办法/" target="_blank" rel="noopener">authorized_keys不生效解决办法</a></p>
<ol start="3">
<li>接下来要创建网站的目录，并赋予权限</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line">cd /var/www</span><br><span class="line">mkdir hexo</span><br><span class="line">chown git:git -R /var/www/hexo</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>配置Git Hooks</li>
</ol>
<p>【注意】这一步在git用户下执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su git</span><br><span class="line">cd /home/git/hexo.git/hooks</span><br><span class="line">vi post-receive</span><br></pre></td></tr></table></figure>
<p>输入如下内容后保存</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">GIT_REPO=/home/git/hexo.git       #git仓库路径</span><br><span class="line">TMP_GIT_CLONE=/tmp/hexo</span><br><span class="line">PUBLIC_WWW=/var/www/hexo          #hexo网站目录</span><br><span class="line">rm -rf $&#123;TMP_GIT_CLONE&#125;</span><br><span class="line">git clone $GIT_REPO $TMP_GIT_CLONE</span><br><span class="line">rm -rf $&#123;PUBLIC_WWW&#125;/*</span><br><span class="line">cp -rf $&#123;TMP_GIT_CLONE&#125;/* $&#123;PUBLIC_WWW&#125;</span><br></pre></td></tr></table></figure>
<p>接着赋予权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod +x post-receive</span><br></pre></td></tr></table></figure>
<h3 id="Nginx相关配置"><a href="#Nginx相关配置" class="headerlink" title="Nginx相关配置"></a>Nginx相关配置</h3><p>【注意】本操作在root用户下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">su root</span><br><span class="line">vim /etc/nginx/conf.d/hexo.conf</span><br></pre></td></tr></table></figure>
<p>插入如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">    listen  80 ;</span><br><span class="line">    root /var/www/hexo; //这里可以改成你的网站目录地址，我将网站放在/var/www/hexo</span><br><span class="line">    server_name example.com www.example.com;   //这里输入你的域名或IP地址</span><br><span class="line">    access_log  /var/log/nginx/hexo_access.log;</span><br><span class="line">    error_log   /var/log/nginx/hexo_error.log;</span><br><span class="line">    location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ &#123;</span><br><span class="line">            root /var/www/hexo;</span><br><span class="line">            access_log   off;</span><br><span class="line">            expires      1d;</span><br><span class="line">    &#125;</span><br><span class="line">    location ~* ^.+\.(css|js|txt|xml|swf|wav)$ &#123;</span><br><span class="line">        root /var/www/hexo;</span><br><span class="line">        access_log   off;</span><br><span class="line">        expires      10m;</span><br><span class="line">    &#125;</span><br><span class="line">    location / &#123;</span><br><span class="line">        root /var/www/hexo;      //这里可以改成你的网站目录地址，我将网站放在/var/www/hexo</span><br><span class="line">        if (-f $request_filename) &#123;</span><br><span class="line">            rewrite ^/(.*)$  /$1 break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启Nginx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure>
<h2 id="本地Hexo配置修改"><a href="#本地Hexo配置修改" class="headerlink" title="本地Hexo配置修改"></a>本地Hexo配置修改</h2><p>在本地<code>hexo</code>博客文件下，编辑配置文件<code>\_config.yml</code>，修改<code>deploy</code>选项，可同时发布到github和vps</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  - type: git</span><br><span class="line">    repo: git@github.com:zhangyfzone/zhangyfzone.github.io.git  #gitHub上用作备份</span><br><span class="line">    branch: master</span><br><span class="line">  - type: git</span><br><span class="line">    repo: ssh://git@VPSIP:端口号/~/hexo.git   #部署到VPS上</span><br><span class="line">    branch: master</span><br></pre></td></tr></table></figure>
<p>保存修改后，便可以使用<code>hexo g</code>,<code>hexo d</code>等指令进行博客更新了。</p>
<h2 id="gitHub配置更改"><a href="#gitHub配置更改" class="headerlink" title="gitHub配置更改"></a>gitHub配置更改</h2><p>如果之前部署到github上时设置了域名，则再setting里把custom domain 之前设置的域名清除。</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>vps</tag>
      </tags>
  </entry>
  <entry>
    <title>LF will be replaced by CRLF</title>
    <url>/2020/LF-will-be-replaced-by-CRLF/</url>
    <content><![CDATA[<p>本文主要写了在 Hexo 博客中 出现 LF will be replaced by CRLF 的原因以及它的解决方式。</p>
<h5 id="出现的原因"><a href="#出现的原因" class="headerlink" title="出现的原因"></a>出现的原因</h5><ol>
<li>windows中的换行符为 CRLF，而在Linux下的换行符为LF，所以在执行add时出现提示 </li>
<li>CRLF和LF是两种不同的换行格式，git工作区默认为CRLF来作为换行符，<br> 所以当我们项目文件里有用的地方使用LF作为换行符，这个时候我们再继续git add<br> 或者git commit的时候就会弹出警告，当最终push到远程仓库的时候git会统一格式全部转化为用CRLF作为换行符 </li>
</ol>
<h5 id="解决方式"><a href="#解决方式" class="headerlink" title="解决方式"></a>解决方式</h5><ol>
<li>这个只是一个警告，我们直接忽略就好。</li>
<li>在hexo目下的.deploy_git目录下打开git bash 执行git config –global core.autocrlf false //禁用自动转换 </li>
</ol>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>NAT号段</title>
    <url>/2021/NAT%E5%8F%B7%E6%AE%B5/</url>
    <content><![CDATA[<p>我们现在常使用的IP地址是IPv4地址，由32位二进制数组成，每隔8位二进制数字用小数点分隔，可得四组二进制数，将每组二进制数转为十进制数，就是我们平常看到的IP地址。Internet上的每一台主机或者路由器都至少有一个IP地址。IP地址的长度是32位，总数为2的32次方，大约43亿个。</p>
<p>NAT（Network Address Translation），中文名唤作网络地址转换，诞生于IP地址匮乏的时代。</p>
<p>NAT的基本思想是ISP（Internet服务提供商）为每个家庭或者公司分配一个IP地址，这个IP地址用作Internet流量的传输，也就是大家常说的<strong>外网</strong>IP地址或者<strong>公网</strong>IP地址。在客户网络的内部，每台计算机有唯一一个IP地址，即<strong>内网</strong>IP地址，这些地址主要用于路由内部流量。当一个数据包离开客户网络发送至其他ISP时，需要进行<strong>地址转换</strong>，把唯一的内网IP地址转换成外网的IP地址。</p>
<p>这种地址转化使用IP地址的三个范围，这些地址已被声明私有化，任何内网中的设备可以任意使用这些地址，但是在这三个范围内的IP地址不允许出现在Internet（外网）上，这三个保留的地址范围是：</p>
<p>10.0.0.0~10.255.255.255/8</p>
<p><strong>100.64.0.0 ~100.127.255.255/10</strong>  <strong>用于在电信级NAT环境中服务提供商与其用户通信</strong> </p>
<p>172.16.0.0~172.31.255.255/12</p>
<p>192.168.0.0~192.168.255.255/16</p>
<p>他们分别可以容纳16777216、1048576、65536台主机。一般家里用无线路由器，就用到了网络地址转换技术，我们连上wifi后分配的IP地址一般是以172或192为开头。学校或者大企业里面的网络可能会用到10开头的地址范围。</p>
<p>NAT将内网外网划分好之后，是如何使内网的设备访问外网的呢？</p>
<p>如下图，当计算机<strong>A</strong>在内网（假设IP为10.0.0.1）想去访问一个Internet上的网站<strong>S</strong>（假设IP地址为54.223.189.245）时，<strong>A</strong>的数据包需要先经过一个<strong>NAT盒子</strong>(NAT box)，这个盒子先将<strong>A</strong>的IP源地址转换成外网的真实IP地址（假设IP为121.0.0.2），然后将转换后的数据包发送至Internet。</p>
<p><img src="/2021/NAT号段/clip_image001.png" alt="clip_image001"></p>
<p>于是问题来了，当网站<strong>S</strong>收到这个数据包后，会处理请求，并发送响应的数据包，然而这个数据包的目标地址是121.0.0.2（外网IP），数据包如何返回内网中的<strong>A</strong>呢？</p>
<p>这里要先介绍一下<strong>源端口</strong>（Source Port）和<strong>目标端口</strong>（Destination Port）的概念。当一个进程希望与另一个进程建立TCP连接时，它把自己绑定到一个本机尚未被占用的TCP端口上，这个端口称为<strong>源端口</strong>，该TCP连接中所有入境的数据包都要被发送至这个端口。同时进程还需要提供一个<strong>目标端口</strong>，指明数据包到达远程主机后送至哪一个端口处理。每一个出境的TCP数据包都包括一个源端口和目标端口。</p>
<p>举例来说，如下图，网站服务器<strong>S</strong>（IP地址为54.223.189.245）的HTTP服务运行在80端口上，公网上的计算机<strong>D</strong>（IP地址为121.141.56.23）想去访问网站<strong>S</strong>，于是把自己绑定到本机的33121端口上，并发送请求的数据包，这个数据包中就包含了计算机<strong>D</strong>的源端口33121和目标端口80。网站<strong>S</strong>收到请求后，发送响应的数据包，这个数据包中包含了服务器<strong>S</strong>的源端口80和目标端口3312。</p>
<p> <img src="/2021/NAT号段/20161103125031128.png" alt="20161103125031128"></p>
<p>上面的例子是外网中的一台计算机访问一个网站。在内网中计算机发送的数据包同样存在着源端口和目标端口。NAT盒子做的事情就是对出入境数据包的端口进行修改。</p>
<p>回到最初举的例子，假设内网计算机<strong>A</strong>（IP地址为10.0.0.1）发送的请求包的源端口是45421，目标端口是80，请求访问网站服务器<strong>S</strong>（IP地址为54.223.189.245）。</p>
<p>当这个出境数据包经过NAT盒子时，其源地址被修改成公网的真实IP（121.0.0.2），源端口被修改一个索引值（假设为50002），这个索引值指向NAT盒子的地址转化表中的某一项，这一表项保存了计算机<strong>A</strong>的内网源地址和源端口。最后NAT盒子将重新生成的数据包发送出去。</p>
<p>当网站S响应的入境数据包到达NAT盒子时，数据包经过处理，目的地址由公网IP（121.0.0.2）还原为计算机A的内网IP（10.0.0.1），目标端口由索引值（50002）还原为计算机A的源端口（45421）。还原后数据包可以正常的在内网路由。</p>
<p>这个过程基本如下图所示。</p>
<p><img src="/2021/NAT号段/clip_image003.png" alt="clip_image003"></p>
<p>如此一来，NAT解决了数据包在内网公网之间的地址和端口的转换问题，暂时缓解了IP地址的短缺，但是它却有着不少的缺点。</p>
<p>NAT违背了IP的结构模型（每个IP地址唯一标识世界上的一台机器），采用NAT后可能有无数台主机使用10.0.0.1这个IP地址。NAT还打破了Internet的端-端的连接模型。内网中的主机可以通过NAT与一台公网上的服务建立连接，但是反过来却不行，公网上的主机无法与某一内网中的主机建立连接。举个简单的例子来说，你在内网某台计算机上搭建了一个网站，在外网是无法访问的。而且使用NAT后，Internet变得如电路交换网络一样脆弱。NAT盒子为每个经过它的连接维护必要的信息（即映射关系），若NAT盒子崩溃，并且所有映射表被摧毁，所有TCP连接将被摧毁。</p>
<p>目前的IP地址匮乏，归根结底是IPv4设计者的锅，NAT只是权宜之策。既然NAT这么复杂，有人要问了，在IPv6普及后，NAT是否就会被取缔了呢？答案是不会的。因为NAT已被广泛使用，尤其是家庭和小型企业的网络，即使IPv6普及了，NAT在短时间内也很难被取代。</p>
<p> <strong>IPv4保留地址</strong><br><img src="/2021/NAT号段/Snipaste_2021-04-01_15-28-01.png" alt="Snipaste_2021-04-01_15-28-01"></p>
<p><strong>IPv6保留地址</strong><br><img src="/2021/NAT号段/Snipaste_2021-04-01_15-28-14.png" alt="Snipaste_2021-04-01_15-28-14"></p>
<p>参考：</p>
<p><a href="https://zh.wikipedia.org/wiki/%E4%BF%9D%E7%95%99IP%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener">保留的IP地址</a></p>
]]></content>
      <categories>
        <category>network</category>
        <category>理论</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>NAT类型和穿透性</title>
    <url>/2021/NAT%E7%B1%BB%E5%9E%8B%E5%92%8C%E7%A9%BF%E9%80%8F%E6%80%A7/</url>
    <content><![CDATA[<h2 id="网络地址映射"><a href="#网络地址映射" class="headerlink" title="网络地址映射"></a>网络地址映射</h2><p>在有中心化服务器的网络中，客户端，服务器，网关构成网络拓扑图。如下图1所示：由于后续出现的名词概念很多，先约法三章，在这里统一一下称呼：所有的终端机器成为客户端，不同客户端使用大写字母区分（A,B,C,…）；客户端上面运行的应用程序统一称为客户程序，不同的应用程序使用不数字区分（1,2,3,…）。作为服务器的物理机称为服务器，而服务器上运行的程序称为服务程序，后文中每一个拓扑组件都只有一个IP地址。为客户端提供公网IP服务的组件称为网关。</p>
<p><img src="/2021/NAT类型和穿透性/clip_image002.jpg" alt="img" style="zoom:67%;"></p>
<p>图1 中心化服务器的网络拓扑图</p>
<p>从网关映射到客户端中的网络结构，这里需要引入一个NAT的概念。什么NAT呢？中文名叫网络地址转换，习惯称为网络地址映射。为什么需要网络地址映射呢？：需要说到IPV4网络地址已经用完，全部使用IPV6又会造成很多只支持IPV4的终端设备无法正常使用，所以网络地址映射应运而生，忍辱负重。才会有我们现在所谓的网络穿透的出现。到底怎么映射的？如图2网络地址映射所示。客户程序使用192.168.0.234:7890发送数据，通过网关的网络地址映射在公网被转换为112.93.116.102:6834，被互联网上的大家所认知。此时在公网上使用客户程序的ip与端口被112.93.116.102:6834代替。在这里大家应该明白了NAT是何许物种了。</p>
<p><img src="/2021/NAT类型和穿透性/clip_image004.jpg" alt="img" style="zoom: 67%;"><br>​图2 网络地址映射</p>
<p>为了保持新手福音，业界良心的态度。什么是穿透？因为NAT是客户程序发起的，网络为了保持通讯新建的一个临时牌照，随时可能被收回，而且重新发起后的牌照不一样。从而外界及时知道了这个临时牌照也没有用。所以需要通过穿透在网关上面打个洞，来为外界进行服务。那NAT与穿透有什么关系呢？正因为有了NAT才需要穿透，如果是IPV6每个客户端一个IP地址，那就不需要直接可以找到客户端了。</p>
<h2 id="NAT种类"><a href="#NAT种类" class="headerlink" title="NAT种类"></a>NAT种类</h2><p>  由于网关的安全性要求不一致，就出现四种不同的NAT方式。分别进行阐述：</p>
<p>第一种<strong>完全锥形NAT</strong>，英文名叫<strong>Full Cone NAT</strong>。如图3完全锥形NAT所示，客户程序(192.168.0.234:7890)与服务器A(13.44.178.98:9800)通信，通过网关的地址转换产生的临时牌照的公网地址（112.93.116.102:6834），服务器B（157.78.13.156:23456）发送数据到公网地址（112.93.116.102:6834），如果客户程序(192.168.0.234:7890)能够收到服务器B（157.78.13.156:23456）发送的数据，这种NAT映射关系为完全锥形NAT；</p>
<p><img src="/2021/NAT类型和穿透性/clip_image006.png" alt="img" style="zoom:67%;"><br>​图3 完全锥形NAT</p>
<p>第二种<strong>限制锥形NAT</strong>，英文名叫<strong>RestrictedCone NAT</strong>。在图3 完全锥形NAT中，如果客户程序(192.168.0.234:7890)不能收到服务器B（157.78.13.156:23456）发送的数据，这种NAT映射关系为限制型锥形NAT。</p>
<p>第三种<strong>端口限制锥形NAT</strong>，英文名叫<strong>Port RestrictedCone NAT</strong>。客户程序(192.168.0.234:7890)发送数据给服务程序（13.44.178.98:9800）,网关通过网络地址转换产生的地址（112.93.116.102:6834）,同样的服务器内的另一个服务程序（13.44.178.178:9801）发送数据给网关（112.93.116.102:6834）地址，如果客户程序(192.168.0.234:7890)能够收到，则为限制锥形NAT，如果客户程序(192.168.0.234:7890)不能收到，则为端口限制锥形NAT。</p>
<p>  对于所有的锥型NAT，客户程序（192.168.0.234:7890）对外发送的数据时，网关地址转换的地址都是一样的为（112.93.116.102:6834）,那为什么在图4 限制型锥形NAT中，客户程序不能收到服务程序B（13.44.178.98:9801）的数据呢？因为在网关中没有发生过客户程序（192.168.0.234:7890）给服务程序B（13.44.178.98:9801），故服务程序（13.44.178.98:9801）直接发送给网关（112.93.116.102:6834），则被网关所丢弃。</p>
<p><img src="/2021/NAT类型和穿透性/clip_image008.jpg" alt="img" style="zoom:67%;"></p>
<p>图4 限制型锥形NAT</p>
<p>第四种<strong>对称NAT</strong>，英文，名叫<strong>Symmetric NAT</strong>。如图5对称NAT所示，客户程序（192.168.0.234:7890）发送数据给两个不同服务器（13.44.178.98:9800）和（157.78.13.156:23456）时，网关会进行不同的网络地址映射产生（112.93.116.102:6834）和（112.93.116.102:6835）。这是对于整个NAT网络发送数据出去的过程，而接收数据与端口限制锥形NAT一致。</p>
<p><img src="/2021/NAT类型和穿透性/clip_image010.png" alt="img" style="zoom:67%;"><br>             图5 对称NAT</p>
<h2 id="不同NAT组合的穿透性"><a href="#不同NAT组合的穿透性" class="headerlink" title="不同NAT组合的穿透性"></a><strong>不同NAT组合的穿透性</strong></h2><p>这里说的穿透指在没有经过第三方数据中转的情况下，两者直接建立点对点的连接，可直接进行数据交换，相当于两者在一个虚拟的局域网中。</p>
<p><img src="/2021/NAT类型和穿透性/image-20210401162435764.png" alt="image-20210401162435764"></p>
]]></content>
      <categories>
        <category>network</category>
        <category>理论</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>内网穿透</tag>
      </tags>
  </entry>
  <entry>
    <title>WOL-远程唤醒-ARP绑定</title>
    <url>/2021/WOL-%E8%BF%9C%E7%A8%8B%E5%94%A4%E9%86%92-ARP%E7%BB%91%E5%AE%9A/</url>
    <content><![CDATA[<p>如果路由器具有公网IP，可以不需要VPS转发WOL数据包，直接在外网连接路由器发送WOL数据包，进行远程唤醒。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li><p>域名设置DDNS  <strong>aaa.com -&gt; 路由器公网IP</strong></p>
</li>
<li><p>windows系统设置了允许WOL的配置，可参考以前文章。</p>
</li>
<li><p>路由器设置了端口转发，如下：</p>
<p>外部9000端口转发到192.168.50.100的9号端口；外部9001端口转发到192.168.50.123的9号端口</p>
</li>
</ol>
<p><img src="/2021/WOL-远程唤醒-ARP绑定/dkzf.png" alt="dkzf"></p>
<ol start="4">
<li>路由器设置IP和mac地址绑定，<strong>内网wol可以不设置地址绑定, 外网wol必须设置地址绑定</strong>，如下：</li>
</ol>
<p><img src="/2021/WOL-远程唤醒-ARP绑定/bd.png" alt="bd"></p>
<p>数据流转：<br>   外网WOL：唤醒端在外网9000号端口发起请求-&gt;路由器端口映射-&gt;192.168.50.100:9 -&gt;查询绑定的mac地址的机器，然后启动。<strong>和frp远程访问不同（frpc配置广播地址，不需要设置端口转发）</strong></p>
<p>   内网WOL：使用广播地址192.168.50.255 和mac地址进行广播，找到mac地址相同的进行启动。frp原理和此相同。</p>
<p>遇到问题是，不能每次都唤醒，所以需要ARP绑定。</p>
<h2 id="何为-ARP-绑定"><a href="#何为-ARP-绑定" class="headerlink" title="何为 ARP 绑定"></a>何为 ARP 绑定</h2><p>华硕路由器居然连 ARP 绑定功能都没有。这里要区别一下，在客户端列表中开启 <code>MAC地址与IP绑定</code> 其实仅仅是 DHCP 绑定，它可以保证每次给相同设备总是分配同一个 IP 地址，但<strong>前提是设备必须请求IP！</strong></p>
<p>我们知道路由器内部会维护一个 ARP 表，记录 IP 与 MAC 的关系，每当设备请求 IP 时便会被记录，其超时时间因具体设置而不同。因此当设备长时间不在线（比如关机）时吗，ARP 记录就会失效，从而无法再通过 IP 给此设备发送数据。</p>
<p>有一个典型需求：PC需要 WOL 网络唤醒。因此我们要进行 <strong>ARP 绑定</strong>，与 DHCP 绑定不同，ARP 绑定相当于把 IP 对应关系写死在表里，无论设备是否在线。</p>
<h2 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h2><p>ssh 或 telnet 登录路由器，执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">arp -s [IP] [MAC]</span><br></pre></td></tr></table></figure>
<p>就搞定了。</p>
<p>但是这样每次重启都会失效，我们需要通过自启脚本来手动添加 ARP 项，因此官方固件是不行的，先刷梅林，使用putty连接到路由器。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /jffs/scripts/ <span class="comment"># 进入脚本目录</span></span><br><span class="line">vi services-start <span class="comment"># 打开编辑器（你也可以用其他编辑器）</span></span><br></pre></td></tr></table></figure>
<p>将文件内容改为：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="meta">#!/bin/sh</span></span><br><span class="line">arp -s [IP] [MAC]</span><br><span class="line"><span class="built_in">exit</span> 0</span><br></pre></td></tr></table></figure>
<p>保存，最后给予执行权限：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">chmod a+rx /jffs/scripts/*</span><br></pre></td></tr></table></figure>
<h2 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h2><p>验证ARP绑定无误也非常简单，上面步骤做完以后，重启一下路由器，putty连接路由器，直接输入<code>arp</code> 查看 ARP 表，对应项目如果标识有 <code>[PERM]</code> 就是已经绑定了。</p>
<p><img src="/2021/WOL-远程唤醒-ARP绑定/Snipaste_2021-04-06_12-57-38.png" alt="Snipaste_2021-04-06_12-57-38"></p>
<p>应该可以通过域名从互联网开机了。</p>
<h2 id="唤醒端配置"><a href="#唤醒端配置" class="headerlink" title="唤醒端配置"></a>唤醒端配置</h2><p>手机下载WOL软件，PC和NAS唤醒配置如下：</p>
<p> <img src="/2021/WOL-远程唤醒-ARP绑定/Snipaste_2021-04-06_11-37-08.png" alt="Snipaste_2021-04-06_11-37-08"><br> <img src="/2021/WOL-远程唤醒-ARP绑定/Snipaste_2021-04-06_11-36-52.png" alt="Snipaste_2021-04-06_11-36-52"></p>
]]></content>
      <categories>
        <category>network</category>
        <category>WOL</category>
      </categories>
      <tags>
        <tag>WOL</tag>
        <tag>ARP</tag>
        <tag>端口转发</tag>
      </tags>
  </entry>
  <entry>
    <title>OSI七层模型与TCP IP五层模型</title>
    <url>/2021/OSI%E4%B8%83%E5%B1%82%E6%A8%A1%E5%9E%8B%E4%B8%8ETCP-IP%E4%BA%94%E5%B1%82%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="一、OSI参考模型"><a href="#一、OSI参考模型" class="headerlink" title="一、OSI参考模型"></a>一、OSI参考模型</h2><p>​    今天我们先学习一下以太网最基本也是重要的知识——OSI参考模型。</p>
<p> 1、OSI的来源</p>
<p>​    OSI（Open System Interconnect），即开放式系统互联。 一般都叫OSI参考模型，是ISO（国际标准化组织）组织在1985年研究的网络互连模型。</p>
<p>​    ISO为了更好的使网络应用更为普及，推出了OSI参考模型。其含义就是推荐所有公司使用这个规范来控制网络。这样所有公司都有相同的规范，就能互联了。</p>
<p> 2、OSI七层模型的划分</p>
<p>​    OSI定义了网络互连的七层框架（物理层、数据链路层、网络层、传输层、会话层、表示层、应用层），即ISO开放互连系统参考模型。如下图。</p>
<p>​    每一层实现各自的功能和协议，并完成与相邻层的接口通信。OSI的服务定义详细说明了各层所提供的服务。某一层的服务就是该层及其下各层的一种能力，它通过接口提供给更高一层。各层所提供的服务与这些服务是怎么实现的无关。</p>
<p>  <img src="/2021/OSI七层模型与TCP-IP五层模型/705728-20160424234824085-667046040.png" alt="img"></p>
<p> 3、各层功能定义</p>
<p>​    这里我们只对OSI各层进行功能上的大概阐述，不详细深究，因为每一层实际都是一个复杂的层。后面我也会根据个人方向展开部分层的深入学习。这里我们就大概了解一下。我们从最顶层——应用层 开始介绍。整个过程以公司A和公司B的一次商业报价单发送为例子进行讲解。</p>
<p><1>  应用层</1></p>
<p>​    OSI参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：HTTP，HTTPS，FTP，POP3、SMTP等。</p>
<p>​    实际公司A的老板就是我们所述的用户，而他要发送的商业报价单，就是应用层提供的一种网络服务，当然，老板也可以选择其他服务，比如说，发一份商业合同，发一份询价单，等等。</p>
<p><2>  表示层</2></p>
<p>​    表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>
<p>​    由于公司A和公司B是不同国家的公司，他们之间的商定统一用英语作为交流的语言，所以此时表示层（公司的文秘），就是将应用层的传递信息转翻译成英语。同时为了防止别的公司看到，公司A的人也会对这份报价单做一些加密的处理。这就是表示的作用，将应用层的数据转换翻译等。</p>
<p><3>  会话层</3></p>
<p>​    会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。   </p>
<p>​    会话层的同事拿到表示层的同事转换后资料，（会话层的同事类似公司的外联部），会话层的同事那里可能会掌握本公司与其他好多公司的联系方式，这里公司就是实际传递过程中的实体。他们要管理本公司与外界好多公司的联系会话。当接收到表示层的数据后，会话层将会建立并记录本次会话，他首先要找到公司B的地址信息，然后将整份资料放进信封，并写上地址和联系方式。准备将资料寄出。等到确定公司B接收到此份报价单后，此次会话就算结束了，外联部的同事就会终止此次会话。</p>
<p><4>  传输层</4></p>
<p>​    传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，TCP UDP就是在这一层。端口号既是这里的“端”。</p>
<p>​    传输层就相当于公司中的负责快递邮件收发的人，公司自己的投递员，他们负责将上一层的要寄出的资料投递到快递公司或邮局。</p>
<p><5>  网络层</5></p>
<p>​    本层通过IP寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的IP层。这一层就是我们经常说的IP协议层。IP协议是Internet的基础。</p>
<p>​    网络层就相当于快递公司庞大的快递网络，全国不同的集散中心，比如说，从深圳发往北京的顺丰快递（陆运为例啊，空运好像直接就飞到北京了），首先要到顺丰的深圳集散中心，从深圳集散中心再送到武汉集散中心，从武汉集散中心再寄到北京顺义集散中心。这个每个集散中心，就相当于网络中的一个IP节点。</p>
<p><6>  数据链路层 </6></p>
<p>​    将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</p>
<p>   数据链路层又分为2个子层：逻辑链路控制子层（LLC）和媒体访问控制子层（MAC）。</p>
<p>​    MAC子层处理CSMA/CD算法、数据出错校验、成帧等；LLC子层定义了一些字段使上次协议能共享数据链路层。 在实际使用中，LLC子层并非必需的。</p>
<p>​    这个没找到合适的例子</p>
<p><7> 物理层   </7></p>
<p>​    实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>
<p>​     快递寄送过程中的交通工具，就相当于我们的物理层，例如汽车，火车，飞机，船。</p>
<p>4、通信特点：对等通信   </p>
<p>对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。</p>
<p><img src="/2021/OSI七层模型与TCP-IP五层模型/705728-20160424234824866-481636745.png" alt="img"></p>
<h2 id="二、TCP-IP五层模型"><a href="#二、TCP-IP五层模型" class="headerlink" title="二、TCP/IP五层模型"></a>二、TCP/IP五层模型</h2><p>  TCP/IP五层协议和OSI的七层协议对应关系如下。</p>
<p><img src="/2021/OSI七层模型与TCP-IP五层模型/705728-20160424234825491-384470376.png" alt="img"></p>
<p>  在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。</p>
<p><img src="/2021/OSI七层模型与TCP-IP五层模型/705728-20160424234826351-1957282396.png" alt="img"></p>
<p>在每一层实现的协议也各不同，即每一层的服务也不同.下图列出了每层主要的协议。其中每层中具体的协议，我会在后面的逐一学习。</p>
<p><img src="/2021/OSI七层模型与TCP-IP五层模型/705728-20160424234827195-1493107425.png" alt="img"></p>
<p>参考文献：</p>
<p>  1.百度百科：OSI参考模型</p>
<p>  2.<a href="http://blog.csdn.net/wdkirchhoff/article/details/43915825" target="_blank" rel="noopener">http://blog.csdn.net/wdkirchhoff/article/details/43915825</a></p>
]]></content>
      <categories>
        <category>network</category>
        <category>理论</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>理论</tag>
      </tags>
  </entry>
  <entry>
    <title>WOL-远程唤醒-FRP</title>
    <url>/2021/WOL-%E8%BF%9C%E7%A8%8B%E5%94%A4%E9%86%92-FRP/</url>
    <content><![CDATA[<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>VPS（具有公网IP），配置了fprs服务。</li>
<li>路由器可安装frpc插件,我是用的华硕ac86u</li>
<li>申请了域名 ，例如aaa.com，并配置DDNS域名解析：  <strong>aaa.com-&gt; vps IP</strong></li>
</ol>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>路由器没有公网IP，需要vps转发数据。唤醒端在外网通过域名请求vps 9号端口，vps将开机命令包通过udp协议转发给路由器所在局域网的 192.168.50.255（广播地址，此广播地址根据192.169.50.1路由器IP算出来的掩码），遍历mac地址相同的机器，发送到该机器的9号端口，进行开机。</p>
<h2 id="Windows系统唤醒"><a href="#Windows系统唤醒" class="headerlink" title="Windows系统唤醒"></a>Windows系统唤醒</h2><h3 id="被唤醒端配置"><a href="#被唤醒端配置" class="headerlink" title="被唤醒端配置"></a>被唤醒端配置</h3><ol>
<li><p>设置技嘉主板BIOS的Erp选项为disable，启动远程开机的功能。其他主板配置不同，参阅百度或者说明手册。</p>
</li>
<li><p>设置windows系统支持远程开机启动<br>设置网卡，选择当前使用的网卡，右键网卡属性，在“网络”tab页点击配置。</p>
<p><img src="/2021/WOL-远程唤醒-FRP/image-20210406091402158.png" alt="image-20210406091402158" style="zoom: 67%;"></p>
<p>在 <strong>高级</strong> 菜单中的属性找到 <strong>唤醒魔包</strong> (Wake on Magic Packet) 设置为 <strong>启用</strong></p>
</li>
</ol>
<p>   <img src="/2021/WOL-远程唤醒-FRP/clip_image002.jpg" alt="IMG_258" style="zoom:50%;"></p>
<p>   在 <strong>电源管理</strong> 中 勾选 <strong>允许此设备唤醒计算机</strong></p>
<p>   <img src="/2021/WOL-远程唤醒-FRP/clip_image004.jpg" alt="IMG_259" style="zoom:50%;"></p>
<h3 id="路由器配置"><a href="#路由器配置" class="headerlink" title="路由器配置"></a>路由器配置</h3><ol>
<li>用vps进行开机udp命令包转发，需要在路由器中安装frpc插件，设置frpc内网穿透配置；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[wol]</span><br><span class="line">type = udp  #类型为UDP</span><br><span class="line">local_ip = 192.168.50.255  #此处填写广播地址，不需要再路由器中设置端口转发</span><br><span class="line">local_port = 9 #一般采用这个端口进行wol</span><br><span class="line">remote_port = 9</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>将mac地址和IP地址进行绑定</li>
</ol>
<p><img src="/2021/WOL-远程唤醒-FRP/clip_image002b.jpg" alt="IMG_260"></p>
<h3 id="唤醒端配置"><a href="#唤醒端配置" class="headerlink" title="唤醒端配置"></a>唤醒端配置</h3><p><strong>远程唤醒</strong>Android端下载WOL软件，可以通过手机唤醒</p>
<p><img src="/2021/WOL-远程唤醒-FRP/Snipaste_2021-04-06_09-42-52.png" alt="Snipaste_2021-04-06_09-42-52"></p>
<p><strong>局域网唤醒</strong></p>
<p><img src="/2021/WOL-远程唤醒-FRP/Snipaste_2021-04-06_09-45-52.png" alt="Snipaste_2021-04-06_09-45-52"></p>
<h2 id="NAS系统唤醒"><a href="#NAS系统唤醒" class="headerlink" title="NAS系统唤醒"></a>NAS系统唤醒</h2><h3 id="被唤醒端配置-1"><a href="#被唤醒端配置-1" class="headerlink" title="被唤醒端配置"></a>被唤醒端配置</h3><ol>
<li><p>改为设置主板华擎J4105的BIOS和NAS系统，NAS开机进入BIOS后，</p>
<p>选择Advanced -&gt; Chipset Configuration</p>
<p>Onboard LAN 设置为enable，启动网卡<br>Enable or disable the onboard network interface controller.</p>
<p>PCIE1 Link Speed<br>Select the link speed for PCIE1.</p>
<p>Deep S5 (设置系统的休眠级别，可能有关系，改小试试)<br>Configure deep sleep mode for power saving when the computer is shut down.</p>
<p>选择Advanced -&gt; ACPI Configuration</p>
<p>PCIE Device Power On 设置为 enable<br>Allow the system to be waked up by a PCIE device and enable wake on LAN.</p>
<p><strong>Boot From Onboard LAN设置为enable</strong><br><strong>Allow the system to be waked up by the onboard LAN.</strong></p>
</li>
<li><p>NAS系统暂未发现设置项，可能不需要设置</p>
</li>
</ol>
<h3 id="路由器端配置"><a href="#路由器端配置" class="headerlink" title="路由器端配置"></a>路由器端配置</h3><ol>
<li>用vps进行开机udp命令包转发，需要在路由器中安装frpc插件，设置frpc内网穿透配置；</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[wol]</span><br><span class="line">type = udp  #类型为UDP</span><br><span class="line">local_ip = 192.168.50.255  #此处填写广播地址，不需要再路由器中设置端口转发</span><br><span class="line">local_port = 9 #一般采用这个端口进行wol</span><br><span class="line">remote_port = 9</span><br></pre></td></tr></table></figure>
<ol start="2">
<li><p>将NAS的mac地址和IP地址进行绑定<br><img src="/2021/WOL-远程唤醒-FRP/Snipaste_2021-04-06_10-05-49.png" alt="Snipaste_2021-04-06_10-05-49"></p>
<h3 id="唤醒端配置-1"><a href="#唤醒端配置-1" class="headerlink" title="唤醒端配置"></a>唤醒端配置</h3></li>
</ol>
<p><strong>远程唤醒</strong></p>
<p><img src="/2021/WOL-远程唤醒-FRP/Snipaste_2021-04-06_10-07-15.png" alt="Snipaste_2021-04-06_10-07-15"></p>
<p><strong>局域网唤醒</strong></p>
<p><img src="/2021/WOL-远程唤醒-FRP/Snipaste_2021-04-06_10-07-37.png" alt="Snipaste_2021-04-06_10-07-37"></p>
]]></content>
      <categories>
        <category>network</category>
        <category>WOL</category>
      </categories>
      <tags>
        <tag>内网穿透</tag>
        <tag>frp</tag>
        <tag>WOL</tag>
      </tags>
  </entry>
  <entry>
    <title>authorized_keys不生效解决办法</title>
    <url>/2021/authorized-keys%E4%B8%8D%E7%94%9F%E6%95%88%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/</url>
    <content><![CDATA[<p>​        在Linux中部署git服务器时，window客户端 执行ssh-keygen在目录<code>C:\Users\zhangyf \.ssh</code> 生成 id_rsa和id_rsa.pub。</p>
<p>将id_rsa.pub内容上传到Linux的/home/git/.ssh/authorized_keys 时， <code>service sshd restart</code> 命令重启了SSH服务， </p>
<p>在windows 打开cmd执行ssh git@VPSIP  -p 28094 需要输入密码。</p>
<p>解决方案：</p>
<p>linux 目录结构为 /home/git/.ssh/authorized_keys  用户和组都为git</p>
<p>/home/git目录必须是 755权限 即drwxr-xr-x  </p>
<p>/home/git/.ssh目录必须是700权限(也就是drwx——)</p>
<p>/home/git/.ssh/authorized_keys 文件必须是600权限(也就是-rw——-)或者644</p>
<p>缺一不可</p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo本地图片不显示</title>
    <url>/2020/hexo%E6%9C%AC%E5%9C%B0%E5%9B%BE%E7%89%87%E4%B8%8D%E6%98%BE%E7%A4%BA/</url>
    <content><![CDATA[<h3 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h3><ul>
<li><p>修改文件<code>_config.yml</code> 里的<code>post_asset_folder:</code>这个选项设置为<code>true</code></p>
</li>
<li><p>修改之后，再使用<code>hexo new post &quot;hexo本地图片不显示&quot;</code>时，目录的样子是</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hexo本地图片不显示</span><br><span class="line">├── 01.jpg</span><br><span class="line">├── 02.jpg</span><br><span class="line">└── 03.jpg</span><br><span class="line">...</span><br><span class="line">hexo本地图片不显示.md</span><br></pre></td></tr></table></figure>
<h3 id="安装插件hexo-asset-image"><a href="#安装插件hexo-asset-image" class="headerlink" title="安装插件hexo-asset-image"></a>安装插件hexo-asset-image</h3><ul>
<li>GitHub地址 <a href="https://github.com/xcodebuild/hexo-asset-image" target="_blank" rel="noopener">hexo-asset-image</a></li>
<li>npm安装 (需要提前安装Node.js)</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install https://github.com/CodeFalling/hexo-asset-image --save</span><br></pre></td></tr></table></figure>
<p><img src="/2020/hexo本地图片不显示/1.png" alt="图片描述"><br><strong>注意</strong> 不要使用<code>npm install hexo-asset-image --save</code>这个命令安装,<strong>版本号不对</strong><br><img src="/2020/hexo本地图片不显示/2.png" alt="图片描述"></p>
<h3 id="版本差异"><a href="#版本差异" class="headerlink" title="版本差异"></a>版本差异</h3><h4 id="0-0-5版本"><a href="#0-0-5版本" class="headerlink" title="0.0.5版本"></a>0.0.5版本</h4><p><img src="/2020/hexo本地图片不显示/3.png" alt="图片描述"></p>
<h4 id="1-0-0版本"><a href="#1-0-0版本" class="headerlink" title="1.0.0版本"></a>1.0.0版本</h4><p><img src="/2020/hexo本地图片不显示/4.png" alt="图片描述"></p>
<h3 id="在md中书写格式（相对路径）"><a href="#在md中书写格式（相对路径）" class="headerlink" title="在md中书写格式（相对路径）"></a>在md中书写格式（相对路径）</h3><p>在md使用如下形式引用图片</p>
<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">![<span class="string">01</span>](<span class="link">hexo本地图片不显示/01.jpg</span>)</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong> 这里要使用<code>&quot;/&quot;</code></p>
<h3 id="md文件名称和图片存放文件夹名称不同时"><a href="#md文件名称和图片存放文件夹名称不同时" class="headerlink" title="md文件名称和图片存放文件夹名称不同时"></a>md文件名称和图片存放文件夹名称不同时</h3><p><strong>注意</strong> <code>重命名md文件之后记得重命名文件夹，当md文件的名称与文件夹名称不同时，映射关系以md文件名称为主。会导致src图片路径找不到</code></p>
<p><img src="/2020/hexo本地图片不显示/5.png" alt="图片描述"></p>
<ul>
<li><code>文件和文件夹以url中的名称保持一致</code></li>
</ul>
<p><strong>总结</strong></p>
<ul>
<li>检查<code>_config.yml</code> 文件的<code>post_asset_folder:</code>选项是否为<code>true</code></li>
<li>检查创建文件之后的目录结构</li>
<li>检查<code>hexo-asset-image</code>插件的版本</li>
<li>检查路径引用图片的路径使用<code>/</code></li>
<li>检查md文件的文件名称和图片存放文件夹名称是否相同</li>
</ul>
<p>转载于：<a href="https://blog.csdn.net/Strong997/article/details/97767929" target="_blank" rel="noopener">https://blog.csdn.net/Strong997/article/details/97767929</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>java泛型</title>
    <url>/2021/java%E6%B3%9B%E5%9E%8B/</url>
    <content><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>泛型在java中有很重要的地位，在面向对象编程及各种设计模式中有非常广泛的应用。</p>
<p>什么是泛型？为什么要使用泛型？</p>
<blockquote>
<p><strong>泛型，即“参数化类型”。一提到参数，最熟悉的就是定义方法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具体的类型参数化，类似于方法中的变量参数，此时类型也定义成参数形式（可以称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</strong></p>
<p><strong>泛型的本质是为了参数化类型（在不创建新的类型的情况下，通过泛型指定的不同类型来控制形参具体限制的类型）</strong>。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，这种参数类型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p>
</blockquote>
<h1 id="一个栗子"><a href="#一个栗子" class="headerlink" title="一个栗子"></a>一个栗子</h1><p>一个被举了无数次的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List arrayList = <span class="keyword">new</span> ArrayList();</span><br><span class="line">arrayList.add(<span class="string">"aaaa"</span>);</span><br><span class="line">arrayList.add(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; arrayList.size();i++)&#123;</span><br><span class="line">    String item = (String)arrayList.get(i);</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"item = "</span> + item);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>毫无疑问，程序的运行结果会以崩溃结束：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String1</span><br></pre></td></tr></table></figure>
<p>ArrayList可以存放任意类型，例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，因此程序崩溃了。为了解决类似这样的问题（在编译阶段就可以解决），泛型应运而生。</p>
<p>我们将第一行声明初始化list的代码更改一下，编译器会在编译阶段就能够帮我们发现类似这样的问题。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; arrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">...</span><br><span class="line"><span class="comment">//arrayList.add(100); 在编译阶段，编译器就会报错123</span></span><br></pre></td></tr></table></figure>
<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><p>泛型只在编译阶段有效。看下面的代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">List&lt;String&gt; stringArrayList = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">List&lt;Integer&gt; integerArrayList = <span class="keyword">new</span> ArrayList&lt;Integer&gt;();</span><br><span class="line"></span><br><span class="line">Class classStringArrayList = stringArrayList.getClass();</span><br><span class="line">Class classIntegerArrayList = integerArrayList.getClass();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(classStringArrayList.equals(classIntegerArrayList))&#123;</span><br><span class="line">    Log.d(<span class="string">"泛型测试"</span>,<span class="string">"类型相同"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果：<code>D/泛型测试: 类型相同</code>。</p>
<p>通过上面的例子可以证明，在编译之后程序会采取去泛型化的措施。也就是说Java中的泛型，只在编译阶段有效。在编译过程中，正确检验泛型结果后，会将泛型的相关信息擦出，并且在对象进入和离开方法的边界处添加类型检查和类型转换的方法。也就是说，泛型信息不会进入到运行时阶段。</p>
<p><strong>对此总结成一句话：泛型类型在逻辑上看以看成是多个不同的类型，实际上都是相同的基本类型。</strong></p>
<h1 id="泛型的使用"><a href="#泛型的使用" class="headerlink" title="泛型的使用"></a>泛型的使用</h1><p>泛型有三种使用方式，分别为：泛型类、泛型接口、泛型方法</p>
<h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><p>泛型类型用于类的定义中，被称为泛型类。通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p>
<p>泛型类的最基本写法（这么看可能会有点晕，会在下面的例子中详解）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名称 &lt;泛型标识：可以随便写任意标识号，标识指定的泛型的类型&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">private</span> 泛型标识 <span class="comment">/*（成员变量类型）*/</span> <span class="keyword">var</span>; </span><br><span class="line">  .....</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个最普通的泛型类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型</span></span><br><span class="line"><span class="comment">//在实例化泛型类时，必须指定T的具体类型</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123; </span><br><span class="line">    <span class="comment">//key这个成员变量的类型为T,T的类型由外部指定  </span></span><br><span class="line">    <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123; <span class="comment">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123; <span class="comment">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span></span><br><span class="line">        <span class="keyword">return</span> key;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//泛型的类型参数只能是类类型（包括自定义类），不能是简单类型</span></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为Integer.</span></span><br><span class="line">Generic&lt;Integer&gt; genericInteger = <span class="keyword">new</span> Generic&lt;Integer&gt;(<span class="number">123456</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//传入的实参类型需与泛型的类型参数类型相同，即为String.</span></span><br><span class="line">Generic&lt;String&gt; genericString = <span class="keyword">new</span> Generic&lt;String&gt;(<span class="string">"key_vlaue"</span>);</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + genericInteger.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + genericString.getKey());<span class="number">12345678</span></span><br><span class="line"><span class="number">12</span>-<span class="number">27</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">04.432</span> <span class="number">13063</span>-<span class="number">13063</span>/? D/泛型测试: key is <span class="number">123456</span></span><br><span class="line"><span class="number">12</span>-<span class="number">27</span> <span class="number">09</span>:<span class="number">20</span>:<span class="number">04.432</span> <span class="number">13063</span>-<span class="number">13063</span>/? D/泛型测试: key is key_vlaue12</span><br></pre></td></tr></table></figure>
<p>定义的泛型类，就一定要传入泛型类型实参么？并不是这样，在使用泛型的时候如果传入泛型实参，则会根据传入的泛型实参做相应的限制，此时泛型才会起到本应起到的限制作用。如果不传入泛型类型实参的话，在泛型类中使用泛型的方法或成员变量定义的类型可以为任何的类型。</p>
<p>看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Generic generic = <span class="keyword">new</span> Generic(<span class="string">"111111"</span>);</span><br><span class="line">Generic generic1 = <span class="keyword">new</span> Generic(<span class="number">4444</span>);</span><br><span class="line">Generic generic2 = <span class="keyword">new</span> Generic(<span class="number">55.55</span>);</span><br><span class="line">Generic generic3 = <span class="keyword">new</span> Generic(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic1.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic2.getKey());</span><br><span class="line">Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key is "</span> + generic3.getKey());</span><br><span class="line">D/泛型测试: key is <span class="number">111111</span></span><br><span class="line">D/泛型测试: key is <span class="number">4444</span></span><br><span class="line">D/泛型测试: key is <span class="number">55.55</span></span><br><span class="line">D/泛型测试: key is false1234</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：</p>
<ul>
<li><ol>
<li>泛型的类型参数只能是类类型，不能是简单类型。</li>
</ol>
</li>
<li><ol>
<li><p>不能对确切的泛型类型使用instanceof操作。如下面的操作是非法的，编译时会出错。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&gt;      <span class="keyword">if</span>(ex_num <span class="keyword">instanceof</span> Generic&lt;Number&gt;)&#123;   </span><br><span class="line">&gt;      &#125; <span class="number">12</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
</blockquote>
<h2 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h2><p>泛型接口与泛型类的定义及使用基本相同。泛型接口常被用在各种类的生产器中，可以看一个例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个泛型接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当实现泛型接口的类，未传入泛型实参时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中</span></span><br><span class="line"><span class="comment"> * 即：class FruitGenerator&lt;T&gt; implements Generator&lt;T&gt;&#123;</span></span><br><span class="line"><span class="comment"> * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T&gt;，编译器会报错："Unknown class"</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当实现泛型接口的类，传入泛型实参时：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 传入泛型实参时：</span></span><br><span class="line"><span class="comment"> * 定义一个生产器实现这个接口,虽然我们只创建了一个泛型接口Generator&lt;T&gt;</span></span><br><span class="line"><span class="comment"> * 但是我们可以为T传入无数个实参，形成无数种类型的Generator接口。</span></span><br><span class="line"><span class="comment"> * 在实现类实现泛型接口时，如已将泛型类型传入实参类型，则所有使用泛型的地方都要替换成传入的实参类型</span></span><br><span class="line"><span class="comment"> * 即：Generator&lt;T&gt;，public T next();中的的T都要替换成传入的String类型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FruitGenerator</span> <span class="keyword">implements</span> <span class="title">Generator</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] fruits = <span class="keyword">new</span> String[]&#123;<span class="string">"Apple"</span>, <span class="string">"Banana"</span>, <span class="string">"Pear"</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">return</span> fruits[rand.nextInt(<span class="number">3</span>)];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><p>在java中,泛型类的定义非常简单，但是泛型方法就比较复杂了。</p>
<blockquote>
<p>尤其是我们见到的大多数泛型类中的成员方法也都使用了泛型，有的甚至泛型类中也包含着泛型方法，这样在初学者中非常容易将泛型方法理解错了。</p>
</blockquote>
<p><strong>泛型类，是在实例化类的时候指明泛型的具体类型；泛型方法，是在调用方法的时候指明泛型的具体类型</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 泛型方法的基本介绍</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> tClass 传入的泛型实参</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> T 返回值为T类型</span></span><br><span class="line"><span class="comment"> * 说明：</span></span><br><span class="line"><span class="comment"> *     1）public 与 返回值中间&lt;T&gt;非常重要，可以理解为声明此方法为泛型方法。</span></span><br><span class="line"><span class="comment"> *     2）只有声明了&lt;T&gt;的方法才是泛型方法，泛型类中的使用了泛型的成员方法并不是泛型方法。</span></span><br><span class="line"><span class="comment"> *     3）&lt;T&gt;表明该方法将使用泛型类型T，此时才可以在方法中使用泛型类型T。</span></span><br><span class="line"><span class="comment"> *     4）与泛型类的定义一样，此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">genericMethod</span><span class="params">(Class&lt;T&gt; tClass)</span><span class="keyword">throws</span> InstantiationException ,</span></span><br><span class="line"><span class="function">  IllegalAccessException</span>&#123;</span><br><span class="line">        T instance = tClass.newInstance();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line">Object obj = genericMethod(Class.forName(<span class="string">"com.test.test"</span>));<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="泛型方法的基本用法"><a href="#泛型方法的基本用法" class="headerlink" title="泛型方法的基本用法"></a>泛型方法的基本用法</h3><p>光看上面的例子有的同学可能依然会非常迷糊，我们再通过一个例子，把我泛型方法再总结一下。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericTest</span> </span>&#123;</span><br><span class="line">   <span class="comment">//这个类是个泛型类，在上面已经介绍过</span></span><br><span class="line">   <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Generic</span>&lt;<span class="title">T</span>&gt;</span>&#123;     </span><br><span class="line">        <span class="keyword">private</span> T key;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Generic</span><span class="params">(T key)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我想说的其实是这个，虽然在方法中使用了泛型，但是这并不是一个泛型方法。</span></span><br><span class="line">        <span class="comment">//这只是类中一个普通的成员方法，只不过他的返回值是在声明泛型类已经声明过的泛型。</span></span><br><span class="line">        <span class="comment">//所以在这个方法中才可以继续使用 T 这个泛型。</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">getKey</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> key;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 这个方法显然是有问题的，在编译器会给我们提示这样的错误信息"cannot reslove symbol E"</span></span><br><span class="line"><span class="comment">         * 因为在类的声明中并未声明泛型E，所以在使用E做形参和返回值类型时，编译器会无法识别。</span></span><br><span class="line"><span class="comment">        public E setKey(E key)&#123;</span></span><br><span class="line"><span class="comment">             this.key = keu</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** </span></span><br><span class="line"><span class="comment">     * 这才是一个真正的泛型方法。</span></span><br><span class="line"><span class="comment">     * 首先在public与返回值之间的&lt;T&gt;必不可少，这表明这是一个泛型方法，并且声明了一个泛型T</span></span><br><span class="line"><span class="comment">     * 这个T可以出现在这个泛型方法的任意位置.</span></span><br><span class="line"><span class="comment">     * 泛型的数量也可以为任意多个 </span></span><br><span class="line"><span class="comment">     *    如：public &lt;T,K&gt; K showKeyName(Generic&lt;T&gt; container)&#123;</span></span><br><span class="line"><span class="comment">     *        ...</span></span><br><span class="line"><span class="comment">     *        &#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">showKeyName</span><span class="params">(Generic&lt;T&gt; container)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"container key :"</span> + container.getKey());</span><br><span class="line">        <span class="comment">//当然这个例子举的不太合适，只是为了说明泛型方法的特性。</span></span><br><span class="line">        T test = container.getKey();</span><br><span class="line">        <span class="keyword">return</span> test;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这就是一个普通的方法，只是使用了Generic&lt;Number&gt;这个泛型类做形参而已。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue1</span><span class="params">(Generic&lt;Number&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//这也不是一个泛型方法，这也是一个普通的方法，只不过使用了泛型通配符?</span></span><br><span class="line">    <span class="comment">//同时这也印证了泛型通配符章节所描述的，?是一种类型实参，可以看做为Number等所有类的父类</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showKeyValue2</span><span class="params">(Generic&lt;?&gt; obj)</span></span>&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"key value is "</span> + obj.getKey());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法是有问题的，编译器会为我们提示错误信息："UnKnown class 'E' "</span></span><br><span class="line"><span class="comment">     * 虽然我们声明了&lt;T&gt;,也表明了这是一个可以处理泛型的类型的泛型方法。</span></span><br><span class="line"><span class="comment">     * 但是只声明了泛型类型T，并未声明泛型类型E，因此编译器并不知道该如何处理E这个类型。</span></span><br><span class="line"><span class="comment">    public &lt;T&gt; T showKeyName(Generic&lt;E&gt; container)&#123;</span></span><br><span class="line"><span class="comment">        ...</span></span><br><span class="line"><span class="comment">    &#125;  </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 这个方法也是有问题的，编译器会为我们提示错误信息："UnKnown class 'T' "</span></span><br><span class="line"><span class="comment">     * 对于编译器来说T这个类型并未项目中声明过，因此编译也不知道该如何编译这个类。</span></span><br><span class="line"><span class="comment">     * 所以这也不是一个正确的泛型方法声明。</span></span><br><span class="line"><span class="comment">    public void showkey(T genericObj)&#123;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="类中的泛型方法"><a href="#类中的泛型方法" class="headerlink" title="类中的泛型方法"></a>类中的泛型方法</h3><p>当然这并不是泛型方法的全部，泛型方法可以出现杂任何地方和任何场景中使用。但是有一种情况是非常特殊的，当泛型方法出现在泛型类中时，我们再通过一个例子看一下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericFruit</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"fruit"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Apple</span> <span class="keyword">extends</span> <span class="title">Fruit</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"apple"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Person"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">GenerateTest</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show_1</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型E，这种泛型E可以为任意类型。可以类型与T相同，也可以不同。</span></span><br><span class="line">        <span class="comment">//由于泛型方法在声明的时候会声明泛型&lt;E&gt;，因此即使在泛型类中并未声明泛型，编译器也能够正确识别泛型方法中识别的泛型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;E&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_3</span><span class="params">(E t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//在泛型类中声明了一个泛型方法，使用泛型T，注意这个T是一种全新的类型，可以与泛型类中声明的T不是同一种类型。</span></span><br><span class="line">        <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show_2</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">            System.out.println(t.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Apple apple = <span class="keyword">new</span> Apple();</span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line">        GenerateTest&lt;Fruit&gt; generateTest = <span class="keyword">new</span> GenerateTest&lt;Fruit&gt;();</span><br><span class="line">        <span class="comment">//apple是Fruit的子类，所以这里可以</span></span><br><span class="line">        generateTest.show_1(apple);</span><br><span class="line">        <span class="comment">//编译器会报错，因为泛型类型实参指定的是Fruit，而传入的实参类是Person</span></span><br><span class="line">        <span class="comment">//generateTest.show_1(person);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法都可以成功</span></span><br><span class="line">        generateTest.show_2(apple);</span><br><span class="line">        generateTest.show_2(person);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//使用这两个方法也都可以成功</span></span><br><span class="line">        generateTest.show_3(apple);</span><br><span class="line">        generateTest.show_3(person);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法与可变参数"><a href="#泛型方法与可变参数" class="headerlink" title="泛型方法与可变参数"></a>泛型方法与可变参数</h3><p>再看一个泛型方法和可变参数的例子：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">printMsg</span><span class="params">( T... args)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(T t : args)&#123;</span><br><span class="line">        Log.d(<span class="string">"泛型测试"</span>,<span class="string">"t is "</span> + t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">printMsg(<span class="string">"111"</span>,<span class="number">222</span>,<span class="string">"aaaa"</span>,<span class="string">"2323.4"</span>,<span class="number">55.55</span>);<span class="number">1</span></span><br></pre></td></tr></table></figure>
<h3 id="静态方法与泛型"><a href="#静态方法与泛型" class="headerlink" title="静态方法与泛型"></a>静态方法与泛型</h3><p>静态方法有一种情况需要注意一下，那就是在类中的静态方法使用泛型：<strong>静态方法无法访问类上定义的泛型；如果静态方法操作的引用数据类型不确定的时候，必须要将泛型定义在方法上。</strong></p>
<p>即：<strong>如果静态方法要使用泛型的话，必须将静态方法也定义成泛型方法</strong> 。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticGenerator</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    ....</span><br><span class="line">    ....</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 如果在类中定义使用泛型的静态方法，需要添加额外的泛型声明（将这个方法定义成泛型方法）</span></span><br><span class="line"><span class="comment">     * 即使静态方法要使用泛型类中已经声明过的泛型也不可以。</span></span><br><span class="line"><span class="comment">     * 如：public static void show(T t)&#123;..&#125;,此时编译器会提示错误信息：</span></span><br><span class="line"><span class="comment">          "StaticGenerator cannot be refrenced from static context"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">show</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="泛型方法总结"><a href="#泛型方法总结" class="headerlink" title="泛型方法总结"></a>泛型方法总结</h3><p>泛型方法能使方法独立于类而产生变化，以下是一个基本的指导原则：</p>
<blockquote>
<p>无论何时，如果你能做到，你就该尽量使用泛型方法。也就是说，如果使用泛型方法将整个类泛型化，那么就应该使用泛型方法。另外对于一个static的方法而已，无法访问泛型类型的参数。所以如果static方法要使用泛型能力，就必须使其成为泛型方法</p>
</blockquote>
<h2 id="泛型中通配符"><a href="#泛型中通配符" class="headerlink" title="泛型中通配符"></a>泛型中通配符</h2><p>我们在定义泛型类，泛型方法，泛型接口的时候经常会碰见很多不同的通配符，比如 T，E，K，V 等等，这些通配符又都是什么意思呢？</p>
<p>本质上这些个都是通配符，没啥区别，只不过是编码时的一种约定俗成的东西。比如上述代码中的 T ，我们可以换成 A-Z 之间的任何一个 字母都可以，并不会影响程序的正常运行，但是如果换成其他的字母代替 T ，在可读性上可能会弱一些。通常情况下，T，E，K，V，？是这样约定的：</p>
<ul>
<li>？表示不确定的 java 类型</li>
<li>T (type) 表示具体的一个java类型</li>
<li>K V (key value) 分别代表java键值中的Key Value</li>
<li>E (element) 代表Element</li>
</ul>
<h3 id="？无界通配符"><a href="#？无界通配符" class="headerlink" title="？无界通配符"></a>？无界通配符</h3><p>先从一个小例子看起，我有一个父类 Animal 和几个子类，如狗、猫等，现在我需要一个动物的列表，我的第一个想法是像这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;Animal&gt; listAnimals</span><br></pre></td></tr></table></figure>
<p>但是老板的想法确实这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">List&lt;? extends Animal&gt; listAnimals</span><br></pre></td></tr></table></figure>
<p>为什么要使用通配符而不是简单的泛型呢？通配符其实在声明局部变量时是没有什么意义的，但是当你为一个方法声明一个参数时，它是非常重要的。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs</span> <span class="params">(List&lt;? extends Animal &gt; animals )</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal += animal.countLegs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">countLegs1</span> <span class="params">(List&lt; Animal &gt; animals )</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> retVal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> ( Animal animal : animals )</span><br><span class="line">    &#123;</span><br><span class="line">        retVal += animal.countLegs();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> retVal;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    List&lt;Dog&gt; dogs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">     <span class="comment">// 不会报错</span></span><br><span class="line">    countLegs( dogs );</span><br><span class="line">    <span class="comment">// 报错</span></span><br><span class="line">    countLegs1(dogs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当调用 countLegs1 时，就会报错。所以，对于不确定或者不关心实际要操作的类型，可以使用无限制通配符（尖括号里一个问号，即 <code>&lt;?&gt;</code>），表示可以持有任何类型。像 countLegs 方法中，限定了上届，但是不关心具体类型是什么，所以对于传入的 Animal 的所有子类都可以支持，并且不会报错。而 countLegs1 就不行。</p>
<h3 id="上界通配符-lt-extends-E-gt"><a href="#上界通配符-lt-extends-E-gt" class="headerlink" title="上界通配符 &lt; ? extends E&gt;"></a>上界通配符 &lt; ? extends E&gt;</h3><blockquote>
<p>上界：用 extends 关键字声明，表示参数化的类型可能是所指定的类型，或者是此类型的子类。</p>
</blockquote>
<p>在类型参数中使用 extends 表示这个泛型中的参数必须是 E 或者 E 的子类，这样有两个好处：</p>
<ul>
<li>如果传入的类型不是 E 或者 E 的子类，编译不成功</li>
<li>泛型中可以使用 E 的方法，要不然还得强转成 E 才能使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private &lt;K extends A, E extends B&gt; E test(K arg1, E arg2)&#123;</span><br><span class="line">    E result = arg2;</span><br><span class="line">    arg2.compareTo(arg1);</span><br><span class="line">    //.....</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类型参数列表中如果有多个类型参数上限，用逗号分开</p>
<h3 id="下界通配符-lt-super-E-gt"><a href="#下界通配符-lt-super-E-gt" class="headerlink" title="下界通配符 &lt; ? super E&gt;"></a>下界通配符 &lt; ? super E&gt;</h3><blockquote>
<p>下界: 用 super 进行声明，表示参数化的类型可能是所指定的类型，或者是此类型的父类型，直至 Object</p>
</blockquote>
<p>在类型参数中使用 super 表示这个泛型中的参数必须是 E 或者 E 的父类。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private &lt;T&gt; void test(List&lt;? super T&gt; dst, List&lt;T&gt; src)&#123;</span><br><span class="line">    for (T t : src) &#123;</span><br><span class="line">        dst.add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">    List&lt;Dog&gt; dogs = new ArrayList&lt;&gt;();</span><br><span class="line">    List&lt;Animal&gt; animals = new ArrayList&lt;&gt;();</span><br><span class="line">    new Test3().test(animals,dogs);</span><br><span class="line">&#125;</span><br><span class="line">// Dog 是 Animal 的子类</span><br><span class="line">class Dog extends Animal &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dst 类型 “大于等于” src 的类型，这里的“大于等于”是指 dst 表示的范围比 src 要大，因此装得下 dst 的容器也就能装 src 。</p>
<h3 id="？和-T-的区别"><a href="#？和-T-的区别" class="headerlink" title="？和 T 的区别"></a>？和 T 的区别</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//指定集合元素只能是T类型</span><br><span class="line">List&lt;T&gt; list =new ArrayList&lt;T&gt;();</span><br><span class="line"></span><br><span class="line">//集合元素可以是任意类型，这种没有意义，一般是方法中，只是为了说明用法</span><br><span class="line">List&lt;?&gt; list =new ArrayList&lt;?&gt;();</span><br></pre></td></tr></table></figure>
<p>？和 T 都表示不确定的类型，区别在于我们可以对 T 进行操作，但是对 ？不行，比如如下这种 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 可以</span><br><span class="line">T t = operate();</span><br><span class="line"></span><br><span class="line">// 不可以</span><br><span class="line">?car = operate();</span><br></pre></td></tr></table></figure>
<p>简单总结下：</p>
<blockquote>
<p>T 是一个 确定的 类型，通常用于泛型类和泛型方法的定义，？是一个 不确定 的类型，通常用于泛型方法的调用代码和形参，不能用于定义类和泛型方法。</p>
</blockquote>
<h4 id="区别1：通过-T-来-确保-泛型参数的一致性"><a href="#区别1：通过-T-来-确保-泛型参数的一致性" class="headerlink" title="区别1：通过 T 来 确保 泛型参数的一致性"></a>区别1：通过 T 来 确保 泛型参数的一致性</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过 T 来 确保 泛型参数的一致性</span><br><span class="line">public &lt;T extends Number&gt; void</span><br><span class="line">test(List&lt;T&gt; dest, List&lt;T&gt; src)</span><br><span class="line"></span><br><span class="line">//通配符是 不确定的，所以这个方法不能保证两个 List 具有相同的元素类型</span><br><span class="line">public void</span><br><span class="line">test(List&lt;? extends Number&gt; dest, List&lt;? extends Number&gt; src)</span><br></pre></td></tr></table></figure>
<p>像下面的代码中，约定的 T 是 Number 的子类才可以，但是申明时是用的 String ，所以就会飘红报错。</p>
<p>不能保证两个 List 具有相同的元素类型的情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GlmapperGeneric&lt;String&gt; glmapperGeneric = new GlmapperGeneric&lt;&gt;();</span><br><span class="line">List&lt;String&gt; dest = new ArrayList&lt;&gt;();</span><br><span class="line">List&lt;Number&gt; src = new ArrayList&lt;&gt;();</span><br><span class="line">glmapperGeneric.testNon(dest,src);</span><br></pre></td></tr></table></figure>
<p>上面的代码在编译器并不会报错，但是当进入到 testNon 方法内部操作时（比如赋值），对于 dest 和 src 而言，就还是需要进行类型转换。</p>
<h4 id="区别2：类型参数可以多重限定而通配符不行"><a href="#区别2：类型参数可以多重限定而通配符不行" class="headerlink" title="区别2：类型参数可以多重限定而通配符不行"></a>区别2：类型参数可以多重限定而通配符不行</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiLimit</span> <span class="keyword">implements</span> <span class="title">MultiLimitInterfaceA</span>,<span class="title">MultiLimitInterfaceB</span></span>&#123;</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">	* 使用 &amp; 符号设定多重边界</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span>&lt;T extends MultiLimitInterfaceA &amp; MultiLimitInterfaceB&gt; <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(T t)</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MultiLimitInterfaceA</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">MulitLimitInterfaceB</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>使用 &amp; 符号设定多重边界（Multi Bounds)，指定泛型类型 T 必须是 MultiLimitInterfaceA 和 MultiLimitInterfaceB 的共有子类型，此时变量 t 就具有了所有限定的方法和属性。对于通配符来说，因为它不是一个确定的类型，所以不能进行多重限定。</p>
<h4 id="区别3：通配符可以使用超类限定而类型参数不行"><a href="#区别3：通配符可以使用超类限定而类型参数不行" class="headerlink" title="区别3：通配符可以使用超类限定而类型参数不行"></a>区别3：通配符可以使用超类限定而类型参数不行</h4><p>类型参数 T 只具有 一种 类型限定方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T extends A</span><br></pre></td></tr></table></figure>
<p>但是通配符 ? 可以进行 两种限定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">? extends A</span><br><span class="line">? super A</span><br></pre></td></tr></table></figure>
<h2 id="Class-lt-T-gt-和-Class-lt-gt-区别"><a href="#Class-lt-T-gt-和-Class-lt-gt-区别" class="headerlink" title="Class&lt; T &gt; 和 Class&lt; ? &gt; 区别"></a>Class&lt; T &gt; 和 Class&lt; ? &gt; 区别</h2><p>前面介绍了 ？和 T 的区别，那么对于，<code>Class&lt;T&gt;</code> 和 <code>&lt;Class&lt;?&gt;</code> 又有什么区别呢？</p>
<p>最常见的是在反射场景下的使用，这里以用一段发射的代码来说明下。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 通过反射的方式生成  multiLimit </span><br><span class="line">// 对象，这里比较明显的是，我们需要使用强制类型转换</span><br><span class="line">MultiLimit multiLimit = (MultiLimit)</span><br><span class="line">Class.forName(&quot;com.glmapper.bridge.boot.generic.MultiLimit&quot;).newInstance();</span><br></pre></td></tr></table></figure>
<p>对于上述代码，在运行期，如果反射的类型不是 MultiLimit 类，那么一定会报 java.lang.ClassCastException 错误。</p>
<p>对于这种情况，则可以使用下面的代码来代替，使得在在编译期就能直接 检查到类型的问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Ttest3&#123;</span><br><span class="line">	public static &lt;T&gt; T createInstance(Class&lt;T&gt; clazz) throws Exception&#123;</span><br><span class="line">		return clazz.newInstance();</span><br><span class="line">	&#125;</span><br><span class="line">	public static void main(String[] args) throws Exception&#123;</span><br><span class="line">		A a = createInstance(A.class);</span><br><span class="line">		B b = createInstance(B.class);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">class A&#123;&#125;</span><br><span class="line">class B&#123;&#125;</span><br></pre></td></tr></table></figure>
<p><code>Class&lt;T&gt;</code> 在实例化的时候，T 要替换成具体类。<code>Class&lt;?&gt;</code> 它是个通配泛型，? 可以代表任何类型，所以主要用于声明时的限制情况。比如，我们可以这样做申明：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 可以</span><br><span class="line">public Class&lt;?&gt; clazz;</span><br><span class="line">// 不可以，因为 T 需要指定类型</span><br><span class="line">public Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>
<p>所以当不知道定声明什么类型的 Class 的时候可以定义一 个<code>Class&lt;?&gt;</code>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test3 &#123;</span><br><span class="line">    public Class&lt;?&gt; clazz;</span><br><span class="line">    public Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>
<p>那如果也想 <code>public Class&lt;T&gt; clazzT;</code> 这样的话，就必须让当前的类也指定 T ，</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Test3&lt;T&gt; &#123;</span><br><span class="line">    public Class&lt;?&gt; clazz;</span><br><span class="line">    // 不会报错</span><br><span class="line">    public Class&lt;T&gt; clazzT;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>加密算法</title>
    <url>/2020/%E5%8A%A0%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="对称性加密算法"><a href="#对称性加密算法" class="headerlink" title="对称性加密算法"></a>对称性加密算法</h2><p><img src="/2020/加密算法/1.jpg" alt="加密流程图"></p>
<p>对称式加密就是加密和解密使用同一个密钥。信息接收双方都需事先知道密匙和加解密算法且其密匙是相同的，之后便是对数据进行加解密了。对称加密算法用来对敏感数据等信息进行加密。</p>
<p>对称加密算法的优点是：算法公开、计算量小、加密速度快、加密效率高。用途：对称加密算法用来对敏感数据等信息进行加密</p>
<p>对称加密算法的缺点是：在数据传送前，发送方和接收方必须商定好秘钥，然后使双方都能保存好秘钥。其次如果一方的秘钥被泄露，那么加密信息也就不安全了。另外，每对用户每次使用对称加密算法时，都需要使用其他人不知道的唯一秘钥，这会使得收、发双方所拥有的钥匙数量巨大，密钥管理成为双方的负担。</p>
<p><strong>DES</strong>：全称为Data Encryption Standard数据加密标准，速度较快，适用于加密大量数据的场合。</p>
<p><strong>3DES</strong>（Triple DES）：是基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高。</p>
<p><strong>AES</strong>：全称为Advanced Encryption Standard高级加密标准，是下一代的加密算法标准，速度快，安全级别高；AES是一个使用128为分组块的分组加密算法，分组块和128、192或256位的密钥一起作为输入，对4×4的字节数组上进行操作。众所周之AES是种十分高效的算法，尤其在8位架构中，这源于它面向字节的设计。AES 适用于8位的小型单片机或者普通的32位微处理器,并且适合用专门的硬件实现，硬件实现能够使其吞吐量（每秒可以到达的加密/解密bit数）达到十亿量级。同样，其也适用于RFID系统。</p>
<h2 id="非对称性算法"><a href="#非对称性算法" class="headerlink" title="非对称性算法"></a>非对称性算法</h2><p><img src="/2020/加密算法/2.jpg" alt="img"></p>
<p><strong>既然是加密，那肯定是不希望别人知道我的消息，所以只有我才能解密，所以可得出公钥负责加密，私钥负责解密；同理，既然是签名，那肯定是不希望有人冒充我发消息，只有我才能发布这个签名，所以可得出私钥负责签名，公钥负责验证。</strong></p>
<p>与对称加密算法不同，非对称加密算法需要两个密钥：公开密钥（publickey）和私有密钥（privatekey）。公开密钥与私有密钥是一对，如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密；如果用私有密钥对数据进行加密，那么只有用对应的公开密钥才能解密。因为加密和解密使用的是两个不同的密钥，所以这种算法叫作非对称加密算法。</p>
<p>非对称加密与有点是：安全性更好；对称加密的通信双方使用相同的秘钥，如果一方的秘钥遭泄露，那么整个通信就会被破解。而非对称加密使用一对秘钥，一个用来加密，一个用来解密，而且公钥是公开的，秘钥是自己保存的，不需要像对称加密那样在通信之前要先同步秘钥。</p>
<p>非对称加密的缺点是：加密和解密花费时间长、速度慢，只适合对少量数据进行加密。</p>
<p><strong>RSA</strong>：全称为Digital Signature Algorithm，是第一个能同时用于加密和数字签名的算法，也易于理解和操作。RSA是被研究得最广泛的公钥算法，从提出到现今的三十多年里，经历了各种攻击的考验，逐渐为人们接受，普遍认为是目前最优秀的公钥方案之一。</p>
<p><strong>DSA</strong>：全称为Digital Encryption Standard，是基于整数有限域离散对数难题的，其安全性与RSA相比差不多。DSA的一个重要特点是两个素数公开，这样，当使用别人的p和q时，即使不知道私钥，你也能确认它们是否是随机产生的，还是作了手脚。RSA算法却做不到。</p>
<p><strong>ECC</strong>：全称为Elliptic Curves Cryptography,，也叫椭圆加密算法，是一种公钥加密体制，最初由Koblitz和Miller两人于1985年提出，其数学基础是利用椭圆曲线上的有理点构成Abel加法群上椭圆离散对数的计算困难性。</p>
<blockquote>
<p>ECC和RSA相比，在许多方面都有对绝对的优势，主要体现在以下方面：</p>
<ol>
<li>抗攻击性强。相同的密钥长度，其抗攻击性要强很多倍。</li>
<li>计算量小，处理速度快。ECC总的速度比RSA、DSA要快得多。</li>
<li>存储空间占用小。ECC的密钥尺寸和系统参数与RSA、DSA相比要小得多，意味着它所占的存贮空间要小得多。这对于加密算法在IC卡上的应用具有特别重要的意义。</li>
<li>带宽要求低。当对长消息进行加解密时，三类密码系统有相同的带宽要求，但应用于短消息时ECC带宽要求却低得多。带宽要求低使ECC在无线网络领域具有广泛的应用前景。</li>
</ol>
</blockquote>
<h2 id="散列算法（签名算法）"><a href="#散列算法（签名算法）" class="headerlink" title="散列算法（签名算法）"></a>散列算法（签名算法）</h2><p><img src="/2020/加密算法/sl.png" alt="img"></p>
<p>散列算法，又称哈希函数，是一种单向加密算法。在信息安全技术中，经常需要验证消息的完整性，散列(Hash)函数提供了这一服务，它对不同长度的输入消息，产生固定长度的输出。这个固定长度的输出称为原输入消息的”散列”或”消息摘要”(Message digest)。散列算法不算加密算法，因为其结果是不可逆的，既然是不可逆的，那么当然不是用来加密的，而是签名。</p>
<p>用途：主要用于验证，防止信息被修。具体用途如：文件校验、数字签名、鉴权协议</p>
<p><strong>MD5</strong>：MD5是一种不可逆的加密算法，目前是最牢靠的加密算法之一，尚没有能够逆运算的程序被开发出来，它对应任何字符串都可以加密成一段唯一的固定长度的代码。</p>
<p><strong>SHA1</strong>：全称为Secure Hash Algorithm，即安全哈希算法，主要适用于数字签名标准（Digital Signature Standard DSS）里面定义的数字签名算法（Digital Signature Algorithm DSA）。有SHA-1，SHA-224，SHA-256，SHA-384，和SHA-512这几种单向散列算法，其中SHA-1已经不安全。而SHA-1基于MD5，MD5又基于MD4。</p>
<p><strong>HMAC</strong>：全称为Hash Message Authentication Code，即散列消息鉴别码，主要是利用哈希算法，以一个密钥和一个消息为输入，生成一个消息摘要作为输出。一般的，消息鉴别码用于验证传输于两个共 同享有一个密钥的单位之间的消息。HMAC 可以与任何迭代散列函数捆绑使用。MD5 和 SHA-1 就是这种散列函数。HMAC 还可以使用一个用于计算和确认消息鉴别值的密钥。</p>
<p><strong>建议：</strong> AES采用128为即可，RSA建议采用1024位的数字，ECC建议采用160位。RSA加密字符长度有限制，一般采用AES+RSA方式组合使用。</p>
<h2 id="Base64算法"><a href="#Base64算法" class="headerlink" title="Base64算法"></a>Base64算法</h2><p>Base64 加密算法是最常见的用于传递 8bit <strong>字节码的编码方式之一</strong></p>
<p>计算机任何数据都是按 ascii 码存储的，而 ascii 码的 128～256 之间的值是不可见字符，由于不同设备对字符处理方式有不同，可能会导致错误，不利于传输，所以把数据作为一个 Base64 编码，统统变成可见字符，出错可能性就降低了</p>
<p>Base64 是取 6 个比特为一组，计算它的 ascii 值，得到一个可见字符，在解码时按 6 个比特进行解码并读取，如 01010101101 等比特流，取 010110 计算它的 ascii 码，转化为可见字符，因此 Base64 <strong>还具备了数据压缩能力</strong></p>
<p>其实不是安全领域下的加密解密算法，只能算是一个编码算法，通常用于把二进制数据编码为可写的字符形式的数据，对数据内容进行编码来适合传输(可以对img图像编码用于传输)。这是一种可逆的编码方式。编码后的数据是一个字符串，其中包含的字符为：A-Z、a-z、0-9、+、/，共64个字符(26 + 26 + 10 + 1 + 1 = 64，其实是65个字符，“=”是填充字符。Base64要求把每三个8Bit的字节转换为四个6Bit的字节(3<em>8 = 4</em>6 = 24)，然后把6Bit再添两位高位0，组成四个8Bit的字节，也就是说，转换后的字符串理论上将要比原来的长1/3。原文的字节最后不够3个的地方用0来补足，转换时Base64编码用=号来代替。这就是为什么有些Base64编码会以一个或两个等号结束的原因，中间是不可能出现等号的，但等号最多只有两个。其实不用”=”也不耽误解码，之所以用”=”，可能是考虑到多段编码后的Base64字符串拼起来也不会引起混淆。)<br>Base64编码是从二进制到字符的过程，像一些中文字符用不同的编码转为二进制时，产生的二进制是不一样的，所以最终产生的Base64字符也不一样。例如”上网”对应utf-8格式的Base64编码是”5LiK572R”， 对应GB2312格式的Base64编码是”yc/N+A==”。<br>标准的Base64并不适合直接放在URL里传输，因为URL编码器会把标准Base64中的“/”和“+”字符变为形如“%XX”的形式，而这些“%”号在存入数据库时还需要再进行转换，因为ANSI SQL中已将“%”号用作通配符。<br>为解决此问题，可采用一种用于URL的改进Base64编码，它不在末尾填充’=’号，并将标准Base64中的“+”和“/”分别改成了“-”和“<em>”，这样就免去了在URL编解码和数据库存储时所要作的转换，避免了编码信息长度在此过程中的增加，并统一了数据库、表单等处对象标识符的格式。<br>另有一种用于正则表达式的改进Base64变种，它将“+”和“/”改成了“!”和“-”，因为“+”，“*”以及前面在IRCu中用到的“[”和“]”在正则表达式中都可能具有特殊含义。<br>此外还有一些变种，它们将“+/”改为“</em>-”或“.<em>”（用作编程语言中的标识符名称）或“.-”（用于XML中的Nmtoken）甚至“</em>:”（用于XML中的Name）。</p>
<h2 id="AES-RSA组合应用"><a href="#AES-RSA组合应用" class="headerlink" title="AES+RSA组合应用"></a>AES+RSA组合应用</h2><p>RSA与AES加密算法所产生的密钥数不一样，它们是如何进行加密的呢？</p>
<p>接收方生成RSA密钥对，将其中的RSA公钥传递给发送方(接收方与发送方建立连接是需要认证的，SSL/TLS协议可以确保RSA公钥的安全完整)，然后用RSA公钥对AES密钥进行加密，加密后的结果传递给接收方，接收方用RSA私钥解密后，得到AES密钥，最后使用AES密钥解密，从而达到安全互通数据的目的。(如下图所示)</p>
<p><img src="/2020/加密算法/3.png" alt="3"></p>
<p><img src="/2020/加密算法/4.jpg" alt="img"></p>
<h2 id="项目应用总结"><a href="#项目应用总结" class="headerlink" title="项目应用总结"></a>项目应用总结</h2><ol>
<li>加密算法是可逆的，用来对敏感数据进行保护。散列算法(签名算法、哈希算法)是不可逆的，主要用于身份验证。</li>
<li>对称加密算法使用同一个密匙加密和解密，速度快，适合给大量数据加密。对称加密客户端和服务端使用同一个密匙，存在被抓包破解的风险。</li>
<li>非对称加密算法使用公钥加密，私钥解密，私钥签名，公钥验签。安全性比对称加密高，但速度较慢。非对称加密使用两个密匙，服务端和客户端密匙不一样，私钥放在服务端，黑客一般是拿不到的，安全性高。</li>
<li>Base64不是安全领域下的加解密算法，只是一个编码算法，通常用于把二进制数据编码为可写的字符形式的数据，特别适合在http，mime协议下的网络快速传输数据。UTF-8和GBK中文的Base64编码结果是不同的。采用Base64编码不仅比较简短，同时也具有不可读性，即所编码的数据不会被人用肉眼所直接看到，但这种方式很初级，很简单。Base64可以对图片文件进行编码传输。</li>
<li>大量数据加密建议采用对称加密算法，提高加解密速度；小量的机密数据，可以采用非对称加密算法。在实际的操作过程中，我们通常采用的方式是：采用非对称加密算法管理对称算法的密钥，然后用对称加密算法加密数据，这样我们就集成了两类加密算法的优点，既实现了加密速度快的优点，又实现了安全方便管理密钥的优点。</li>
<li>MD5标准密钥长度128位（128位是指二进制位。二进制太长，所以一般都改写成16进制，每一位16进制数可以代替4位二进制数，所以128位二进制数写成16进制就变成了128/4=32位。16位加密就是从32位MD5散列中把中间16位提取出来）；sha1标准密钥长度160位(比MD5摘要长32位)，Base64转换后的字符串理论上将要比原来的长1/3。</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.KeyGenerator;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> javax.crypto.spec.SecretKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.SecureRandom;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * AES 加密方法，是对称的密码算法(加密与解密的密钥一致)。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESUtil</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获得一个 密钥长度为 128 位的 AES 密钥，</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回经 BASE64 处理之后的密钥字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getStrKeyAES</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyGenerator keyGen = KeyGenerator.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        SecureRandom secureRandom = <span class="keyword">new</span> SecureRandom(String.valueOf(System.currentTimeMillis()).getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="comment">// 这里可以是 128、192、256、越大越安全</span></span><br><span class="line">        keyGen.init(<span class="number">128</span>, secureRandom);</span><br><span class="line">        SecretKey secretKey = keyGen.generateKey();</span><br><span class="line">        <span class="keyword">return</span> base64_byteArr2Str(secretKey.getEncoded());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将使用 Base64 加密后的字符串类型的 secretKey 转为 SecretKey</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> strKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> SecretKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecretKey <span class="title">strKey2SecretKey</span><span class="params">(String strKey)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] byteArr = base64_str2ByteArr(strKey);</span><br><span class="line">        SecretKeySpec secretKey = <span class="keyword">new</span> SecretKeySpec(byteArr, <span class="string">"AES"</span>);</span><br><span class="line">        <span class="keyword">return</span> secretKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   待加密内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKey 加密使用的 AES 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后的密文 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] encryptAES(<span class="keyword">byte</span>[] content, SecretKey secretKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, secretKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 加密 返回Base64编码的字符串密文</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String message, String secretKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SecretKey aesKey = AESUtil.strKey2SecretKey(secretKey);</span><br><span class="line">        <span class="comment">//加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptAESByteArr = AESUtil.encryptAES(message.getBytes(<span class="string">"utf-8"</span>), aesKey);</span><br><span class="line">        <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">        <span class="keyword">return</span> AESUtil.base64_byteArr2Str(encryptAESByteArr);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * &lt;p&gt;</span></span><br><span class="line"><span class="comment">     * 解密 传入Base64编码的字符串密文，返回解密后的字符串</span></span><br><span class="line"><span class="comment">     * &lt;/p&gt;</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String encryptMsgBase64Str, String secretKey)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SecretKey aesKey = AESUtil.strKey2SecretKey(secretKey);</span><br><span class="line">        <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] messageByteArr = AESUtil.base64_str2ByteArr(encryptMsgBase64Str);</span><br><span class="line">        <span class="comment">//解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptAESByteArr = AESUtil.decryptAES(messageByteArr, aesKey);</span><br><span class="line">        String descyptAes = <span class="keyword">new</span> String(decryptAESByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="keyword">return</span> descyptAes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   待解密内容</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> secretKey 解密使用的 AES 密钥</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解密后的明文 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] decryptAES(<span class="keyword">byte</span>[] content, SecretKey secretKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"AES"</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, secretKey);</span><br><span class="line">        <span class="keyword">return</span> cipher.doFinal(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转Base64编码字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">base64_byteArr2Str</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base64编码字符串转字节数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base64Key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] base64_str2ByteArr(String base64Key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getDecoder().decode(base64Key);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.Cipher;</span><br><span class="line"><span class="keyword">import</span> java.security.*;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.PKCS8EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.security.spec.X509EncodedKeySpec;</span><br><span class="line"><span class="keyword">import</span> java.util.Base64;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * RSA 是非对称的密码算法，密钥分公钥和私钥，公钥用来加密，私钥用于解密</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAUtil</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span>  <span class="title">RSAUtil</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 生成密钥对：密钥对中包含公钥和私钥</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 包含 RSA 公钥与私钥的 keyPair</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> KeyPair <span class="title">getKeyPair</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        SecureRandom secureRandom = <span class="keyword">new</span> SecureRandom(String.valueOf(System.currentTimeMillis()).getBytes(<span class="string">"utf-8"</span>));</span><br><span class="line">        <span class="comment">// 这里可以是1024、2048 初始化一个密钥对</span></span><br><span class="line">        keyPairGenerator.initialize(<span class="number">2048</span>, secureRandom);</span><br><span class="line">        KeyPair keyPair = keyPairGenerator.generateKeyPair();</span><br><span class="line">        <span class="keyword">return</span> keyPair;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取公钥 (并进行Base64编码，返回一个 Base64 编码后的字符串)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个 Base64 编码后的公钥字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPublicKey</span><span class="params">(KeyPair keyPair)</span> </span>&#123;</span><br><span class="line">        PublicKey publicKey = keyPair.getPublic();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = publicKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> base64_byteArr2Str(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取私钥(并进行Base64编码，返回一个 Base64 编码后的字符串)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> keyPair</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 返回一个 Base64 编码后的私钥字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getPrivateKey</span><span class="params">(KeyPair keyPair)</span> </span>&#123;</span><br><span class="line">        PrivateKey privateKey = keyPair.getPrivate();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = privateKey.getEncoded();</span><br><span class="line">        <span class="keyword">return</span> base64_byteArr2Str(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Base64编码后的公钥转换成 PublicKey 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> pubStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> PublicKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PublicKey <span class="title">string2PublicKey</span><span class="params">(String pubStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(pubStr);</span><br><span class="line">        X509EncodedKeySpec keySpec = <span class="keyword">new</span> X509EncodedKeySpec(bytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        PublicKey publicKey = keyFactory.generatePublic(keySpec);</span><br><span class="line">        <span class="keyword">return</span> publicKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将Base64编码后的私钥转换成 PrivateKey 对象</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> priStr</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> PrivateKey</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PrivateKey <span class="title">string2PrivateKey</span><span class="params">(String priStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = Base64.getDecoder().decode(priStr);</span><br><span class="line">        PKCS8EncodedKeySpec keySpec = <span class="keyword">new</span> PKCS8EncodedKeySpec(bytes);</span><br><span class="line">        KeyFactory keyFactory = KeyFactory.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        PrivateKey privateKey = keyFactory.generatePrivate(keySpec);</span><br><span class="line">        <span class="keyword">return</span> privateKey;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content   待加密的内容 byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> publicKey 加密所需的公钥对象 PublicKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 加密后的字节数组 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] publicEncrypt(<span class="keyword">byte</span>[] content, PublicKey publicKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        cipher.init(Cipher.ENCRYPT_MODE, publicKey);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 公钥加密并返回Base64编码的结果</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">encrypt</span><span class="params">(String message, String publicKeyStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line">        PublicKey publicKey = RSAUtil.string2PublicKey(publicKeyStr);</span><br><span class="line">        <span class="comment">//用公钥加密</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicEncrypt = RSAUtil.publicEncrypt(message.getBytes(<span class="string">"utf-8"</span>), publicKey);</span><br><span class="line">        <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">        String encryptMsgBase64Str = RSAUtil.base64_byteArr2Str(publicEncrypt);</span><br><span class="line">        <span class="keyword">return</span> encryptMsgBase64Str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> content    待解密的内容 byte[]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> privateKey 解密需要的私钥对象 PrivateKey</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> 解密后的字节数组 byte[]</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] privateDecrypt(<span class="keyword">byte</span>[] content, PrivateKey privateKey) <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        Cipher cipher = Cipher.getInstance(<span class="string">"RSA"</span>);</span><br><span class="line">        cipher.init(Cipher.DECRYPT_MODE, privateKey);</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = cipher.doFinal(content);</span><br><span class="line">        <span class="keyword">return</span> bytes;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 私钥解密,返回字符串</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">decrypt</span><span class="params">(String encryptMsgBase64Str, String privateKeyStr)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line">        PrivateKey privateKey = RSAUtil.string2PrivateKey(privateKeyStr);</span><br><span class="line">        <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptMsgByteArr = RSAUtil.base64_str2ByteArr(encryptMsgBase64Str);</span><br><span class="line">        <span class="comment">//用私钥解密</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptmsgByteArr = RSAUtil.privateDecrypt(encryptMsgByteArr, privateKey);</span><br><span class="line">        String decryptmsgStr = <span class="keyword">new</span> String(decryptmsgByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="keyword">return</span> decryptmsgStr;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 字节数组转Base64编码字符串</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> bytes</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">base64_byteArr2Str</span><span class="params">(<span class="keyword">byte</span>[] bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getEncoder().encodeToString(bytes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Base64编码字符串转字节数组</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> base64Key</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">byte</span>[] base64_str2ByteArr(String base64Key) &#123;</span><br><span class="line">        <span class="keyword">return</span> Base64.getDecoder().decode(base64Key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESUtilTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String key;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            key = AESUtil.getStrKeyAES();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">encryptFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//String sourceFilePath = "D://滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案.docx";</span></span><br><span class="line">        String sourceFilePath = <span class="string">"E:\\打印\\JasperReports+iReport报表开发详解.pdf"</span>;</span><br><span class="line">        <span class="comment">//String sourceFilePath = "D:\\1583915786661_html_2f4d5dc.png";</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// String destFilePath = "D://test//滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案jiami.docx";</span></span><br><span class="line">        String destFilePath = <span class="string">"D://test//JasperReports+iReport报表开发详解jm.pdf"</span>;</span><br><span class="line">        FileEncryptUtil.encryptFile(key, sourceFilePath, destFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">decryptFile</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        String sourceFilePath = <span class="string">"D://test//JasperReports+iReport报表开发详解jm.pdf"</span>;</span><br><span class="line">        <span class="comment">//String sourceFilePath = "D://test//滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案jiami.docx";</span></span><br><span class="line">      <span class="comment">//  String destFilePath = "E://test//滨海石化10000m3拱顶罐（1-4）泄漏和火灾事故现场应急处置方案.docx";</span></span><br><span class="line">        String destFilePath = <span class="string">"E://test//JasperReports+iReport报表开发详解.pdf"</span>;</span><br><span class="line">        <span class="comment">//String destFilePath="E:\\11.png";</span></span><br><span class="line">        FileEncryptUtil.decryptFile(key, sourceFilePath, destFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//=================客户端=================</span></span><br><span class="line">            <span class="comment">//hello, i am infi, good night!加密</span></span><br><span class="line">            String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line">            System.out.println(<span class="string">"明文数据为："</span> + message);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//生成AES秘钥，并Base64编码</span></span><br><span class="line">            String aesKeyBase64Str = AESUtil.getStrKeyAES();</span><br><span class="line">            System.out.println(<span class="string">"AES秘钥Base64编码:"</span> + aesKeyBase64Str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//将Base64编码的字符串，转换成AES秘钥</span></span><br><span class="line">            SecretKey aesKey = AESUtil.strKey2SecretKey(aesKeyBase64Str);</span><br><span class="line">            <span class="comment">//加密</span></span><br><span class="line">            <span class="keyword">byte</span>[] encryptAESByteArr = AESUtil.encryptAES(message.getBytes(<span class="string">"utf-8"</span>), aesKey);</span><br><span class="line">            <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">            String encryptAESBase64Str = AESUtil.base64_byteArr2Str(encryptAESByteArr);</span><br><span class="line">            System.out.println(<span class="string">"加密并Base64编码的结果："</span> + encryptAESBase64Str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//##############   网络上传输的内容有Base64编码后的秘钥 和 Base64编码加密后的内容    #################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//===================服务端================</span></span><br><span class="line">            <span class="comment">//将Base64编码的字符串，转换成AES秘钥</span></span><br><span class="line">            SecretKey aesKeyFromNet = AESUtil.strKey2SecretKey(aesKeyBase64Str);</span><br><span class="line">            <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">            <span class="keyword">byte</span>[] encryptAESByteArrFromNet = AESUtil.base64_str2ByteArr(encryptAESBase64Str);</span><br><span class="line">            <span class="comment">//解密</span></span><br><span class="line">            <span class="keyword">byte</span>[] decryptAESByteArr = AESUtil.decryptAES(encryptAESByteArrFromNet, aesKeyFromNet);</span><br><span class="line">            String descyptAes = <span class="keyword">new</span> String(decryptAESByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//解密后的明文</span></span><br><span class="line">            System.out.println(<span class="string">"解密后的明文: "</span> + descyptAes);</span><br><span class="line">            <span class="keyword">if</span> (message.equals(descyptAes)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//封装方法测试</span></span><br><span class="line">            String miwen=AESUtil.encrypt(message,aesKeyBase64Str);</span><br><span class="line">            System.out.println(miwen);</span><br><span class="line">            String minwen=AESUtil.decrypt(miwen,aesKeyBase64Str);</span><br><span class="line">            System.out.println(minwen);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> begin = System.currentTimeMillis();</span><br><span class="line">            encryptFile();</span><br><span class="line">            decryptFile();</span><br><span class="line">            <span class="keyword">long</span> end = System.currentTimeMillis();</span><br><span class="line">            System.err.println(<span class="string">"耗时："</span> + (end - begin) / <span class="number">1000</span> + <span class="string">"秒"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RSAUtilTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//===============生成公钥和私钥，公钥传给客户端，私钥服务端保留==================</span></span><br><span class="line">            <span class="comment">//生成RSA公钥和私钥，并Base64编码</span></span><br><span class="line">            KeyPair keyPair = RSAUtil.getKeyPair();</span><br><span class="line">            String publicKeyStr = RSAUtil.getPublicKey(keyPair);</span><br><span class="line">            String privateKeyStr = RSAUtil.getPrivateKey(keyPair);</span><br><span class="line">            System.out.println(<span class="string">"RSA公钥Base64编码:"</span> + publicKeyStr);</span><br><span class="line">            System.out.println(<span class="string">"RSA私钥Base64编码:"</span> + privateKeyStr);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//=================客户端=================</span></span><br><span class="line">            <span class="comment">//hello, i am infi, good night!加密</span></span><br><span class="line">            String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line">            <span class="comment">//将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line">            PublicKey publicKey = RSAUtil.string2PublicKey(publicKeyStr);</span><br><span class="line">            <span class="comment">//用公钥加密</span></span><br><span class="line">            <span class="keyword">byte</span>[] publicEncrypt = RSAUtil.publicEncrypt(message.getBytes(<span class="string">"utf-8"</span>), publicKey);</span><br><span class="line">            <span class="comment">//加密后的内容Base64编码</span></span><br><span class="line">            String encryptMsgBase64Str = RSAUtil.base64_byteArr2Str(publicEncrypt);</span><br><span class="line">            System.out.println(<span class="string">"公钥加密并Base64编码的结果："</span> + encryptMsgBase64Str);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//##############    网络上传输的内容有Base64编码后的公钥 和 Base64编码后的公钥加密的内容     #################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//===================服务端================</span></span><br><span class="line">            <span class="comment">//将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line">            PrivateKey privateKey = RSAUtil.string2PrivateKey(privateKeyStr);</span><br><span class="line">            <span class="comment">//加密后的内容Base64解码</span></span><br><span class="line">            <span class="keyword">byte</span>[] encryptMsgFromNet = RSAUtil.base64_str2ByteArr(encryptMsgBase64Str);</span><br><span class="line">            <span class="comment">//用私钥解密</span></span><br><span class="line">            <span class="keyword">byte</span>[] privateDecryptmsgByteArr = RSAUtil.privateDecrypt(encryptMsgFromNet, privateKey);</span><br><span class="line">            String privateDecrypmsgtStr = <span class="keyword">new</span> String(privateDecryptmsgByteArr, <span class="string">"utf-8"</span>);</span><br><span class="line">            <span class="comment">//解密后的明文</span></span><br><span class="line">            System.out.println(<span class="string">"解密后的明文: "</span> + privateDecrypmsgtStr);</span><br><span class="line">            <span class="keyword">if</span> (message.equals(privateDecrypmsgtStr)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">//封装方法测试</span></span><br><span class="line">            String miwen=RSAUtil.encrypt(message,publicKeyStr);</span><br><span class="line">            System.out.println(<span class="string">"密文: "</span> + miwen);</span><br><span class="line">            String mingwen=RSAUtil.decrypt(miwen,privateKeyStr);</span><br><span class="line">            System.out.println(<span class="string">"明文: "</span> + mingwen);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> net.huadong.tech.base.util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.crypto.SecretKey;</span><br><span class="line"><span class="keyword">import</span> java.security.KeyPair;</span><br><span class="line"><span class="keyword">import</span> java.security.PrivateKey;</span><br><span class="line"><span class="keyword">import</span> java.security.PublicKey;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AESAndRSATest</span> </span>&#123;</span><br><span class="line">    <span class="comment">//测试RSA与AES的结合。</span></span><br><span class="line">    <span class="comment">//客户端：AES秘钥加密明文得到密文，然后用从服务器获取的RSA公钥加密AES秘钥，网络传输密文和RSA加密后的AES秘钥到服务器</span></span><br><span class="line">    <span class="comment">//服务端：用RSA私钥解密AES秘钥，解密后的AES秘钥再用来解密密文，得到明文。</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//===============生成公钥和私钥，公钥传给客户端，私钥服务端保留==================</span></span><br><span class="line">        <span class="comment">//生成RSA公钥和私钥，并Base64编码，生成一次以后，就写死在配置文件或代码中，下次不再重新生成</span></span><br><span class="line">        KeyPair keyPair = RSAUtil.getKeyPair();</span><br><span class="line">        String publicKeyStr = RSAUtil.getPublicKey(keyPair);</span><br><span class="line">        String privateKeyStr = RSAUtil.getPrivateKey(keyPair);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥Base64编码:"</span> + publicKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥Base64编码:"</span> + privateKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=================客户端=================</span></span><br><span class="line">        <span class="comment">//hello, i am infi, good night!  需要加密的实际内容</span></span><br><span class="line">        String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line">        <span class="comment">//将Base64编码后的公钥转换成PublicKey对象</span></span><br><span class="line">        PublicKey publicKey = RSAUtil.string2PublicKey(publicKeyStr);</span><br><span class="line">        <span class="comment">//生成AES秘钥，并Base64编码</span></span><br><span class="line">        String aesKeyStr = AESUtil.getStrKeyAES();</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥Base64编码:"</span> + aesKeyStr);</span><br><span class="line">        <span class="comment">//用公钥加密AES秘钥</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicEncryptAESKey = RSAUtil.publicEncrypt(aesKeyStr.getBytes(<span class="string">"utf-8"</span>), publicKey);</span><br><span class="line">        <span class="comment">//公钥加密AES秘钥后的内容Base64编码</span></span><br><span class="line">        String publicEncryptAESKeyStr = RSAUtil.base64_byteArr2Str(publicEncryptAESKey);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥加密AES秘钥并Base64编码的结果："</span> + publicEncryptAESKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Base64编码后的AES秘钥转换成SecretKey对象</span></span><br><span class="line">        SecretKey aesKey = AESUtil.strKey2SecretKey(aesKeyStr);</span><br><span class="line">        <span class="comment">//用AES秘钥加密实际的内容</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptAES = AESUtil.encryptAES(message.getBytes(<span class="string">"utf-8"</span>), aesKey);</span><br><span class="line">        <span class="comment">//AES秘钥加密后的内容Base64编码</span></span><br><span class="line">        String encryptAESStr = AESUtil.base64_byteArr2Str(encryptAES);</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥加密实际的内容并Base64编码的结果："</span> + encryptAESStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//##############   网络上传输的内容有Base64编码后的公钥加密AES秘钥的结果 和 Base64编码后的AES秘钥加密实际内容的结果   #################</span></span><br><span class="line">        <span class="comment">//##############   即publicEncryptAESKeyStr和encryptAESStr  ###################</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//===================服务端================</span></span><br><span class="line">        <span class="comment">//将Base64编码后的私钥转换成PrivateKey对象</span></span><br><span class="line">        PrivateKey privateKey = RSAUtil.string2PrivateKey(privateKeyStr);</span><br><span class="line">        <span class="comment">//公钥加密AES秘钥后的内容(Base64编码)，进行Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] publicEncryptAESKeyFromNet = RSAUtil.base64_str2ByteArr(publicEncryptAESKeyStr);</span><br><span class="line">        <span class="comment">//用私钥解密,得到aesKey</span></span><br><span class="line">        <span class="keyword">byte</span>[] aesKeyStrBytes = RSAUtil.privateDecrypt(publicEncryptAESKeyFromNet, privateKey);</span><br><span class="line">        <span class="comment">//解密后的aesKey</span></span><br><span class="line">        String aesKeyStrFromNet = <span class="keyword">new</span> String(aesKeyStrBytes,<span class="string">"utf-8"</span>);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥解密AES秘钥并Base64编码的结果: "</span> + aesKeyStrFromNet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将Base64编码后的AES秘钥转换成SecretKey对象</span></span><br><span class="line">        SecretKey aesKey2 = AESUtil.strKey2SecretKey(aesKeyStrFromNet);</span><br><span class="line">        <span class="comment">//AES秘钥加密后的内容(Base64编码)，进行Base64解码</span></span><br><span class="line">        <span class="keyword">byte</span>[] encryptAES2 = AESUtil.base64_str2ByteArr(encryptAESStr);</span><br><span class="line">        <span class="comment">//用AES秘钥解密实际的内容</span></span><br><span class="line">        <span class="keyword">byte</span>[] decryptAES = AESUtil.decryptAES(encryptAES2, aesKey2);</span><br><span class="line">        String decryptAESStr=<span class="keyword">new</span> String(decryptAES,<span class="string">"utf-8"</span>);</span><br><span class="line">        <span class="comment">//解密后的实际内容</span></span><br><span class="line">        System.out.println(<span class="string">"解密后的实际内容: "</span> + decryptAESStr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (message.equals(decryptAESStr)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 封装方法测试</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> Exception</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testSimple</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//===============生成公钥和私钥，公钥传给客户端，私钥服务端保留==================</span></span><br><span class="line">        <span class="comment">//生成RSA公钥和私钥，并Base64编码，生成一次以后，就写死在配置文件或代码中，下次不再重新生成</span></span><br><span class="line">        KeyPair keyPair = RSAUtil.getKeyPair();</span><br><span class="line">        String publicKeyStr = RSAUtil.getPublicKey(keyPair);</span><br><span class="line">        String privateKeyStr = RSAUtil.getPrivateKey(keyPair);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥Base64编码:"</span> + publicKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥Base64编码:"</span> + privateKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//=================客户端=================</span></span><br><span class="line">        <span class="comment">//hello, i am infi, good night!  需要加密的实际内容</span></span><br><span class="line">        String message = <span class="string">"hello, i am infi, good night!"</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//生成AES秘钥，并Base64编码</span></span><br><span class="line">        String aesKeyStr = AESUtil.getStrKeyAES();</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥Base64编码:"</span> + aesKeyStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//用公钥加密AES秘钥</span></span><br><span class="line">        String publicEncryptAESKeyStr = RSAUtil.encrypt(aesKeyStr,publicKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA公钥加密AES秘钥并Base64编码的结果："</span> + publicEncryptAESKeyStr);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用AES秘钥加密实际的内容Base64编码</span></span><br><span class="line">        String encryptAESStr = AESUtil.encrypt(message, aesKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"AES秘钥加密实际的内容并Base64编码的结果："</span> + encryptAESStr);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="comment">//===================服务端================</span></span><br><span class="line">        <span class="comment">//用RSA私钥解密,得到aesKey</span></span><br><span class="line">        String aesKeyStrFromNet = RSAUtil.decrypt(publicEncryptAESKeyStr, privateKeyStr);</span><br><span class="line">        System.out.println(<span class="string">"RSA私钥解密AES秘钥并Base64编码的结果: "</span> + aesKeyStrFromNet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用AES秘钥解密实际的内容</span></span><br><span class="line">        String decryptAESStr = AESUtil.decrypt(encryptAESStr, aesKeyStrFromNet);</span><br><span class="line">        <span class="comment">//解密后的实际内容</span></span><br><span class="line">        System.out.println(<span class="string">"AES解密后的实际内容: "</span> + decryptAESStr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (message.equals(decryptAESStr)) &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试通过！"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"测试未通过！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//test();</span></span><br><span class="line">            testSimple();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>开博</title>
    <url>/2019/%E5%BC%80%E5%8D%9A/</url>
    <content><![CDATA[<p>记录生活<br>感悟人生</p>
]]></content>
  </entry>
  <entry>
    <title>开源协议介绍</title>
    <url>/2021/%E5%BC%80%E6%BA%90%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<p>网上看到一篇对开原协议讲述的比较通俗易懂的文章，感谢原作者。</p>
<p>世界上的开源许可证（Open Source License）大概有上百种，今天我们来介绍下几种我们常见的开源协议。大致有GPL、BSD、MIT、Mozilla、Apache和LGPL等。</p>
<p><img src="/2021/开源协议介绍/0.604344791375343.png" alt="img"></p>
<h3 id="Apache-License"><a href="#Apache-License" class="headerlink" title="Apache License"></a>Apache License</h3><p>Apache License（Apache许可证），是Apache软件基金会发布的一个自由软件许可证。</p>
<p>Apache Licence是著名的非盈利开源组织Apache采用的协议。该协议和BSD类似，同样鼓励代码共享和最终原作者的著作权，同样允许源代码修改和再发布。但是也需要遵循以下条件：</p>
<ul>
<li>需要给代码的用户一份Apache Licence。</li>
<li>如果修改了代码，需要再被修改的文件中说明。</li>
<li>在衍生的代码中（修改和有源代码衍生的代码中）需要带有原来代码中的协议，商标，专利声明和其他原来作者规定需要包含的说明。</li>
<li>如果再发布的产品中包含一个Notice文件，则在Notice文件中需要带有Apache Licence。你可以再Notice中增加自己的许可，但是不可以表现为对Apache Licence构成更改。</li>
<li>Apache Licence也是对商业应用又好的许可。使用者也可以再需要的时候修改代码来满足并作为开源或商业产品发布/销售。</li>
</ul>
<p>使用这个协议的好处是:</p>
<ul>
<li>永久权利 一旦被授权，永久拥有。</li>
<li>全球范围的权利 在一个国家获得授权，适用于所有国家。假如你在美国，许可是从印度授权的，也没有问题。</li>
<li>授权免费 无版税， 前期、后期均无任何费用。</li>
<li>授权无排他性 任何人都可以获得授权</li>
<li>授权不可撤消 一旦获得授权，没有任何人可以取消。比如，你基于该产品代码开发了衍生产品，你不用担心会在某一天被禁止使用该代码</li>
</ul>
<h3 id="BSD"><a href="#BSD" class="headerlink" title="BSD"></a>BSD</h3><p>BSD是”Berkeley Software Distribution”的缩写，意思是”伯克利软件发行版”。</p>
<p>BSD开源协议：是一个给于使用者很大自由的协议。可以自由的使用，修改源代码，也可以将修改后的代码作为开源或者专有软件再发布。 当你发布使用了BSD协议的代码，或则以BSD协议代码为基础做二次开发自己的产品时，需要满足三个条件：</p>
<ul>
<li>如果再发布的产品中包含源代码，则在源代码中必须带有原来代码中的BSD协议。</li>
<li>如果再发布的只是二进制类库/软件，则需要在类库/软件的文档和版权声明中包含原来代码中的BSD协议。</li>
<li>不可以用开源代码的作者/机构名字和原来产品的名字做市场推广。</li>
</ul>
<p>BSD代码鼓励代码共享，但需要尊重代码作者的著作权。BSD由于允许使用者修改和重新发布代码，也允许使用或在BSD代码上开发商业软件发布和销售，因此是对商业集成很友好的协议。而很多的公司企业在选用开源产品的时候都首选BSD协议，因为可以完全控制这些第三方的代码，在必要的时候可以修改或者二次开发。</p>
<h3 id="GPL"><a href="#GPL" class="headerlink" title="GPL"></a>GPL</h3><p>GPL （GNU General Public License） ：GNU通用公共许可协议。</p>
<p><strong>Linux 采用了 GPL</strong>。</p>
<p>GPL协议和BSD, Apache Licence等鼓励代码重用的许可很不一样。GPL的出发点是代码的开源/免费使用和引用/修改/衍生代码的开源/免费使用，但不允许修改后和衍生的代码做为闭源的商业软件发布和销售。这也就是为什么我们能用免费的各种linux，包括商业公司的linux和linux上各种各样的由个人，组织，以及商业软件公司开发的免费软件了。</p>
<h3 id="LGPL"><a href="#LGPL" class="headerlink" title="LGPL"></a>LGPL</h3><p>LGPL是GPL的一个为主要为类库使用设计的开源协议。和GPL要求任何使用/修改/衍生之GPL类库的的软件必须采用GPL协议不同。LGPL允许商业软件通过类库引用(link)方式使用LGPL类库而不需要开源商业软件的代码。这使得采用LGPL协议的开源代码可以被商业软件作为类库引用并发布和销售。</p>
<p>但是如果修改LGPL协议的代码或者衍生，则所有修改的代码，涉及修改部分的额外代码和衍生的代码都必须采用LGPL协议。因此LGPL协议的开源代码很适合作为第三方类库被商业软件引用，但不适合希望以LGPL协议代码为基础，通过修改和衍生的方式做二次开发的商业软件采用。</p>
<p>GPL/LGPL都保障原作者的知识产权，避免有人利用开源代码复制并开发类似的产品。</p>
<h3 id="MIT"><a href="#MIT" class="headerlink" title="MIT"></a>MIT</h3><p>MIT是和BSD一样宽范的许可协议,源自麻省理工学院（Massachusetts Institute of Technology, MIT），又称X11协议。作者只想保留版权,而无任何其他了限制。MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。</p>
<p>MIT与BSD类似，但是比BSD协议更加宽松，是目前最少限制的协议。这个协议唯一的条件就是在修改后的代码或者发行包包含原作者的许可信息。适用商业软件。使用MIT的软件项目有：jquery、Node.js。</p>
<h3 id="MPL-Mozilla-Public-License-1-1"><a href="#MPL-Mozilla-Public-License-1-1" class="headerlink" title="MPL (Mozilla Public License 1.1)"></a>MPL (Mozilla Public License 1.1)</h3><p>MPL协议允许免费重发布、免费修改，但要求修改后的代码版权归软件的发起者 。这种授权维护了商业软件的利益，它要求基于这种软件的修改无偿贡献版权给该软件。这样，围绕该软件的所有代码的版权都集中在发起开发人的手中。但MPL是允许修改，无偿使用得。MPL软件对链接没有要求。</p>
<h3 id="EPL-Eclipse-Public-License-1-0"><a href="#EPL-Eclipse-Public-License-1-0" class="headerlink" title="EPL (Eclipse Public License 1.0)"></a>EPL (Eclipse Public License 1.0)</h3><p>EPL允许Recipients任意使用、复制、分发、传播、展示、修改以及改后闭源的二次商业发布。</p>
<p>使用EPL协议，需要遵守以下规则：</p>
<ul>
<li>当一个Contributors将源码的整体或部分再次开源发布的时候,必须继续遵循EPL开源协议来发布,而不能改用其他协议发布.除非你得到了原”源码”Owner 的授权；</li>
<li>EPL协议下,你可以将源码不做任何修改来商业发布.但如果你要发布修改后的源码,或者当你再发布的是Object Code的时候,你必须声明它的Source Code是可以获取的,而且要告知获取方法；</li>
<li>当你需要将EPL下的源码作为一部分跟其他私有的源码混和着成为一个Project发布的时候,你可以将整个Project/Product以私人的协议发布,但要声明哪一部分代码是EPL下的,而且声明那部分代码继续遵循EPL；</li>
<li>4.独立的模块(Separate Module),不需要开源。</li>
</ul>
<h3 id="Creative-Commons-知识共享协议"><a href="#Creative-Commons-知识共享协议" class="headerlink" title="Creative Commons 知识共享协议"></a>Creative Commons 知识共享协议</h3><p>Creative Commons (CC) 许可协议并不能说是真正的开源协议，它们大多是被使用于设计类的工程上。 CC 协议种类繁多，每一种都授权特定的权利。 一个 CC 许可协议具有四个基本部分，这几个部分可以单独起作用，也可以组合起来。下面是这几部分的简介：</p>
<ul>
<li>署名 作品上必须附有作品的归属。如此之后，作品可以被修改，分发，复制和其它用途。</li>
<li>相同方式共享 作品可以被修改、分发或其它操作，但所有的衍生品都要置于CC许可协议下。</li>
<li>非商业用途 作品可以被修改、分发等等，但不能用于商业目的。但语言上对什么是”商业”的说明十分含糊不清 (没有提供精确的定义)，所以你可以在你的工程里对其进行说明。例如，有些人简单的解释”非商业”为不能出售这个作品。而另外一些人认为你甚至不能在有广告的网站上使用它们。 还有些人认为”商业”仅仅指你用它获取利益。</li>
<li>禁止衍生作品</li>
</ul>
<p>CC 许可协议的这些条款可以自由组合使用。大多数的比较严格的CC协议会声明 “署名权，非商业用途，禁止衍生”条款，这意味着你可以自由的分享这个作品，但你不能改变它和对其收费，而且必须声明作品的归属。这个许可协议非常的有用，它可以让你的作品传播出去，但又可以对作品的使用保留部分或完全的控制。最少限制的CC协议类型当属 “署名”协议，这意味着只要人们能维护你的名誉，他们对你的作品怎么使用都行。</p>
<p>CC 许可协议更多的是在设计类工程中使用，而不是开发类，但没有人或妨碍你将之使用与后者。只是你必须要清楚各部分条款能覆盖到的和不能覆盖到的权利。</p>
<hr>
<h3 id="图解分析"><a href="#图解分析" class="headerlink" title="图解分析"></a>图解分析</h3><p><img src="/2021/开源协议介绍/0.806442015465004.png" alt="img"></p>
<p><img src="/2021/开源协议介绍/0.7893948360872438.png" alt="img"></p>
<p><img src="/2021/开源协议介绍/0.03694453917716278.png" alt="img"></p>
<p>来源： <a href="https://www.jianshu.com/p/36c1cd4aaeae" target="_blank" rel="noopener">https://www.jianshu.com/p/36c1cd4aaeae</a></p>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>彻底明白VUE修饰符sync</title>
    <url>/2021/%E5%BD%BB%E5%BA%95%E6%98%8E%E7%99%BDVUE%E4%BF%AE%E9%A5%B0%E7%AC%A6sync/</url>
    <content><![CDATA[<blockquote>
<p>对于VUE的初学者来讲，肯定会感觉prop的写法很麻烦，很讨厌！你肯定想如果prop也可以实现双向绑定那怎是一个爽字了得！不过现实是残酷的，如果子组件可以任意修改父组件的内容，那势必会带来数据的混乱，从而造成维护的困扰！毕竟父组件也是有尊严的！</p>
</blockquote>
<p>官方推荐使用一种update:my-prop-name 的模式来替代事件触发，目的是为了优雅而不粗鲁的实现父子组件间的双向绑定！先来完成一个小功能：通过父组件按钮将子组件显示出来，如图：</p>
<p><img src="/2021/彻底明白VUE修饰符sync/webp" alt="img"></p>
<p>父组件代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> </span></span><br><span class="line"><span class="tag">               <span class="attr">value</span>=<span class="string">"我是父组件中的按钮"</span> </span></span><br><span class="line"><span class="tag">               @<span class="attr">click</span>=<span class="string">"show"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">v-show</span>=<span class="string">"isShow"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    import child from "@/components/child"</span><br><span class="line">    export default &#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                isShow:false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            child</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            show()&#123;</span><br><span class="line">                this.isShow=true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子组件child代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">         我是一个子组件，我在红色的海洋里！</span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来加个需求，在子组当中增加一个按钮，通过该按钮来将自已隐藏起来！需要借助父子之间的传值了！如图：</p>
<p><img src="/2021/彻底明白VUE修饰符sync/webp1" alt="img"></p>
<p>父组件代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">value</span>=<span class="string">"我是父组件中的按钮"</span></span></span><br><span class="line"><span class="tag">               @<span class="attr">click</span>=<span class="string">"show"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> @<span class="attr">upIsShow</span>=<span class="string">"changeIsShow"</span> <span class="attr">v-show</span>=<span class="string">"isShow"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    import child from "@/components/child"</span><br><span class="line">    export default &#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                isShow:false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            child</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            show()&#123;</span><br><span class="line">                this.isShow=true;</span><br><span class="line">            &#125;,</span><br><span class="line">            changeIsShow(bol)&#123;</span><br><span class="line">                this.isShow=bol;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子组件代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">         我是一个子组件，我在红色的海洋里！</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"点我隐身"</span> @<span class="attr">click</span>=<span class="string">"upIsShow"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    export default &#123;</span><br><span class="line">        methods:&#123;</span><br><span class="line">            upIsShow()&#123;</span><br><span class="line">                this.$emit("upIsShow",false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果我要将父组件中的事@upIsShow修改为@update:isShow不违法吧：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&lt;child <span class="meta">@update</span>:isShow=<span class="string">"changeIsShow"</span> v-<span class="keyword">show</span>=<span class="string">"isShow"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>子组件的emit自然也要做对应调整：</p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line">upIsShow()&#123;</span><br><span class="line">    <span class="keyword">this</span>.$emit(<span class="string">"update:isShow"</span>,<span class="literal">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下，一切正常！真好！</p>
<p>那么如果现在我将父组件的changeIsShow直接写成匿名函数，也能运行吧：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&lt;child <span class="meta">@update</span>:isShow=<span class="string">"function(bol)&#123;isShow=bol&#125;"</span> v-<span class="keyword">show</span>=<span class="string">"isShow"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>再次运行，一切还是那么美好，真好！</p>
<p>现在我将那匿名函数改成箭头函数，不过分吧：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&lt;child <span class="meta">@update</span>:isShow=<span class="string">"bol=&gt;isShow=bol"</span> v-<span class="keyword">show</span>=<span class="string">"isShow"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>再运行一次，完美，真好！</p>
<p>最后我将上面那行代码做最后一次修改：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><span class="line">&lt;child :isShow.<span class="keyword">sync</span>=<span class="string">"isShow"</span> v-<span class="keyword">show</span>=<span class="string">"isShow"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>至此终于涉及到了sync了。以上代码 :isShow.sync=”isShow”其实是 @update:isShow=”bol=&gt;isShow=bol”语法糖。是其一种简写形式。附上完整代码。<br>父组件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span></span></span><br><span class="line"><span class="tag">               <span class="attr">value</span>=<span class="string">"我是父组件中的按钮"</span></span></span><br><span class="line"><span class="tag">               @<span class="attr">click</span>=<span class="string">"show"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">child</span> <span class="attr">:isShow.sync</span>=<span class="string">"isShow"</span> <span class="attr">v-show</span>=<span class="string">"isShow"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    import child from "@/components/child"</span><br><span class="line">    export default &#123;</span><br><span class="line">        data() &#123;</span><br><span class="line">            return &#123;</span><br><span class="line">                isShow:false</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        components:&#123;</span><br><span class="line">            child</span><br><span class="line">        &#125;,</span><br><span class="line">        methods:&#123;</span><br><span class="line">            show()&#123;</span><br><span class="line">                this.isShow=true;</span><br><span class="line">            &#125;,</span><br><span class="line">            changeIsShow(bol)&#123;</span><br><span class="line">                this.isShow=bol;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>子组件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">         我是一个子组件，我在红色的海洋里！</span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"点我隐身"</span> @<span class="attr">click</span>=<span class="string">"upIsShow"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">    export default &#123;</span><br><span class="line">        methods:&#123;</span><br><span class="line">            upIsShow()&#123;</span><br><span class="line">                this.$emit("update:isShow",false);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后：sync只是给大家伙提供了一种与父组件沟通的思路而已！所以在后面日子里，你如果只是单纯的在子组件当中修改父组件的某个数据时，建议使用sync，简单，快捷，有档次！真好！</p>
]]></content>
      <categories>
        <category>前端</category>
        <category>Vue.js</category>
      </categories>
      <tags>
        <tag>Vue.js</tag>
      </tags>
  </entry>
  <entry>
    <title>群晖DSM使用端口大全</title>
    <url>/2021/%E7%BE%A4%E6%99%96DSM%E4%BD%BF%E7%94%A8%E7%AB%AF%E5%8F%A3%E5%A4%A7%E5%85%A8/</url>
    <content><![CDATA[<table>
<thead>
<tr>
<th>设置工具</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>Synology Assistant</td>
<td>9999、9998、9997</td>
<td>UDP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>备份</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>Data Replicator、Data Replicator II、Data Replicator III</td>
<td>9999、9998、9997、137、138、139、445</td>
<td>TCP</td>
</tr>
<tr>
<td>网络备份</td>
<td>873（数据）、3260（iSCSI LUN）</td>
<td>TCP</td>
</tr>
<tr>
<td>加密的网络备份（远程 Time Backup）</td>
<td>22</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>下载</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>eMule</td>
<td>4662（TCP）、4672（UDP）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>BT</td>
<td>6890 ~ 6999（用于 DSM 版本早于 v2.0.1-3.0401 的机型）；  16881（用于 DSM 版本 v2.0.1 以上的机型）</td>
<td>TCP/UDP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>网页应用程序</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>DSM</td>
<td>5000（HTTP）、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>Download Station</td>
<td>5000</td>
<td>TCP</td>
</tr>
<tr>
<td>Photo Station、Web Station</td>
<td>80（可添加另外的端口）、443（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>Mail Station</td>
<td>80（HTTP）、443（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>Audio Station</td>
<td>5000（HTTP，可添加另外的端口）、5001（HTTPS，可添加另外的端口）、5353（Bonjour 服务）、6001-6010（AirPlay 控制/定时）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>File Station</td>
<td>5000（HTTP，可添加另外的端口）、5001（HTTPS，可添加另外的端口）</td>
<td>TCP</td>
</tr>
<tr>
<td>Surveillance Station</td>
<td>9900（HTTP）、9901（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>媒体服务器</td>
<td>1900（UPnP）、50001（内容浏览）、50002（内容串流）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>Video Station</td>
<td>5000（HTTP）、5001（HTTPS）、9025-9040、 5002、5004、65001（使用 HDHomeRun 网络调谐器的情况下）</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>邮件服务器</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>SMTP</td>
<td>25</td>
<td>TCP</td>
</tr>
<tr>
<td>POP3</td>
<td>110</td>
<td>TCP</td>
</tr>
<tr>
<td>IMAP</td>
<td>143</td>
<td>TCP</td>
</tr>
<tr>
<td>IMAP 含 SSL/TLS</td>
<td>993</td>
<td>TCP</td>
</tr>
<tr>
<td>POP3 含 SSL/TLS</td>
<td>995</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>文件传输</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>FTP、FTP 含 SSL、FTP 含 TLS</td>
<td>21（命令）、20（主动模式的数据连接）、55536-55663（被动模式的数据连接）</td>
<td>TCP</td>
</tr>
<tr>
<td>AFP</td>
<td>548</td>
<td>TCP</td>
</tr>
<tr>
<td>CIFS</td>
<td>smbd：139（netbios-ssn）、445（microsoft-ds）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>Nmbd：137、138</td>
<td>UDP</td>
<td></td>
</tr>
<tr>
<td>NFS</td>
<td>111、892、2049</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>WebDAV、CalDAV</td>
<td>5005、5006（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>iSCSI</td>
<td>3260</td>
<td>TCP</td>
</tr>
<tr>
<td>TFTP</td>
<td>69</td>
<td>UDP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>套件</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>Cloud Station</td>
<td>6690</td>
<td>TCP</td>
</tr>
<tr>
<td>VPN Server（OpenVPN）</td>
<td>1194</td>
<td>UDP</td>
</tr>
<tr>
<td>VPN Server（PPTP）</td>
<td>1723</td>
<td>TCP</td>
</tr>
<tr>
<td>Syslog Server</td>
<td>514（可添加另外的端口）</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>iTunes Server</td>
<td>3689</td>
<td>TCP</td>
</tr>
<tr>
<td>Directory Server</td>
<td>389（LDAP）、636（LDAP 含 SSL）</td>
<td>TCP</td>
</tr>
<tr>
<td>DHCP Server</td>
<td>67、68</td>
<td>UDP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th>行动应用程序</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>DS photo+</td>
<td>80、443（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS audio</td>
<td>5000、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS cam</td>
<td>5000</td>
<td>TCP</td>
</tr>
<tr>
<td>DS file</td>
<td>Android/iOS 设备：5005、5006（HTTPS） Windows Phone：5000</td>
<td>TCP</td>
</tr>
<tr>
<td>DS finder</td>
<td>5000（HTTP）、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS video</td>
<td>5000（HTTP）、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS download</td>
<td>5000（HTTP）、5001（HTTPS）</td>
<td>TCP</td>
</tr>
<tr>
<td>DS cloud</td>
<td>6690</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><strong>打印机、UPS 和外围设备</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>LPR</td>
<td>515</td>
<td>UDP</td>
</tr>
<tr>
<td>网络打印机（IPP）/CUPS</td>
<td>631</td>
<td>TCP</td>
</tr>
<tr>
<td>Bonjour</td>
<td>5353</td>
<td>UDP</td>
</tr>
<tr>
<td>网络 MFP</td>
<td>3240-3259</td>
<td>TCP</td>
</tr>
<tr>
<td>UPS</td>
<td>3493</td>
<td>TCP</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th><strong>系统</strong></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>类型</strong></td>
<td><strong>端口号码</strong></td>
<td><strong>协议</strong></td>
</tr>
<tr>
<td>SSH/SFTP</td>
<td>22</td>
<td>TCP</td>
</tr>
<tr>
<td>Telnet</td>
<td>23</td>
<td>TCP</td>
</tr>
<tr>
<td>资源监视器/SNMP</td>
<td>161</td>
<td>TCP/UDP</td>
</tr>
<tr>
<td>MySQL</td>
<td>3306</td>
<td>TCP</td>
</tr>
<tr>
<td>LDAP</td>
<td>389、636（SLAPD）</td>
<td>TCP</td>
</tr>
</tbody>
</table>
]]></content>
      <categories>
        <category>network</category>
        <category>NAS</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>群晖Photo_Station_Video_Station索引无视频缩略图</title>
    <url>/2021/%E7%BE%A4%E6%99%96Photo-Station-Video-Station%E7%B4%A2%E5%BC%95%E6%97%A0%E8%A7%86%E9%A2%91%E7%BC%A9%E7%95%A5%E5%9B%BE/</url>
    <content><![CDATA[<h2 id="群晖（Synology）Photo-Station索引无视频缩略图"><a href="#群晖（Synology）Photo-Station索引无视频缩略图" class="headerlink" title="群晖（Synology）Photo Station索引无视频缩略图"></a>群晖（Synology）Photo Station索引无视频缩略图</h2><h2 id="一、个人环境"><a href="#一、个人环境" class="headerlink" title="一、个人环境"></a>一、个人环境</h2><p>黑群晖DSM6.1.4</p>
<h2 id="二、解决方式"><a href="#二、解决方式" class="headerlink" title="二、解决方式"></a>二、解决方式</h2><p>目前群晖DSM自带的ffmpeg版本是 2.7.1 ，通过社区第三方安装 4.2.4 版本的ffmpeg，即可实现Photo Station索引生成视频缩略图</p>
<h2 id="三、解决步骤"><a href="#三、解决步骤" class="headerlink" title="三、解决步骤"></a>三、解决步骤</h2><h3 id="1、开启SSH登录功能"><a href="#1、开启SSH登录功能" class="headerlink" title="1、开启SSH登录功能"></a>1、开启SSH登录功能</h3><p> <img src="/2021/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424093136937-1495485162.jpg" alt="img"></p>
<h3 id="2、ssh方式登录群辉"><a href="#2、ssh方式登录群辉" class="headerlink" title="2、ssh方式登录群辉"></a>2、ssh方式登录群辉</h3><p>ssh客户端比较多，常见的有Putty、SecureCRT（付费），以Putty为例介绍</p>
<p><img src="/2021/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424094227293-616185227.jpg" alt="img"></p>
<p>填入“群辉IP地址”和“端口号”，单击“open”</p>
<p>使用管理员账户和密码登录</p>
<h3 id="3、备份历史版本ffmpeg"><a href="#3、备份历史版本ffmpeg" class="headerlink" title="3、备份历史版本ffmpeg"></a>3、备份历史版本ffmpeg</h3><p>ssh命令行窗口运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mv /usr/bin/ffmpeg /usr/bin/ffmpeg_bak</span><br></pre></td></tr></table></figure>
<h3 id="4、安装新版本ffmpeg"><a href="#4、安装新版本ffmpeg" class="headerlink" title="4、安装新版本ffmpeg"></a>4、安装新版本ffmpeg</h3><ul>
<li>打开套件中心 – 右上角设置 – 常规 – 勾选任何发行者</li>
</ul>
<p><img src="/2021/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424095118933-317675568.jpg" alt="img"></p>
<ul>
<li>设置菜单 – 套件来源 – 新增</li>
</ul>
<p><img src="/2021/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424094953347-1914197471.jpg" alt="img"></p>
<p>名称：随便起名</p>
<p>位置：<a href="http://packages.synocommunity.com" target="_blank" rel="noopener">http://packages.synocommunity.com</a></p>
<ul>
<li>安装新版本ffmpeg</li>
</ul>
<p><img src="/2021/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424100424865-1954461477.jpg" alt="img"></p>
<ul>
<li>拷贝</li>
</ul>
<p>ssh命令行窗口运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo cp -r /usr/<span class="built_in">local</span>/ffmpeg/bin/ffmpeg /usr/bin/ffmpeg</span><br></pre></td></tr></table></figure>
<ul>
<li>重写索引</li>
</ul>
<p>控制面板 – 索引服务 – 索引文件夹，勾选照片+影片，保存，然后点击旁边的“重建索引”按钮</p>
<p><img src="/2021/群晖Photo-Station-Video-Station索引无视频缩略图/image-20210703205125971.png" alt></p>
<p>索引需要较长时间，等待其结束</p>
<h2 id="群晖（Synology）video-Station索引无视频缩略图"><a href="#群晖（Synology）video-Station索引无视频缩略图" class="headerlink" title="群晖（Synology）video Station索引无视频缩略图"></a>群晖（Synology）video Station索引无视频缩略图</h2><h2 id="一、个人环境-1"><a href="#一、个人环境-1" class="headerlink" title="一、个人环境"></a>一、个人环境</h2><p>黑群晖DSM6.1.4</p>
<h2 id="二、解决方式-1"><a href="#二、解决方式-1" class="headerlink" title="二、解决方式"></a>二、解决方式</h2><p>1、参考上文，下载新版本ffmpeg</p>
<p>2、编写python脚本，调用ffmpeg截取视频图像</p>
<h2 id="三、解决步骤-1"><a href="#三、解决步骤-1" class="headerlink" title="三、解决步骤"></a>三、解决步骤</h2><p>目前群晖DSM自带的ffmpeg版本是 2.7.1 ，通过社区第三方安装 4.2.4 版本的ffmpeg，Photo Station索引后，可以生成视频缩略图；但Video Station索引后，仍然无法生成视频缩略图。</p>
<p>个人的解决方式为编写python转换脚本</p>
<h3 id="1、下载安装新版ffmpeg"><a href="#1、下载安装新版ffmpeg" class="headerlink" title="1、下载安装新版ffmpeg"></a>1、下载安装新版ffmpeg</h3><h3 id="2、编写python转换脚本"><a href="#2、编写python转换脚本" class="headerlink" title="2、编写python转换脚本"></a>2、编写python转换脚本</h3><p>创建脚本文件photo_thumb.py</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding:UTF-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_type</span><span class="params">(filename,video_list)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    检查是否为视频文件</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    array = map(filename.endswith,video_list)</span><br><span class="line">    <span class="keyword">if</span> <span class="literal">True</span> <span class="keyword">in</span> array:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_capture_delay_time</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取截取图片在视频中位置</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(file_path):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    file_size = os.path.getsize(file_path)</span><br><span class="line">    <span class="keyword">if</span> file_size &lt;= <span class="number">1</span> * <span class="number">1024</span> * <span class="number">1024</span>:                                <span class="comment"># 视频大小 &lt;= 1MB，截取视频第1S图片</span></span><br><span class="line">        delay_time = <span class="number">1</span></span><br><span class="line">    <span class="keyword">elif</span> file_size &lt;= <span class="number">4</span> * <span class="number">1024</span> * <span class="number">1024</span>:                              <span class="comment"># 1MB &lt; 视频大小 &lt;= 4MB，截取视频第5S图片</span></span><br><span class="line">        delay_time = <span class="number">5</span></span><br><span class="line">    <span class="keyword">elif</span> file_size &lt;= <span class="number">50</span> * <span class="number">1024</span> * <span class="number">1024</span>:                             <span class="comment"># 4MB &lt; 视频大小 &lt;= 50MB，截取视频第10S图片</span></span><br><span class="line">        delay_time = <span class="number">10</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        delay_time = <span class="number">20</span>                                             <span class="comment"># 50MB &lt; 视频大小，截取视频第20S图片</span></span><br><span class="line">    <span class="keyword">return</span> delay_time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_file_existed</span><span class="params">(file_path)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    检查文件是否存在</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">if</span> os.path.exists(file_path):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_file_pre</span><span class="params">(file_name)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    获取文件名前缀，如my_video.mp4，返回my_video</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    video_name_list = os.path.splitext(file_name)</span><br><span class="line">    <span class="keyword">if</span> len(video_name_list) == <span class="number">2</span>:</span><br><span class="line">        video_name_pre = video_name_list[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        video_name_pre = <span class="literal">False</span></span><br><span class="line">    <span class="keyword">return</span> video_name_pre</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_thumb</span><span class="params">(file_path,video_types)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    遍历文件夹，调用ffmpeg截取视频图片</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">for</span> dir_path,dir_names,file_names <span class="keyword">in</span> os.walk(file_path):</span><br><span class="line">        <span class="keyword">for</span> name <span class="keyword">in</span> file_names:</span><br><span class="line">            <span class="comment"># print("*"*20)</span></span><br><span class="line">            <span class="comment"># print(name)</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> check_type(name,video_types):                    <span class="comment"># 不是视频文件，跳过本地迭代，继续下一次迭代</span></span><br><span class="line">                print(<span class="string">"not video,continue next"</span>)</span><br><span class="line">                <span class="keyword">continue</span></span><br><span class="line">            video_full_path = os.path.join(dir_path, name)</span><br><span class="line">            video_name_pre = get_file_pre(name)</span><br><span class="line">            <span class="keyword">if</span> video_name_pre:                                      <span class="comment"># 如果缩略图已经存在，跳过本地迭代，继续下一次迭代</span></span><br><span class="line">                pic_name = <span class="string">'%s%s'</span> % (video_name_pre,<span class="string">'.jpg'</span>)</span><br><span class="line">                picture_full_path = os.path.join(dir_path,pic_name)</span><br><span class="line">                ret = check_file_existed(picture_full_path)</span><br><span class="line">                <span class="keyword">if</span> ret:</span><br><span class="line">                    print(<span class="string">"%s existed,continue next"</span> % picture_full_path)</span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                delay_time = get_capture_delay_time(video_full_path)</span><br><span class="line">                <span class="keyword">if</span> <span class="keyword">not</span> delay_time:                                  <span class="comment"># 获取文件大小失败，跳过本地迭代，继续下一次迭代</span></span><br><span class="line">                    <span class="keyword">continue</span></span><br><span class="line">                shell = <span class="string">'ffmpeg -i "%s" -y -ss %s -frames:v 1 "%s"'</span> % \</span><br><span class="line">                        (video_full_path, delay_time,picture_full_path)</span><br><span class="line">                <span class="comment"># print("#"*20)</span></span><br><span class="line">                print(shell)</span><br><span class="line">                os.system(shell)</span><br><span class="line">                print(<span class="string">"%s capture success"</span> % picture_full_path)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">    <span class="comment"># 当前路径中执行脚本</span></span><br><span class="line">    file_path = sys.path[<span class="number">0</span>]</span><br><span class="line">    video_types = [<span class="string">'.mp4'</span>,<span class="string">'.avi'</span>,<span class="string">'.wmv'</span>,<span class="string">'.mkv'</span>,<span class="string">'.flv'</span>]</span><br><span class="line">    make_thumb(file_path,video_types)</span><br></pre></td></tr></table></figure>
<p> 也可参考如下链接，直接下载</p>
<p>链接：<a href="https://pan.baidu.com/s/1iHW_3GvutSz6d_KPeyxvlA" target="_blank" rel="noopener">https://pan.baidu.com/s/1iHW_3GvutSz6d_KPeyxvlA</a> 提取码：3uok</p>
<h3 id="3、上传至群辉共享文件夹"><a href="#3、上传至群辉共享文件夹" class="headerlink" title="3、上传至群辉共享文件夹"></a>3、上传至群辉共享文件夹</h3><ul>
<li>打开File Station，上传脚本文件photo_thumb.py至需要转换的文件夹，如video</li>
</ul>
<p><img src="/2021/群晖Photo-Station-Video-Station索引无视频缩略图/793034-20210424104410603-2139857840.jpg" alt="img"></p>
<ul>
<li>脚本执行时，会自动遍历子文件夹，所以只需在最外层文件夹执行即可</li>
</ul>
<h3 id="4、运行脚本"><a href="#4、运行脚本" class="headerlink" title="4、运行脚本"></a>4、运行脚本</h3><p>ssh登录群辉</p>
<p>ssh命令行窗口运行如下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /</span><br><span class="line"><span class="built_in">cd</span> volume1/video/</span><br><span class="line">sudo python3 photo_thumb.py</span><br></pre></td></tr></table></figure>
<p>注：如上脚本采用python3执行，python2未实验</p>
]]></content>
      <categories>
        <category>network</category>
        <category>NAS</category>
      </categories>
      <tags>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title>路由器端口转发访问NAS</title>
    <url>/2021/%E8%B7%AF%E7%94%B1%E5%99%A8%E7%AB%AF%E5%8F%A3%E8%BD%AC%E5%8F%91%E8%AE%BF%E9%97%AENAS/</url>
    <content><![CDATA[<p>如果<strong>路由器具有公网IP</strong>，则访问家里的NAS时，不需要通过VPS进行转发，直接在路由器中设置端口转发即可。</p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ol>
<li>路由器具有公网IP</li>
<li>申请一个域名例如aaa.com，并设置了解析 aaa.com -&gt; 路由器公网IP</li>
</ol>
<h2 id="设置IP与MAC地址绑定"><a href="#设置IP与MAC地址绑定" class="headerlink" title="设置IP与MAC地址绑定"></a>设置IP与MAC地址绑定</h2><p>以华硕AC86U为例，开启IP与MAC地址绑定为：</p>
<p><img src="/2021/路由器端口转发访问NAS/Snipaste_2021-04-06_22-15-14.png" alt="Snipaste_2021-04-06_22-15-14"></p>
<h2 id="设置端口转发"><a href="#设置端口转发" class="headerlink" title="设置端口转发"></a>设置端口转发</h2><p>以华硕AC86U为例，开启端口转发的设置为：</p>
<p><img src="/2021/路由器端口转发访问NAS/Snipaste_2021-04-06_21-50-25.png" alt="Snipaste_2021-04-06_21-50-25"></p>
<h2 id="设置DDNS"><a href="#设置DDNS" class="headerlink" title="设置DDNS"></a>设置DDNS</h2><p>路由器的外网动态IP是不断变化的，所以域名解析设置也需要同步更新，使用DDNS服务，可以在路由器公网IP变化时，自动同步域名解析的配置，我们就可以只记住一个域名就可以访问NAS的服务。</p>
<p>以华硕ac86u为例，在软件中心安装<strong>Aliddns</strong>插件，设置如下图：</p>
<p><img src="/2021/路由器端口转发访问NAS/Snipaste_2021-04-06_21-57-55.png" alt="Snipaste_2021-04-06_21-57-55"></p>
<h2 id="访问地址"><a href="#访问地址" class="headerlink" title="访问地址"></a>访问地址</h2><p>DS file、DS finder、DS audio 官方使用5000端口 ， DS photo官方使用80端口</p>
<p>运营商封锁了aaa.com域名的80、443端口，所以不能访问aaa.com的80和443端口，不需要在端口转发中设置这两个端口的配置。</p>
<p>web端访问管理界面 <a href="http://aaa.com:5000/" target="_blank" rel="noopener">http://aaa.com:5000</a> 端口号不能省略</p>
<p>移动端APP填入以下地址：</p>
<p>ds file aaa.com:5000                :5000能省略，省略的话，APP可能默认使用5000端口<br>ds audio aaa.com:5000           :5000能省略，省略的话，APP可能默认使用5000端口<br>ds photo aaa.com:8008           :8008不能省略，省略的话，APP可能默认使用80端口<br>android drive aaa.com:5000   :5000能省略，省略的话，APP可能默认使用5000端口</p>
<p>windows drive   aaa.com:6690   不能省略端口</p>
]]></content>
      <categories>
        <category>network</category>
        <category>NAS</category>
      </categories>
      <tags>
        <tag>路由器</tag>
        <tag>NAS</tag>
        <tag>端口转发</tag>
      </tags>
  </entry>
  <entry>
    <title>远程桌面</title>
    <url>/2021/%E8%BF%9C%E7%A8%8B%E6%A1%8C%E9%9D%A2/</url>
    <content><![CDATA[<h2 id="远程访问-Android"><a href="#远程访问-Android" class="headerlink" title="远程访问 Android"></a>远程访问 Android</h2><p>小米通话：小米手机之间远程软件，米聊已停服。</p>
<h2 id="远程访问-Windows"><a href="#远程访问-Windows" class="headerlink" title="远程访问 Windows"></a>远程访问 Windows</h2><p>远程软件主要有： </p>
<p><strong>向日葵</strong> 免费，多用时收费</p>
<p><strong>teamviewer</strong> 少用时免费，多用时可能检测为商业用途</p>
<p><strong>Anydesk</strong> 同是德国软件，teamviewer 公司里面的人再创业出品</p>
<p><strong>VNC Server</strong>(被控端) + <strong>VNC Viewer</strong>(控制端) </p>
<p><strong>microsoft remote desktop</strong> 和 <strong>远程桌面</strong>(system32\mstsc.exe) 微软官方出品 <strong>需要局域网环境或内网穿透</strong></p>
<h3 id="windows端设置"><a href="#windows端设置" class="headerlink" title="windows端设置"></a>windows端设置</h3><p>本文介绍在使用<strong>microsoft remote desktop</strong> 或  <strong>远程桌面</strong>(system32\mstsc.exe) 时windows需要设置的配置。</p>
<ol>
<li><p>先确定被遥控的电脑的系统必须是Professional或Enterprise以上版本，<strong>家庭版不支持远程桌面</strong>。</p>
</li>
<li><p>确保自己的系统登录是带有密码的，<strong>采用outlook网络账号登录</strong>，而不是本地账户登录。</p>
</li>
<li><p><strong>打开控制面板 -&gt;系统 -&gt;点击远程设置，在“远程设置”tab页中</strong> 点击允许远程连接到此计算机，并且勾上仅允许运行使用网络级别身份验证的远程桌面的计算机连接（建议）。</p>
<p><img src="/2021/远程桌面/1.png" alt="1"></p>
<ol start="4">
<li>点击选择用户，可以看到网络账户，例如：<a href="mailto:aaa@outlook.com" target="_blank" rel="noopener">aaa@outlook.com</a>已经有访问权。</li>
</ol>
</li>
</ol>
<p><img src="/2021/远程桌面/Snipaste_2021-04-06_13-25-44.png" alt="Snipaste_2021-04-06_13-25-44"></p>
<ol start="5">
<li>接下来是最重要的一步，依次打开控制面板 -&gt;Windows Defender 防火墙→允许应用或功能通过Windows Defender防火墙，点击更改设置，找到远程桌面（一般为最下方），将后面的两个框都勾上，点击确定保存。</li>
</ol>
<p><img src="/2021/远程桌面/22.png" alt="22"></p>
<h3 id="局域网访问"><a href="#局域网访问" class="headerlink" title="局域网访问"></a>局域网访问</h3><ol>
<li><p>查看自己的内网IP地址，按Win+R，输入cmd，跳出对话框，输入ipconfig，在跳出的一筐数字中找到一栏，IPv4地址，记录下后面的地址。</p>
</li>
<li><p>打开Microsoft Remote Desktop，PC和Android端都有该软件。或  远程桌面(system32\mstsc.exe) PC端<br>PC name 填入主机的局域网IP，User name 填入网络outlook账号和密码，入下图所示，后面3389为默认端口，可省略。</p>
</li>
</ol>
<p><img src="/2021/远程桌面/Snipaste_2021-04-06_19-01-00.png" alt="Snipaste_2021-04-06_19-01-00"></p>
<h3 id="广域网访问"><a href="#广域网访问" class="headerlink" title="广域网访问"></a>广域网访问</h3><h4 id="路由器设置-frp内网穿透"><a href="#路由器设置-frp内网穿透" class="headerlink" title="路由器设置-frp内网穿透"></a>路由器设置-frp内网穿透</h4><p><strong>路由器没有公网IP</strong>，在外网访问家里的电脑，需要在路由器中对frpc进行配置，在VPS进行frps设置（自己的局域网可以利用路由器24小时开机的特性，进行frpc配置，公司网络没这个条件）</p>
<p>唤醒端应用请求vps 3389端口，vps转发到路由器所在的局域网中IP为192.168.50.100的主机的3389端口进行远程桌面。</p>
<p>WOL唤醒后才能远程访问，使用远程桌面进行访问，走vps主机流量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[remote desktop]</span><br><span class="line">type = tcp</span><br><span class="line">local_ip = 192.168.50.100</span><br><span class="line">local_port = 3389 #通常本地采用3389进行远程访问</span><br><span class="line">remote_port = 3389</span><br></pre></td></tr></table></figure>
<h4 id="路由器设置-端口转发"><a href="#路由器设置-端口转发" class="headerlink" title="路由器设置-端口转发"></a>路由器设置-端口转发</h4><p><strong>路由器有公网IP</strong>，在外网访问家里的电脑，不需要在路由器设置frpc，只需要设置端口转发，如下图：</p>
<p><img src="/2021/远程桌面/Snipaste_2021-04-06_19-14-42.png" alt="Snipaste_2021-04-06_19-14-42"></p>
<p>唤醒程序直接根据路由器IP，请求路由器IP的3389 端口，不需要经过VPS转发，速度更快。</p>
<h4 id="唤醒端设置"><a href="#唤醒端设置" class="headerlink" title="唤醒端设置"></a>唤醒端设置</h4><p>打开Microsoft Remote Desktop，PC name 填入域名:3389   User name 填入网络outlook账号和密码</p>
<p><img src="/2021/远程桌面/Snipaste_2021-04-06_19-01-19.png" alt="Snipaste_2021-04-06_19-01-19"></p>
]]></content>
      <categories>
        <category>network</category>
        <category>远程桌面</category>
      </categories>
      <tags>
        <tag>frp</tag>
        <tag>端口转发</tag>
        <tag>远程桌面</tag>
      </tags>
  </entry>
  <entry>
    <title>雷鸟电视在线安装软件</title>
    <url>/2021/%E9%9B%B7%E9%B8%9F%E7%94%B5%E8%A7%86%E5%9C%A8%E7%BA%BF%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>新买的雷鸟R625C电视往往默认是无法安装第三方应用的，即使用U盘安装了第三方应用，应用也没有升级权限。另外，也无法通过沙发管家等应用市场来安装应用。接下来说说如何使用adb工具打开雷鸟电视的第三方应用安装权限。</p>
<h2 id="ADB安装"><a href="#ADB安装" class="headerlink" title="ADB安装"></a>ADB安装</h2><p>ADB的全称为Android Debug Bridge，通过ADB工具，我们可以直接操作管理android模拟器或者真实的android设备（如安卓手机、机顶盒）。它主要有以下几种作用：<br>（1）运行设备的shell(命令行)<br>（2）管理模拟器或设备的端口映射<br>（3）计算机和android设备之间上传/下载文件<br>（4）将本地apk软件安装至android模拟器或android设备</p>
<h3 id="下载Android-Platform-Tools"><a href="#下载Android-Platform-Tools" class="headerlink" title="下载Android Platform Tools"></a>下载Android Platform Tools</h3><p>到Android开发官网下载Android Platform Tools并解压，解压后可以看到文件夹platform-tools，里面包含adb调试工具。<br> <img src="/2021/雷鸟电视在线安装软件/image-20210331111636482.png" alt="image-20210331111636482"></p>
<h3 id="环境变量设置"><a href="#环境变量设置" class="headerlink" title="环境变量设置"></a>环境变量设置</h3><p>打开“我的电脑-&gt;属性-&gt;系统高级设置-&gt;环境变量”，在Path变量中添加platform-tools文件夹的路径：</p>
<p><img src="/2021/雷鸟电视在线安装软件/image-20210331111701288.png" alt="image-20210331111701288"></p>
<h3 id="运行ADB"><a href="#运行ADB" class="headerlink" title="运行ADB"></a>运行ADB</h3><p>打开命令行窗口，输入adb，能打印出adb的版本号和用法，即为安装成功。</p>
<p> <img src="/2021/雷鸟电视在线安装软件/image-20210331111724426.png" alt="image-20210331111724426"></p>
<h2 id="打开电视的adb调试开关"><a href="#打开电视的adb调试开关" class="headerlink" title="打开电视的adb调试开关"></a>打开电视的adb调试开关</h2><p>进入设置-&gt;系统-&gt;系统信息，遥控器依次按下“上”、“下”、“左”、“右”，即可看到页面中跳出adb开关，将ADB设为开启状态即可：</p>
<p><img src="/2021/雷鸟电视在线安装软件/image-20210331111929404.png" alt="image-20210331111929404"></p>
<h2 id="abd工具打开电视权限"><a href="#abd工具打开电视权限" class="headerlink" title="abd工具打开电视权限"></a>abd工具打开电视权限</h2><ol>
<li><p>首先将电脑和雷鸟电视连接到同一网络下。</p>
</li>
<li><p>查看雷鸟电视的ip地址，我的这台电视的ip为192.168.0.129</p>
</li>
<li><p>根据上一步获得的ip地址，在windows命令行执行<code>adb connect 192.168.0.129:5555</code>连接到雷鸟电视：</p>
</li>
<li><p>执行adb shell进入shell模式，然后执行以下两条命令就可以成功打开第三方应用安装权限：<br><code>setprop persist.tcl.debug.installapk 1</code><br><code>setprop persist.tcl.installapk.enable 1</code></p>
<p><img src="/2021/雷鸟电视在线安装软件/image-20210331112424137.png" alt="image-20210331112424137"></p>
</li>
<li><p>然后再尝试用电视安装或升级第三方应用，第三方应用已经可以正常安装和升级，用当贝极速版或者沙发管家下载就可以了。</p>
</li>
<li><p>如果需要直接通过adb工具安装应用，先按照步骤1~3连接到电视，再执行<code>adb install</code>命令安装应用即可：<br><code>adb install XXX.apk</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>network</category>
        <category>电视</category>
      </categories>
      <tags>
        <tag>电视</tag>
      </tags>
  </entry>
</search>
